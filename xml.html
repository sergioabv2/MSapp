   
<html lang="es"> 
<head>  
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Reproductor MusicXML</title>
   <link href="https://cdn.jsdelivr.net/npm/remixicon@4.5.0/fonts/remixicon.css" rel="stylesheet"/>
   <script src="https://unpkg.com/@phosphor-icons/web"></script>
<style>
    /* =========================================
       1. VARIABLES GLOBALES (FUSIONADAS)
       ========================================= */
    :root {
      /* --- Variables NUEVAS (Interfaz Top Bar) --- */
      --primary-bg: #ffffff;
      --secondary-bg: #f8f9fa;
      --border-color: #e6e6e6;
      --text-main: #1f1f1f;
      --text-light: #757575;
      
      /* Colores de Acento */
      --accent-blue: #1a73e8;       /* Azul Google/Pro */
      --accent-red: #ea4335;        /* Rojo Grabación/Stop */
      --accent-green: #0f9d58;      /* Verde Inicio/Éxito */
      --accent-orange: #f9ab00;     /* Naranja (Mano Izquierda) */
      
      /* Dimensiones UI */
      --bar-height: 60px;
      --panel-height: 56px;
      --knob-size: 14px;

      /* --- Variables ANTIGUAS (Piano & Waterfall - NO TOCAR) --- */
      --primary-color: #3498db;
      --primary-glow: rgba(52, 152, 219, 0.6);
      --piano-height: 122px;
      --piano-bottom: 0px;
      --key-white-height: 90px;
      --key-black-height: 58px;
    }

    /* Media query original para pantallas grandes */
    @media (min-width: 769px) {
        :root {
            --piano-height: 125px; 
            --piano-height2: 110px; 
            --key-white-height: 90px; 
            --key-black-height: 58px; 
        }
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #f0f2f5; /* Fondo gris claro más moderno */
      color: var(--text-main);
      padding-bottom: 160px; /* Espacio para el piano fijo abajo */
      overflow-x: hidden;
    }

    /* =========================================
       2. TOP BAR (NUEVO DISEÑO PRO)
       ========================================= */
    #top-bar-container {
      position: sticky; top: 0; z-index: 1000;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      box-shadow: 0 1px 4px rgba(0,0,0,0.05);
    }

    .main-bar {
      height: var(--bar-height);
      display: flex; justify-content: space-between; align-items: center;
      padding: 0 24px; border-bottom: 1px solid var(--border-color);
      position: relative;
    }

    /* Info Canción */
    .song-info { display: flex; flex-direction: column; gap: 2px; }
    .song-title { font-size: 16px; font-weight: 600; color: var(--text-main); line-height: 1.2; }
    .song-subtitle { font-size: 12px; color: var(--text-light); font-weight: 400; line-height: 1.2; }

    /* Controles Centrales */
    .controls-center {
      position: absolute; left: 50%; transform: translateX(-50%);
      display: flex; gap: 8px; align-items: center;
    }

     .btn-start {
      background: var(--accent-green);
      color: white;
      border: none;
      border-radius: 20px;
      padding: 10px 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 2px 6px rgba(15, 157, 88, 0.3);
      transition: all 0.2s ease;
    }

    .btn-start:hover {
      background: #0d8a4d;
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(15, 157, 88, 0.4);
    }

    .btn-start:active {
      transform: translateY(0);
    }

    .btn-start i {
      font-size: 18px;
    }

    .control-divider { width: 1px; height: 24px; background: #e0e0e0; margin: 0 4px; }

    .learning-btn {
      width: 36px; height: 36px; border-radius: 50%; background: transparent;
      border: 1px solid #e0e0e0; color: var(--text-main); display: flex;
      align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; font-size: 18px;
    }
    .learning-btn:hover { background: #f5f5f5; }
    .learning-btn.active { background: #e8f0fe; border-color: var(--accent-blue); color: var(--accent-blue); }
    #left-hand-only-btn.active { background: #ffeecf; border-color: var(--accent-orange); color: var(--accent-orange); }
    .learning-btn .hand-left { transform: scaleX(-1); }

    /* Controles Derecha */
    .controls-right { display: flex; gap: 8px; align-items: center; position: relative; }

    .tool-btn {
      background: transparent; border: 1px solid transparent; border-radius: 6px;
      padding: 0 12px; height: 32px; font-size: 13px; font-weight: 500;
      color: var(--text-light); display: flex; align-items: center; gap: 6px;
      cursor: pointer; transition: all 0.2s ease; position: relative;
    }
    .tool-btn:hover { background: #f5f5f5; color: var(--text-main); }
    .tool-btn.active { background: #e8f0fe; color: var(--accent-blue); }
    .tool-btn.recording.active { background: #fce8e6; color: var(--accent-red); }
    .tool-btn i { font-size: 18px; }

    .close-btn {
      width: 32px; height: 32px; border-radius: 50%; background: #f1f1f1; border: none;
      color: #555; display: flex; align-items: center; justify-content: center;
      cursor: pointer; margin-left: 8px; transition: 0.2s;
    }
    .close-btn:hover { background: #e0e0e0; color: #000; }

    /* =========================================
       3. MODALES FLOTANTES (NUEVO)
       ========================================= */
    .modal-popup {
      position: absolute; top: calc(100% + 12px); right: 0; background: white;
      border: 1px solid var(--border-color); border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12); padding: 16px; min-width: 240px;
      opacity: 0; transform: translateY(-10px); pointer-events: none;
      transition: all 0.2s cubic-bezier(0.165, 0.84, 0.44, 1); z-index: 2000;
    }
    .modal-popup.is-open { opacity: 1; transform: translateY(0); pointer-events: all; }
    
    .modal-header { 
      font-size: 11px; font-weight: 700; color: var(--text-light); 
      text-transform: uppercase; border-bottom: 1px solid #f0f0f0; 
      padding-bottom: 8px; margin-bottom: 12px; letter-spacing: 0.5px;
    }
    
    .modal-option { padding: 8px 0; display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
    .modal-label { display: flex; align-items: center; gap: 10px; font-size: 14px; color: var(--text-main); }
    .modal-label i { font-size: 18px; color: var(--text-light); }
    
    .toggle-switch { width: 36px; height: 20px; background: #e0e0e0; border-radius: 10px; position: relative; cursor: pointer; transition: background 0.2s; }
    .toggle-switch.active { background: var(--accent-blue); }
    .toggle-switch::after { content: ''; position: absolute; width: 16px; height: 16px; background: white; border-radius: 50%; top: 2px; left: 2px; transition: transform 0.2s; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
    .toggle-switch.active::after { transform: translateX(16px); }

    .counter-control { display: flex; align-items: center; gap: 4px; background: #f5f5f5; border-radius: 6px; padding: 2px; border: 1px solid #eee; }
    .counter-btn { width: 28px; height: 28px; border: none; background: transparent; cursor: pointer; display: flex; align-items: center; justify-content: center; color: var(--text-light); border-radius: 4px; }
    .counter-btn:hover { background: #fff; color: var(--text-main); box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
    .counter-value { font-family: 'SF Mono', 'Menlo', 'monospace'; font-size: 13px; font-weight: 600; min-width: 44px; text-align: center; }

    /* =========================================
       4. PANEL SECUNDARIO (TIMELINE & SLIDER)
       ========================================= */
    .secondary-panel { background-color: var(--primary-bg); border-bottom: 1px solid var(--border-color); height: var(--panel-height); }
    .panel-content { height: 100%; padding: 0 24px; display: flex; align-items: center; width: 100%; }
    .timeline-layout { display: flex; align-items: center; width: 100%; gap: 16px; }

    .playback-btn {
      width: 36px; height: 36px; border-radius: 50%; background: var(--accent-blue);
      border: none; color: white; display: flex; align-items: center; justify-content: center;
      cursor: pointer; transition: all 0.2s ease; font-size: 18px; flex-shrink: 0; box-shadow: 0 2px 5px rgba(26, 115, 232, 0.3);
    }
    .playback-btn:hover { background: #1557b0; transform: scale(1.05); }

    .time-badge {
      font-family: 'SF Mono', 'Menlo', 'monospace'; font-size: 13px; color: var(--text-main);
      background: #f5f5f5; padding: 4px 10px; border-radius: 6px; display: flex; gap: 6px;
      align-items: center; border: 1px solid #eee; flex-shrink: 0;
    }
    .measure-count { color: var(--text-light); font-size: 11px; margin-left: 4px; padding-left: 6px; border-left: 1px solid #ddd; }

    /* Slider Personalizado */
    .track-container { flex: 1; position: relative; height: 24px; display: flex; align-items: center; cursor: pointer; }
    /* Estilo para cuando estamos seleccionando el final del loop en el timeline */
.track-container.selecting-loop {
    cursor: crosshair;
}

.track-container.selecting-loop .rail {
    background-color: #d0e1fd; /* Un azul muy clarito para indicar zona activa */
}
#loop-dropdown {
    top: calc(100% + 8px);
    z-index: 150;
}
    .rail { position: absolute; width: 100%; height: 4px; background: #e0e0e0; border-radius: 2px; }
    .fill { position: absolute; height: 4px; background: var(--accent-blue); border-radius: 2px; width: 0%; pointer-events: none; }
    .loop-region { position: absolute; height: 4px; background: var(--accent-blue); opacity: 0; display: none; pointer-events: none; transition: opacity 0.2s; }
    .loop-region.active { display: block; opacity: 0.3; }
    
  .loop-pin { 
    position: absolute; 
    width: 2px; 
    height: 16px; /* Aumentado para que sobresalga más */
    background: var(--accent-blue); 
    top: 12px; 
    transform: translateX(-1px); 
    opacity: 0; 
    transition: opacity 0.2s; 
    pointer-events: none; 
    z-index: 15;
}
.loop-pin.visible { opacity: 1; }

.loop-pin::before {
    content: attr(data-measure);
    position: absolute;
    top: 18px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--accent-blue);
    color: white;
    font-size: 10px;
    font-weight: 700;
    padding: 2px 6px;
    border-radius: 4px;
    white-space: nowrap;
    box-shadow: 0 2px 6px rgba(26, 115, 232, 0.3);
}

#loop-dropdown {
    top: calc(100% + 8px);
    left: auto !important;
    right: 0 !important; /* Alineado a la derecha del botón */
    bottom: auto !important;
    z-index: 150;
}

/* NUEVO: Estilos para el thumb arrastrable del loop */
.loop-thumb {
    position: absolute;
    width: 20px;
    height: 20px;
    background: white;
    border: 3px solid var(--accent-blue);
    border-radius: 50%;
    top: 2px;
    transform: translateX(-50%);
    cursor: grab;
    z-index: 20;
    opacity: 0;
    transition: opacity 0.2s, transform 0.1s;
    box-shadow: 0 2px 8px rgba(26, 115, 232, 0.4);
}

.loop-thumb:hover {
    transform: translateX(-50%) scale(1.15);
}

.loop-thumb:active {
    cursor: grabbing;
    background: var(--accent-blue);
}

.loop-thumb.visible {
    opacity: 1;
}

/* Número dentro del thumb */
.loop-thumb::after {
    content: attr(data-measure);
    position: absolute;
    top: 24px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--accent-blue);
    color: white;
    font-size: 10px;
    font-weight: 700;
    padding: 2px 6px;
    border-radius: 4px;
    white-space: nowrap;
    box-shadow: 0 2px 6px rgba(26, 115, 232, 0.3);
}
    
    .knob {
      position: absolute; left: 0%; width: 16px; height: 16px;
      background: white; border: 2px solid var(--accent-blue); border-radius: 50%;
      transform: translateX(-50%); box-shadow: 0 2px 4px rgba(0,0,0,0.2); cursor: grab; z-index: 10;
      transition: transform 0.1s;
    }
    .knob:hover { transform: translateX(-50%) scale(1.2); }
    .knob:active { cursor: grabbing; background: var(--accent-blue); }

    /* Selector de Compás */
    .measure-selector { 
        position: relative; cursor: pointer; display: flex; align-items: center; gap: 6px; 
        background: #fff; padding: 5px 10px; border: 1px solid #e0e0e0; border-radius: 6px; 
        transition: 0.2s; min-width: 90px; justify-content: space-between;
    }
    .measure-selector:hover { background: #f9f9f9; border-color: #ccc; }
    .measure-label { font-size: 10px; color: var(--text-light); font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
    .measure-display { font-family: 'SF Mono', 'Menlo', 'monospace'; font-size: 14px; font-weight: 700; color: var(--text-main); }
    
   .measure-dropdown {
  position: absolute; 
  top: calc(100% + 6px); /* AHORA ABRE HACIA ABAJO */
  bottom: auto;          /* Reseteamos el bottom por si acaso */
  right: 0; 
  background: white; 
  border: 1px solid var(--border-color); 
  border-radius: 8px; 
  box-shadow: 0 4px 16px rgba(0,0,0,0.15); 
  width: 150px; 
  max-height: 0; 
  overflow: hidden; 
  opacity: 0; 
  transition: all 0.2s ease; 
  z-index: 100;
}
    .measure-dropdown.open { max-height: 240px; opacity: 1; }
    .measure-dropdown-scroll { max-height: 240px; overflow-y: auto; padding: 4px; }
    .measure-option { 
        padding: 8px 12px; border-radius: 4px; cursor: pointer; font-family: 'SF Mono', 'Menlo', 'monospace'; 
        font-size: 12px; display: flex; justify-content: space-between; color: var(--text-main);
    }
    .measure-option:hover { background: #f5f5f5; }
    .measure-option.current { background: #e8f0fe; color: var(--accent-blue); font-weight: 700; }

    .loop-tools { display: flex; gap: 4px; background: #fff; border: 1px solid #e0e0e0; padding: 3px; border-radius: 6px; flex-shrink: 0; }
    .loop-btn { width: 30px; height: 30px; border: none; background: transparent; color: var(--text-light); border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 18px; }
    .loop-btn:hover { background: #f5f5f5; color: var(--text-main); }
    .loop-btn.btn-on { background: #e8f0fe; color: var(--accent-blue); }

    /* =========================================
       5. ESTILOS ORIGINALES (PIANO, WATERFALL, OSMD)
       ¡Estos se han preservado intactos!
       ========================================= */
    #osmd-container {
      width: 95%; max-width: 900px; margin: 20px auto;
      border: 1px solid #ddd; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      border-radius: 3px; box-sizing: border-box; overflow: hidden;
      background: #fff; /* Aseguramos fondo blanco */
    }



#piano-container {
  position: fixed;
  left: 0;
  bottom: 0;
  width: 100%;

  padding: 12px 0;
  overflow: hidden;
  box-shadow: 0 -1px 3px rgba(0,0,0,0.08);
  border-top: 1px solid #e0e0e0;
  height: 160px;
  z-index: 100;
}

/* Estado 1: Solo waterfall (cubre toda la pantalla) */
#piano-container.waterfall-only {
  height: calc(100vh - 60px);
  top: 60px;
  bottom: auto;
  padding: 0 0 12px 0;
  background: transparent !important;
}
#piano-container.waterfall-only #waterfall-canvas {
  height: calc(100% - 102px) !important; 
  width: 100%;
}

/* Estado 2: Solo piano (sin waterfall) */
#piano-container.piano-only {
  height: 112px;
}

#piano-container.piano-only #waterfall-canvas{
  display: none;
}
/* REEMPLAZA los estilos de #piano-wrapper y #piano-keys */
#piano-wrapper {
  position: absolute; 
  bottom: var(--piano-bottom);
  left: 0; 
  width: 100%; 
  height: var(--piano-height2) ;
  background: #2a2a2a; 
  border-top: 1px solid #333; 
  display: flex; 
  justify-content: center; 
  align-items: flex-end; /* Alinea el piano al fondo */
  overflow: hidden;
  box-shadow: 0 -10px 30px rgba(0,0,0,0.3); /* Sombra hacia arriba */
  padding-bottom: 5px; /* Espacio para que el piano no toque el borde */
}

#piano-keys { 
  position: relative; 
  height: var(--key-white-height); /* Usa la altura de teclas blancas */
  display: flex; 
  justify-content: center; 
  z-index: 3;
}

/* REEMPLAZA los estilos de .key */
.key { 
  position: relative; 
  float: left; 
  cursor: pointer; 
  transition: all 0.05s ease; 
  user-select: none; 
}

.key.white {
  width: 24px; 
  height: var(--key-white-height); 
  background: linear-gradient(to bottom, #ffffff 0%, #f5f5f5 100%); /* Gradiente sutil */
  border: 1px solid #ccc; 
  border-right: 1px solid #e0e0e0; 
  border-radius: 0 0 4px 4px; 
  z-index: 1;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Sombra para profundidad */
}


.key.white.active { 
  background: var(--primary-color) !important; 
  box-shadow: 0 0 20px var(--primary-glow), inset 0 2px 4px rgba(0,0,0,0.2); 
  transform: translateY(2px); /* Efecto de presión */
}

.key.black {
  width: 14px; 
  height: var(--key-black-height); 
  background: #333; border: 1px solid #555; margin-left: -7px; margin-right: -7px; z-index: 2; border-radius: 0 0 3px 3px;
}

.key.black.active { 
  background: #2980b9 !important; 
  box-shadow: 0 0 15px rgba(41, 128, 185, 0.8), inset 0 2px 4px rgba(0,0,0,0.3);
  transform: translateY(2px);
}
#piano-top-casing {
  position: absolute; 
  bottom: calc(var(--piano-height) + var(--piano-bottom) - 25px); 
  left: 0; 
  width: 100%; 
  height: 15px; /* Aumentado ligeramente */
  background: linear-gradient(to bottom, #1a1a1a 0%, #2a2a2a 100%);
  z-index: 4; 
  display: flex; 
  justify-content: center;
  border-top: 1px solid #444;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.casing-note-label {
  position: absolute; 
  top: 6px; /* Ajustado para mejor centrado */
  color: #fff; 
  font-size: 11px; 
  font-weight: 600;
  background: rgba(52, 152, 219, 0.8); /* Color del tema */
  padding: 2px 8px; 
  border-radius: 12px; /* Más redondeado */
  pointer-events: none;
  transform: translateX(-50%); 
  z-index: 20;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  letter-spacing: 0.5px;
}


.key.active-treble {
  background: #3498db !important; /* Azul para mano derecha (treble) */
  box-shadow: 0 0 20px rgba(52, 152, 219, 0.8), inset 0 2px 4px rgba(0,0,0,0.2) !important;

}

.key.active-bass {
  background: #de9e37 !important; /* Naranja para mano izquierda (bass) */
  box-shadow: 0 0 20px rgba(222, 158, 55, 0.8), inset 0 2px 4px rgba(0,0,0,0.2) !important;

}

/* Para teclas negras en modo aprendizaje */
.key.black.active-treble {
  background: #2980b9 !important; /* Azul más oscuro para teclas negras */
  box-shadow: 0 0 15px rgba(41, 128, 185, 0.8), inset 0 2px 4px rgba(0,0,0,0.3) !important;
}

.key.black.active-bass {
  background: #b45309 !important; /* Naranja más oscuro para teclas negras */
  box-shadow: 0 0 15px rgba(180, 83, 9, 0.8), inset 0 2px 4px rgba(0,0,0,0.3) !important;
}

/* Animación de pulso para las teclas en modo aprendizaje */
@keyframes keyPulse {
  0% { 
    filter: brightness(1);
    transform: translateY(2px);
  }
  50% {
    filter: brightness(1.2);
    transform: translateY(1px);
  }
  100% { 
    filter: brightness(1);
    transform: translateY(2px);
  }
}


.key.active-treble,
.key.active-bass {
  animation: keyPulse 0.15s ease-out;
}

.key.midi-active {
  background-color: #d5d5d5 !important; /* Gris más oscuro */
  box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3) !important;
  
}

.key.white.midi-active {
  background-color: #d0d0d0 !important;
  filter: brightness(0.9);
  transform: translateY(2px);
}

.key.black.midi-active {
  background-color: #444444 !important; /* Negro más claro */
  box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.5) !important;
  filter: brightness(1.3);
  transform: translateY(1px);
}
#waterfall-canvas {
  position: absolute;
  top: 0;
  left: 50%;  /* ← CAMBIADO de 0 a 50% */
  transform: translateX(-50%);  /* ← AÑADIDO para centrar */
  width: 100%;
  height: calc(100% - 102px);
  pointer-events: none;
  z-index: 1;
  background-color: transparent !important;
  transition: height 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
}

@media (min-width: 769px) {
  #waterfall-canvas {
    left: 49%;
  }
}
.hit-line-piano {
  position: absolute;
  height: 4px !important;
  bottom: 96px;
  left: 0;
  right: 0;
  height: 2px;
  background: rgba(255, 0, 0, 0.7);
  box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
  z-index: 30;
  pointer-events: none;
}

.note-flash-piano {
  position: absolute;
  bottom: 102px;
  width: 20px;
  height: 12px;
  pointer-events: none;
  z-index: 4;
  opacity: 0;
  background: white;
  transform-origin: center bottom;
}
.note-flash-piano.flash-active {
  animation: flashEffectPiano 0.4s ease-out;
}

@keyframes flashEffectPiano {
  0% {
    opacity: 0.7;
    transform: translateX(-50%) translateY(0) scaleY(1);
    filter: blur(2px);
    box-shadow: 0 3px 10px 3px rgba(255, 255, 255, 0.6);
  }
  50% {
    opacity: 0.4;
    transform: translateX(-50%) translateY(-8px) scaleY(1.3);
    filter: blur(4px);
    box-shadow: 0 6px 12px 5px rgba(255, 255, 255, 0.3);
  }
  100% {
    opacity: 0;
    transform: translateX(-50%) translateY(-15px) scaleY(1.6);
    filter: blur(6px);
    box-shadow: 0 8px 15px 6px rgba(255, 255, 255, 0);
  }
}


    #status { text-align: center; padding: 40px 20px; color: #999; font-size: 13px; }
    #annotation-canvas { height: 100%; width: 100vw; }

    /* Key Names */
    .key-name {
      position: absolute; bottom: 5px; width: 100%; text-align: center;
      font-size: 10px; font-weight: bold; color: #333; pointer-events: none; z-index: 10;
      font-family: Arial, sans-serif;
    }
    .key.black .key-name { color: white; bottom: 3px; font-size: 8px; }
    .key.white.has-name { background: linear-gradient(to bottom, #fff 0%, #f5f5f5 100%); }

    /* Confetti */
    .confetti {
      position: fixed; width: 10px; height: 10px; opacity: 0;
      animation: confetti-fall 5s ease-out forwards; z-index: 9999;
    }
    @keyframes confetti-fall {
      0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; }
      100% { transform: translateY(110vh) rotate(720deg); opacity: 0; }
    }

    /* Modales de Sistema (Éxito, Alertas) */
    .modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(4px);
      display: flex; align-items: center; justify-content: center;
      z-index: 3001; opacity: 0; transition: opacity 0.3s ease; pointer-events: none;
    }
    .modal-overlay.is-visible { opacity: 1; pointer-events: auto; }

    .modal-content {
      background: #fff; padding: 28px 32px; border-radius: 10px;
      border: 1px solid #e0e0e0; box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(0, 0, 0, 0.1);
      text-align: center; max-width: 380px; transform: scale(0.95);
      transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    .modal-overlay.is-visible .modal-content { transform: scale(1); }

    #modal-message, #success-modal-message {
      font-size: 14px; color: #333; line-height: 1.6; margin-bottom: 24px; font-weight: 400;
    }
    #modal-message strong, #success-modal-message strong { font-weight: 700; color: #1a1a1a; }

    .closeBtn {
      background-color: #1a1a1a; color: white; padding: 11px 24px;
      border-radius: 6px; font-weight: 600; font-size: 13px; transition: all 0.2s;
      border: none; cursor: pointer; letter-spacing: 0.3px;
    }
    .closeBtn:hover { background-color: #2a2a2a; transform: translateY(-1px); }

    /* Success Toast */
    .success-toast {
      position: fixed; top: -80px; left: 50%; transform: translateX(-50%);
      background-color: #ffffff; color: #27ae60; padding: 12px 24px;
      border-radius: 50px; box-shadow: 0 4px 15px rgba(0,0,0,0.15);
      border: 1px solid #d4edda; z-index: 3000; display: flex; align-items: center; gap: 10px;
      font-weight: 600; font-size: 14px; transition: top 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      pointer-events: none;
    }
    .success-toast.show { top: 90px; }
    .success-toast i { font-size: 18px; }
    .success-toast.warning { color: #856404; background-color: #fff3cd; border-color: #ffeeba; }
    .success-toast.warning i { color: #856404; }

    /* Midi Status Legend */
    #midi-status-legend {
      position: fixed; bottom: 165px; left: 10px; z-index: 550;
      background-color: rgba(26, 26, 26, 0.85); color: #fafafa;
      padding: 8px 12px; border-radius: 10px; border: 1px solid #444;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1); backdrop-filter: blur(8px);
      font-size: 13px; font-weight: 500; display: flex; align-items: center; gap: 8px;
      opacity: 0; transform: translateY(10px); transition: opacity 0.3s ease, transform 0.3s ease;
      pointer-events: none;
    }
    #midi-status-legend.is-visible { opacity: 1; transform: translateY(0); }
    #midi-status-legend i { font-size: 16px; color: #3498db; }

    /* Global Progress */
    #global-progress-container {
      position: fixed; bottom: 165px; right: 10px; z-index: 550;
      background-color: rgba(26, 26, 26, 0.85); color: #fafafa;
      padding: 10px 12px; border-radius: 10px; border: 1px solid #444;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1); backdrop-filter: blur(8px);
      display: flex; flex-direction: column; gap: 6px; min-width: 140px;
      opacity: 0; transform: translateY(10px); transition: opacity 0.3s ease, transform 0.3s ease;
      pointer-events: none;
    }
    #global-progress-container.is-visible { opacity: 1; transform: translateY(0); }
    .progress-header { display: flex; align-items: center; justify-content: space-between; font-size: 12px; font-weight: 500; width: 100%; }
    #global-progress-text { font-weight: 700; color: #2ecc71; }
    .global-progress-track { width: 100%; height: 6px; background: rgba(255, 255, 255, 0.15); border-radius: 3px; overflow: hidden; }
    #global-progress-fill { width: 0%; height: 100%; background: linear-gradient(90deg, #2ecc71, #27ae60); transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1); }

    /* Fog Overlay */
    .fog-overlay {
      position: absolute; background-color: rgba(255, 255, 255, 0.85);
      z-index: 10; pointer-events: none; transition: all 0.5s ease;
    }

    /* Tutorial Highlights */
    .tutorial-highlight {
      position: relative; z-index: 3001 !important;
      box-shadow: 0 0 0 4px rgba(52, 152, 219, 0.7), 0 0 20px 10px rgba(52, 152, 219, 0.5) !important;
      border-radius: 6px; transition: all 0.3s ease-in-out;
      background-color: rgba(255, 255, 255, 0.1);
    }
    .tutorial-parent-highlight { z-index: 3000 !important; position: relative; }
    #tutorial-overlay { backdrop-filter: none; background: rgba(0, 0, 0, 0.4); display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2999; }
    #tutorial-modal {
      position: absolute; background: #ffffff; color: black; padding: 20px 24px;
      border-radius: 12px; box-shadow: 0 8px 32px rgba(52, 152, 219, 0.4);
      max-width: 350px; opacity: 0; transform: scale(0.8) translateY(10px);
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); z-index: 3001;
      border: 1px solid #e0e0e0; text-align: left; display: none;
    }
    #tutorial-modal.show { display: block; opacity: 1; transform: scale(1) translateY(0); }
    #tutorial-modal::before {
      content: ''; position: absolute; width: 0; height: 0; top: -10px; left: var(--arrow-left, 50%);
      transform: translateX(-50%); border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 10px solid #ffffff;
    }
    #tutorial-modal.arrow-bottom::after {
      display: block; content: ''; position: absolute; width: 0; height: 0; bottom: -10px; left: var(--arrow-left, 50%);
      transform: translateX(-50%); border-left: 10px solid transparent; border-right: 10px solid transparent; border-top: 10px solid #ffffff;
    }
    #tutorial-modal.arrow-bottom::before { display: none; }

    /* Responsive Ajustes Finales */
    @media (max-width: 768px) {
      .main-bar { padding: 0 16px; gap: 8px; }
      .song-info { display: none; }
      .controls-center { position: relative; left: 0; transform: none; flex: 1; justify-content: flex-start; }
      .btn-start { padding: 0; width: 36px; height: 36px; border-radius: 50%; justify-content: center; }
      .btn-start span { display: none; }
      .control-divider { display: none; }
      .modal-popup { position: fixed; bottom: 0; top: auto; right: 0; left: 0; width: 100%; border-radius: 16px 16px 0 0; transform: translateY(100%); padding-bottom: 30px; }
      .modal-popup.is-open { transform: translateY(0); }
      .measure-count { display: none; }
      .key.white { width: 13px; height: 75px; }
      .key.black { width: 8px; height: 48px; margin-left: -4px; margin-right: -4px; }
      .mobile-zoom { transform: scale(0.85); transform-origin: top center; }
    }
</style>
</head>
<body>

<div id="top-bar-container">
  
  <div id="top-bar" class="main-bar">
    <div class="song-info">
      <span class="song-title">MusicXML Player</span>
      <span class="song-subtitle">Interactive Learning</span>
    </div>

    <div class="controls-group controls-center">
      <button id="midi-learn-btn" class="btn btn-start" title="Comenzar aprendizaje">
        <i class="ph-fill ph-play-circle"></i>
        <span>Comenzar</span>
      </button>

      <div class="control-divider"></div>
      
      <button id="restart-chunk-btn" class="btn learning-btn back" title="Reiniciar sección">
        <i class="ph ph-arrow-u-up-left"></i>
      </button>
      
      <button id="left-hand-only-btn" class="btn learning-btn" title="Mano izquierda">
      <i class="ph ph-hand hand-left"></i>
      </button>
      
      <button id="right-hand-only-btn" class="btn learning-btn" title="Mano derecha">
          <i class="ph ph-hand"></i>
      </button>
    </div>

    <div class="controls-group controls-right">
      <button id="mute-btn" class="btn tool-btn" title="Silenciar Piano">
        <i class="ph ph-speaker-high"></i>
      </button>

      <button id="metronome-modal-btn" class="btn tool-btn" onclick="toggleModal('metronome')">
          <i class="ph ph-metronome"></i>
      </button>

      <button id="tools-toggle-btn" class="btn tool-btn" onclick="toggleModal('settings')">
      <i class="ph ph-sliders-horizontal"></i>
      </button>

      <button id="close-btn-placeholder" class="close-btn">
        <i class="ph ph-x"></i>
      </button>

      <div id="modal-metronome" class="modal-popup">
        <div class="modal-header">Metrónomo</div>
        <div class="modal-option">
          <div class="modal-label"><i class="ph ph-power"></i><span>Activar</span></div>
          <div class="toggle-switch" id="metronome-btn"></div>
        
        </div>
        <div class="modal-option">
          <div class="modal-label"><i class="ph ph-gauge"></i><span>BPM</span></div>
          <div class="counter-control">
            <button id="speed-down-btn" class="counter-btn"><i class="ri-subtract-line"></i></button>
            <span class="counter-value" id="speed-bpm">120</span>
            <button id="speed-up-btn" class="counter-btn"><i class="ri-add-line"></i></button>
          </div>
        </div>
        <div class="modal-option">
    <div class="modal-label"><i class="ph-fill ph-music-note"></i><span>Beat</span></div>
    <div class="counter-control">
      <button id="accent-down-btn" class="counter-btn"><i class="ri-subtract-line"></i></button>
      <span class="counter-value" id="accent-value">4</span>
      <button id="accent-up-btn" class="counter-btn"><i class="ri-add-line"></i></button>
    </div>
  </div>
      </div>

      <div id="modal-settings" class="modal-popup">
        <div class="modal-header">Herramientas</div>
        
        <div class="modal-option">
          <div class="modal-label"><i class="ph ph-microphone"></i><span>Micrófono</span></div>
          <div class="toggle-switch" id="mic-btn"></div>
        </div>

        <div class="modal-option">
             <div class="modal-label"><i class="ph ph-seal-question"></i><span>Tutorial</span></div>
             <button id="start-tutorial-btn" class="counter-btn" style="width: auto; padding: 0 8px; font-size: 11px; font-weight: bold; border: 1px solid #ddd;">
                INICIAR
             </button>
        </div>

        <div class="control-divider" style="width: 100%; height: 1px; margin: 8px 0; background: #eee;"></div>
        <div class="modal-header">Visualización</div>

        <div class="modal-option">
          <div class="modal-label"><i class="ph ph-magnifying-glass-plus"></i><span>Zoom</span></div>
          <div class="counter-control">
            <button id="zoom-out" class="counter-btn"><i class="ph-bold ph-minus"></i></button>
            <span class="counter-value" id="zoom-label">100%</span>
            <button id="zoom-in" class="counter-btn"><i class="ph-bold ph-plus"></i></button>
          </div>
        </div>

        <div class="modal-option">
          <div class="modal-label"><i class="ph ph-piano-keys"></i><span>Vista Piano</span></div>
          <div class="toggle-switch" id="piano-btn"></div>
        </div>

        <div style="display:none;">
             <button id="show-key-names-btn"></button>
             <button id="fullscreen-btn"></button>
        </div>
      </div>
    </div>
  </div>

  <div id="secondary-top-bar" class="secondary-panel">
    <div class="panel-content">
      <div class="timeline-layout">
        
        <button id="play-btn" class="playback-btn" title="Reproducir/Pausar">
          <i class="ri-play-fill" id="play-icon"></i>
          <i class="ri-pause-fill" id="pause-icon" style="display:none;"></i>
        </button>

        <div id="time-display" class="time-badge">
           <span id="current-time">0:00</span>
           <span class="measure-count">/ <span id="total-time">0:00</span></span>
        </div>

        <input type="range" id="progress-bar" value="0" min="0" max="100" step="0.1" style="display:none;">
        <select id="measure-select" style="display:none;"></select>
        <select id="measure-until" style="display:none;"></select>

        <div class="track-container" id="track-container">
            <div class="rail"></div>
            <div class="loop-region" id="loop-region"></div>
            <div class="fill" id="track-fill" style="width: 0%;"></div>
            <div class="loop-pin" id="loop-pin-start"></div>
            <div class="loop-pin" id="loop-pin-end"></div>
            <div class="loop-thumb" id="loop-thumb-end"></div>
            <div class="knob" id="track-knob" style="left: 0%;"></div>
        </div>

        <div class="measure-selector" onclick="toggleMeasureDropdown()">
          <span class="measure-label">Compás</span>
          <span class="measure-display" id="custom-measure-display">-</span>
          <i class="ri-arrow-down-s-line" style="font-size: 14px; color: var(--text-light);"></i>
          <div class="measure-dropdown" id="measure-dropdown">
            <div class="measure-dropdown-scroll" id="measure-list-custom"></div>
          </div>
        </div>

        <div class="loop-tools" style="position: relative;">
    <button class="loop-btn" id="btn-loop-active" onclick="toggleLoopMenu()" title="Crear Bucle">
        <i class="ph ph-repeat"></i>
    </button>
    
    <div class="measure-dropdown" id="loop-dropdown" style="left: 0; right: auto; width: 160px;">
        <div class="measure-dropdown-scroll" id="loop-end-list"></div>
    </div>

    <button id="cancel-loop-btn" class="loop-btn" onclick="deactivateLoopMode()" title="Borrar loop" style="display:none;">
        <i class="ph ph-trash"></i>
    </button>
</div>

      </div>
    </div>
  </div>
</div>

<div id="sheet-music-wrapper" style="position: relative;">
    <div id="osmd-container"></div>
    <canvas id="annotation-canvas" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
</div>
<div id="status">Cargando...</div>

<div id="piano-container">
    <canvas id="waterfall-canvas"></canvas>
    <div class="hit-line-piano"></div>
    <div id="piano-top-casing"></div>
    <div id="piano-wrapper">
        <div id="piano-keys"></div>
    </div>
</div>

<div id="midi-status-legend"></div>
<div id="global-progress-container"><div class="progress-header"><span class="progress-label">Progreso</span><span id="global-progress-text">0%</span></div><div class="global-progress-track"><div id="global-progress-fill"></div></div></div>
<div id="midi-modal" class="modal-overlay" style="display: none;"><div class="modal-content"><p id="modal-message"></p><button id="modal-close-btn" class="btn closeBtn">Entendido</button></div></div>
<div id="success-toast" class="success-toast"><i class="ri-checkbox-circle-line"></i><span id="success-toast-message"></span></div>
<div id="success-modal" class="modal-overlay" style="display: none;"><div class="modal-content"><p id="success-modal-message"></p><button id="success-modal-close-btn" class="btn closeBtn">Continuar</button></div></div>

<div style="display: none !important;">
    <div id="secondary-top-bar2"></div>
    <div id="tutorial-midi-alert"></div>
    <div id="tutorial-phantom-target"></div>
</div>

<div id="tutorial-overlay" class="modal-overlay" style="display: none; z-index: 2999;">
  <div id="tutorial-modal" class="modal-content" style="max-width: 400px; text-align: left;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <h4 id="tutorial-title" style="margin: 0;">Tutorial</h4>
        <button id="tutorial-close-btn" class="close-btn"><i class="ri-close-line"></i></button>
    </div>
    <p id="tutorial-text"></p>
    <div id="tutorial-nav" style="margin-top: 20px; text-align: right;">
        <button id="tutorial-next-btn" class="btn-start">Siguiente</button>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@latest/build/opensheetmusicdisplay.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
  <script>
    const playBtn = document.getElementById('play-btn');
    const playIcon = document.getElementById('play-icon');
    const pauseIcon = document.getElementById('pause-icon');
    const pianoBtn = document.getElementById('piano-btn');
    const osmdContainer = document.getElementById('osmd-container');
    const statusDiv = document.getElementById('status');
    const pianoContainer = document.getElementById('piano-container');
    const pianoKeys = document.getElementById('piano-keys');
    const progressBar = document.getElementById('progress-bar');
    const progressBarContainer = document.getElementById('progress-bar-container');
    const speedBpmLabel = document.getElementById('speed-bpm');
   const speedUpBtn = document.getElementById('speed-up-btn');
const speedDownBtn = document.getElementById('speed-down-btn');
    const zoomInBtn = document.getElementById('zoom-in');
    const zoomOutBtn = document.getElementById('zoom-out');
    const zoomLabel = document.getElementById('zoom-label');
    const currentTimeSpan = document.getElementById('current-time');
const totalTimeSpan = document.getElementById('total-time');
const measureSelect = document.getElementById('measure-select');
const toolsToggleBtn = document.getElementById('tools-toggle-btn');
const secondaryTopBar = document.getElementById('secondary-top-bar');
const secondaryTopBar2 = document.getElementById('secondary-top-bar2');
const restartChunkBtn = document.getElementById('restart-chunk-btn');
  let isRestarting = false;
  let isPianoMuted = false;
const muteBtn = document.getElementById('mute-btn');

//const cursorBtn = document.getElementById('cursor-btn');
const fullscreenBtn = document.getElementById('fullscreen-btn');
const midiModal = document.getElementById('midi-modal');
const modalMessage = document.getElementById('modal-message');
const modalCloseBtn = document.getElementById('modal-close-btn');
const midiStatusLegend = document.getElementById('midi-status-legend');
const rightHandOnlyBtn = document.getElementById('right-hand-only-btn');
const leftHandOnlyBtn = document.getElementById('left-hand-only-btn');
let handFilterMode = 'both';

const showKeyNamesBtn = document.getElementById('show-key-names-btn');
let showKeyNames = false;
const successModal = document.getElementById('success-modal');
const successModalMessage = document.getElementById('success-modal-message');
const successModalCloseBtn = document.getElementById('success-modal-close-btn');

let isPieceCompleted = false;
let isSustainPedalDown = false;
let sustainedNotes = new Set();

const metronomeBtn = document.getElementById('metronome-btn');
let isMetronomeOn = false;
let metronomeAudioCtx = null;
let metronomeInterval = null;
let metronomeBeatCount = 0;
let metronomeAccent = 4;
let metronomeSchedulerId = null;
let metronomeNextNoteTime = 0;
const metronomeScheduleAhead = 0.1; // Programar con 100ms de anticipación
const metronomeLookahead = 25;
const accentUpBtn = document.getElementById('accent-up-btn');
const accentDownBtn = document.getElementById('accent-down-btn');
const accentValueSpan = document.getElementById('accent-value');

const startTutorialBtn = document.getElementById('start-tutorial-btn');
const tutorialOverlay = document.getElementById('tutorial-overlay');
const tutorialModal = document.getElementById('tutorial-modal');
const tutorialTitle = document.getElementById('tutorial-title');
const tutorialText = document.getElementById('tutorial-text');
const tutorialNextBtn = document.getElementById('tutorial-next-btn');
const tutorialCloseBtn = document.getElementById('tutorial-close-btn');
const tutorialMidiAlert = document.getElementById('tutorial-midi-alert');
let tutorialAlertTimeout = null;
let currentTutorialStep = 0;
let tutorialSteps = [];

let unlockedMeasureCount = 4; 
const MEASURES_PER_CHUNK = 4;


tutorialSteps = [
    {
        elementId: 'midi-learn-btn',
        title: 'Modo Aprendizaje',
        text: 'Este es el botón principal. <strong>Haz clic en él ahora</strong> para activar el Modo Aprendizaje y ver la barra de herramientas de práctica.',
        requiresClick: true,
        targetAction: 'click-midi-learn'
    },
    {
        elementId: 'left-hand-only-btn',
        title: 'Filtro de Mano Izquierda',
        text: 'Este botón filtra la partitura y el modo aprendizaje para mostrar <strong>solo las notas de la mano izquierda</strong> (clave de Fa).'
    },
    {
        elementId: 'right-hand-only-btn',
        title: 'Filtro de Mano Derecha',
        text: '<strong>Haz clic en este botón</strong> para activar el filtro de mano derecha y continuar.',
        requiresClick: true,
        targetAction: 'click-right-hand'
    },
    {
        elementId: 'piano-keys',
        title: '¡Prueba el Piano!',
        text: 'Ahora <strong>toca en tu teclado MIDI la nota que se muestra en azul</strong> para avanzar. Así es como funciona el modo aprendizaje.',
        requiresClick: true,
        targetAction: 'play-correct-note'
    },
    {
        elementId: 'global-progress-container',
        title: 'Progreso de Práctica',
        text: 'Esta barra muestra <strong>cuánto has completado</strong> de la pieza nota por nota mientras estás en "Modo Aprendizaje".'
    },
    {
        elementId: 'tutorial-phantom-target', 
        title: 'Desbloqueo por Secciones',

        placement: 'bottom',
        text: 'Debes tocar los <strong>4 compases resaltados con AMBAS MANOS</strong> correctamente. Si lo logras sin errores, desbloquearás 4 siguientes compases y así sucesivamente.',
        onShow: () => {
            const container = document.getElementById('osmd-container');
            const phantom = document.getElementById('tutorial-phantom-target');
            
            if (container && phantom) {
                const rect = container.getBoundingClientRect();
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
                phantom.style.top = (rect.top + scrollTop) + 'px';
                phantom.style.left = (rect.left + scrollLeft) + 'px';
                phantom.style.width = rect.width + 'px';
                phantom.style.height = '280px'; 
            }

            if (handFilterMode !== 'both') {
                handFilterMode = 'both';
                
                const rhBtn = document.getElementById('right-hand-only-btn');
                const lhBtn = document.getElementById('left-hand-only-btn');
                if(rhBtn) { rhBtn.style.background = 'none'; rhBtn.style.color = '#1a1a1a'; }
                if(lhBtn) { lhBtn.style.background = 'none'; lhBtn.style.color = '#1a1a1a'; }

                updateStaffOpacity('both');
                reloadCurrentStepWithHandFilter();
            }
        }
    },
    {
        elementId: 'measure-select',
        title: 'Saltar al Compás',
        text: 'Usa este menú para <strong>saltar a cualquier compás</strong> de la pieza e iniciar tu práctica desde allí.'
    },
    {
        elementId: 'measure-until',
        title: 'Modo Loop (Bucle)',
        text: 'Selecciona un compás aquí para <strong>crear un bucle de práctica</strong>. El sistema repetirará la sección entre el "Compás de inicio" y este.'
    }
];

const measureUntil = document.getElementById('measure-until');
const cancelLoopBtn = document.getElementById('cancel-loop-btn');
let loopMeasureStart = -1;
let loopMeasureEnd = -1;
let isLoopMode = false;

    let osmd = null;
    let sampler = null;
    let parsedNotes = [];
    let measureStartTimes = [];
    let globalTempo = 120;
    let playbackRate = 1.0;
    let currentSpeed = 1.0;
    let totalDuration = 0;
    let isPlaying = false;
    let audioPart = null;
    let visualPart = null;
    let progressInterval = null;
    let activeHighlightTimeouts = [];
    let currentZoom = 1.0;
    let isMobile = window.innerWidth <= 768;
    let pianoViewMode = 'full'; 


const micBtn = document.getElementById('mic-btn');
let isMicActive = false;
let audioContext = null;
let analyser = null;
let microphoneStream = null;
let micInterval = null;
let lastMicNote = null;
let lastMicTime = 0;
const MIC_THRESHOLD = 0.03; // Ajusta según sensibilidad
 let currentInputSource = 'none';   


  
let waterfallCanvas, waterfallCtx;
let waterfallAnimationId;
let pixelsPerSecond = 100;
let whiteKeyWidth = 16; // Ya no es const
let blackKeyWidth = 10; // Ya no es const
let waterfallScrollOffset = 0;

    // Script: al inicio, junto a las otras constantes
const midiLearnBtn = document.getElementById('midi-learn-btn');
let isMidiLearnMode = false;
let midiAccess = null;
let expectedNotes = new Set(); // Almacenará las notas que esperamos que el usuario toque
let currentLearningIndex = 0; // Para saber en qué nota de la partitura vamos





function initWaterfallCanvas() {
  waterfallCanvas = document.getElementById('waterfall-canvas');
  if (!waterfallCanvas) return;
  
  waterfallCtx = waterfallCanvas.getContext('2d');  
  resizeWaterfallCanvas();
  updateKeyDimensions()
  window.addEventListener('resize', resizeWaterfallCanvas);
}



function resizeWaterfallCanvas() {
  if (!waterfallCanvas) return;
  
  // Actualizar los tamaños de las teclas desde el DOM
  updateKeyDimensions();
  
  const container = pianoContainer;
  const dpr = window.devicePixelRatio || 1;
  
  waterfallCanvas.width = window.innerWidth * dpr;
  waterfallCanvas.height = (container.clientHeight - 102) * dpr;
  
  waterfallCanvas.style.width = `${window.innerWidth}px`;
  waterfallCanvas.style.height = `${container.clientHeight - 102}px`;
  
  // NUEVO: Ajustar pixelsPerSecond según la altura disponible
  const availableHeight = container.clientHeight - 102;
  
  if (pianoContainer.classList.contains('waterfall-only')) {
    // En modo waterfall-only, aumentar la velocidad para mostrar más notas
    pixelsPerSecond = availableHeight / 6; // Muestra aproximadamente 6 segundos de música
  } else {
    // En modo normal, velocidad estándar
    pixelsPerSecond = 100;
  }
  
  console.log(`Altura disponible: ${availableHeight}px, pixelsPerSecond: ${pixelsPerSecond}`);
}


function updateKeyDimensions() {
  // Leer el tamaño real de las teclas del DOM
  const whiteKey = document.querySelector('.key.white');
  const blackKey = document.querySelector('.key.black');
  
  if (whiteKey) {
    whiteKeyWidth = whiteKey.offsetWidth;
  }
  if (blackKey) {
    blackKeyWidth = blackKey.offsetWidth;
  }
}

function getKeyXPosition(midiNote) {
  const firstMidiNote = 21; // A0
  const notePattern = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1]; // A A# B C C# D D# E F F# G G#
  
  let whiteKeyIndex = 0;
  for (let i = firstMidiNote; i < midiNote; i++) {
    const patternIndex = (i - firstMidiNote) % 12;
    if (notePattern[patternIndex] === 0) {
      whiteKeyIndex++;
    }
  }
  
  const patternIndex = (midiNote - firstMidiNote) % 12;
  const isBlack = notePattern[patternIndex] === 1;
  
  if (isBlack) {
    // Para teclas negras, posición centrada entre teclas blancas
    return (whiteKeyIndex * whiteKeyWidth) - (blackKeyWidth / 2);
  } else {
    return whiteKeyIndex * whiteKeyWidth;
  }
}

function pitchToMidiNumber(pitch) {
  const noteMap = {
    'C': 0, 'C#': 1, 'Db': 1,
    'D': 2, 'D#': 3, 'Eb': 3,
    'E': 4, 'Fb': 4, 'E#': 5,
    'F': 5, 'F#': 6, 'Gb': 6,
    'G': 7, 'G#': 8, 'Ab': 8,
    'A': 9, 'A#': 10, 'Bb': 10,
    'B': 11, 'B#': 0, 'Cb': 11,  // ✅ AGREGADO B#
    // Dobles sostenidos (CORREGIDOS)
    'C##': 2, 'D##': 4, 'E##': 6, 'F##': 8, 'G##': 10, 'A##': 11, 'B##': 1,
    // Dobles bemoles
    'Dbb': 0, 'Ebb': 2, 'Fbb': 3, 'Gbb': 5, 'Abb': 7, 'Bbb': 9, 'Cbb': 10
  };
  
  // Regex mejorado para capturar dobles alteraciones y bemoles
  const match = pitch.match(/^([A-G])(bb|##|b|#)?(\d+)$/);
  if (!match) {
    console.warn(`No se pudo convertir pitch a MIDI: ${pitch}`);
    return -1;
  }
  
  const [, noteLetter, alteration, octave] = match;
  const noteWithAlt = noteLetter + (alteration || '');
  
  if (!(noteWithAlt in noteMap)) {
    console.warn(`Nota no reconocida en noteMap: ${noteWithAlt}`);
    return -1;
  }
  
  let chromaticValue = noteMap[noteWithAlt];
  let finalOctave = parseInt(octave);
  
  // Ajustes de octava para casos especiales
  if (noteWithAlt === 'Cb' || noteWithAlt === 'Cbb') {
    finalOctave -= 1;
  } else if (noteWithAlt === 'B#' || noteWithAlt === 'B##') {
    finalOctave += 1;  // B# = C del siguiente octava
  }
  // A## NO necesita cambio de octava (A## = B en la misma octava)
  
  return (finalOctave + 1) * 12 + chromaticValue;
}

function drawWaterfall() {
  if (!waterfallCtx || !waterfallCanvas) return;
  
  const dpr = window.devicePixelRatio || 1;
  waterfallCtx.clearRect(0, 0, waterfallCanvas.width, waterfallCanvas.height);
  
  const canvasHeight = waterfallCanvas.height / dpr;
  const totalWhiteKeys = 52;
  const pianoTotalWidth = totalWhiteKeys * whiteKeyWidth;
  const offset = whiteKeyWidth === 16 ? -16 : -12;
  const pianoStartX = (waterfallCanvas.width / dpr - pianoTotalWidth) / 2 + offset;
  
  // Patrón corregido empezando desde A
  const notePattern = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1]; // A A# B C C# D D# E F F# G G#
  
  // Primero dibujar todas las notas blancas
  parsedNotes.forEach(note => {
    if (note.isRest) return;
    
    const midiNote = pitchToMidiNumber(note.pitch);
    if (midiNote < 21 || midiNote > 108) return;
    
    const patternIndex = (midiNote - 21) % 12;
    const isBlack = notePattern[patternIndex] === 1;
    
    // Solo procesar notas blancas en este primer paso
    if (isBlack) return;
    
    const noteStartY = canvasHeight - ((note.startSec - waterfallScrollOffset) * pixelsPerSecond);
    const noteEndY = noteStartY - (note.durSec * pixelsPerSecond);
    
    if (noteEndY < canvasHeight && noteStartY > 0) {
      const keyX = pianoStartX + getKeyXPosition(midiNote);
      const height = Math.max(1, noteStartY - noteEndY);
      const opacityFactor = Math.max(0.15, Math.min(1, noteStartY / canvasHeight));
      
      waterfallCtx.shadowBlur = 40 * dpr * opacityFactor;
      
      if (note.hand === 'treble') {
        waterfallCtx.shadowColor = `rgba(36, 113, 163, ${opacityFactor})`; // Azul oscuro
        waterfallCtx.fillStyle = `rgba(36, 113, 163, ${opacityFactor})`;
      } else {
        waterfallCtx.shadowColor = `rgba(214, 137, 16, ${opacityFactor})`; // Naranja oscuro
        waterfallCtx.fillStyle = `rgba(214, 137, 16, ${opacityFactor})`;
      }
      
      waterfallCtx.fillRect(
        keyX * dpr,
        noteEndY * dpr,
        (whiteKeyWidth - 2) * dpr,
        height * dpr
      );
    }
  });
  
  // Luego dibujar todas las notas negras (sobre las blancas)
  parsedNotes.forEach(note => {
    if (note.isRest) return;
    
    const midiNote = pitchToMidiNumber(note.pitch);
    if (midiNote < 21 || midiNote > 108) return;
    
    const patternIndex = (midiNote - 21) % 12;
    const isBlack = notePattern[patternIndex] === 1;
    
    // Solo procesar notas negras en este segundo paso
    if (!isBlack) return;
    
    const noteStartY = canvasHeight - ((note.startSec - waterfallScrollOffset) * pixelsPerSecond);
    const noteEndY = noteStartY - (note.durSec * pixelsPerSecond);
    
    if (noteEndY < canvasHeight && noteStartY > 0) {
      const keyX = pianoStartX + getKeyXPosition(midiNote);
      const height = Math.max(1, noteStartY - noteEndY);
      
      // Calcular opacidad: notas cerca del piano (Y alto) = opacas, notas arriba (Y bajo) = transparentes
      const opacityFactor = Math.max(0.15, Math.min(1, noteStartY / canvasHeight));
      
      waterfallCtx.shadowBlur = 30 * dpr * opacityFactor;
      
      if (note.hand === 'treble') {
        waterfallCtx.shadowColor = `rgba(26, 84, 144, ${opacityFactor})`; // Azul muy oscuro
        waterfallCtx.fillStyle = `rgba(26, 84, 144, ${opacityFactor})`;
      } else {
        waterfallCtx.shadowColor = `rgba(168, 111, 10, ${opacityFactor})`; // Naranja muy oscuro
        waterfallCtx.fillStyle = `rgba(168, 111, 10, ${opacityFactor})`;
      }
      
      waterfallCtx.fillRect(
        keyX * dpr,
        noteEndY * dpr,
        (blackKeyWidth - 1) * dpr,
        height * dpr
      );
    }
  });
  
  waterfallCtx.shadowBlur = 0;
}


function animateWaterfall() {
    
    // SI ESTÁ EN CUALQUIER MODO DE APRENDIZAJE (normal O inteligente)
    if (isMidiLearnMode) {
        
        // Mover el waterfall al tiempo de la nota anterior (para "esperarla")
        if (currentLearningIndex > 0 && parsedNotes[currentLearningIndex - 1]) {
            waterfallScrollOffset = parsedNotes[currentLearningIndex - 1].startSec;
        } else {
            // Si estamos al principio (índice 0), el offset es 0
            waterfallScrollOffset = 0;
        }

    } else if (Tone.Transport.state === 'started') {
        // Modo de reproducción normal
        waterfallScrollOffset = Tone.Transport.seconds;
    }
    
    drawWaterfall();
    waterfallAnimationId = requestAnimationFrame(animateWaterfall);
}

function createNoteFlashPiano(noteName, hand) {
  const midiNote = pitchToMidiNumber(noteName);
  if (midiNote < 21 || midiNote > 108) return;
  
  const flash = document.createElement('div');
  flash.className = 'note-flash-piano flash-active';
  
  const totalWhiteKeys = 52;
  const pianoTotalWidth = totalWhiteKeys * whiteKeyWidth;
  
  // Usar el mismo offset que en drawWaterfall
  const offset = whiteKeyWidth === 16 ? -16 : -12;
  const pianoStartX = (window.innerWidth - pianoTotalWidth) / 2 + offset;
  
  const keyX = getKeyXPosition(midiNote);
  const notePattern = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1];
  const isBlack = notePattern[(midiNote - 21) % 12] === 1;
  const keyWidth = isBlack ? blackKeyWidth : whiteKeyWidth;
  const flashX = pianoStartX + keyX + (keyWidth / 2);
  
  flash.style.left = flashX + 'px';
  
  pianoContainer.appendChild(flash);
  
  setTimeout(() => {
    flash.remove();
  }, 400);
}


   document.addEventListener('DOMContentLoaded', async () => {
  setStatus('Inicializando...');
  initOSMD();
  createPiano88Keys();
  updateKeyDimensions();
  addEventListeners();
  initSampler();
  initMidiInput();
  initWaterfallCanvas(); 
  animateWaterfall(); 
  
  setStatus('Cargando sonidos de piano...');
  await Tone.loaded();
  setStatus('Cargando partitura...');


  const urlParams = new URLSearchParams(window.location.search);
  const fileId = urlParams.get('file'); 
  if (!fileId) {
    const dynamicUrl = `https://storage.googleapis.com/mozartacademy-files/xml/minuet-in-c-reinagle.musicxml`;
    //const dynamicUrl = `https://storage.googleapis.com/mozartacademy-files/xml/${encodeURIComponent(fileId)}.musicxml`;
    await loadMusicXMLFromUrl(dynamicUrl);

  } else {
    setStatus('Error: No se ha especificado ningún archivo para cargar. Añade "?file=tu-archivo.musicxml" a la URL.');
    playBtn.disabled = true; 
  }


});

    function initOSMD() {
      try {
        osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay(osmdContainer, {
          backend: 'svg',
          drawTitle: true,
          drawSubtitle: true,   
          drawComposer: true, 
          followCursor: true,
          drawPartNames: false,
          autoResize: true,
          drawingParameters: "width",
          drawMeasureNumbers: false,
          cursorsOptions: [{ 
            type: 3, 
            color: "rgba(52, 152, 219, 0.45)", 
            alpha: 0.45, 
            follow: true 
          }]
        });
        
        // Configuración para pantallas grandes (hasta 4 compases por línea)
        setupEngravingRulesForScreenSize();
        
      } catch (e) { 
        setStatus('Error al inicializar'); 
      }
    }

    function setupEngravingRulesForScreenSize() {
      if (!osmd || !osmd.EngravingRules) return;
      
      const width = window.innerWidth;
      
      if (width <= 480) {
        // Pantallas muy pequeñas - máxima compresión
        osmd.EngravingRules.SystemMaxMeasuresCount = 4;
        osmd.EngravingRules.MinimumDistanceBetweenNotes = 0.8;
        osmd.EngravingRules.MinimumDistanceBetweenStaffLines = 2.0;
        osmd.EngravingRules.StaffDistance = 2.8;
        osmd.EngravingRules.StaffLineWidth = 0.06;
        osmd.EngravingRules.NoteHeadWidth = 0.8;
        osmd.zoom = 0.5;
        currentZoom = 0.5;
      } else if (width <= 768) {
        // Tablets y móviles grandes
        osmd.EngravingRules.SystemMaxMeasuresCount = 4;
        osmd.EngravingRules.MinimumDistanceBetweenNotes = 1.0;
        osmd.EngravingRules.MinimumDistanceBetweenStaffLines = 2.2;
        osmd.EngravingRules.StaffDistance = 3.0;
        osmd.EngravingRules.StaffLineWidth = 0.07;
        osmd.EngravingRules.NoteHeadWidth = 0.9;
        osmd.zoom = 0.7;
        currentZoom = 0.7;
      } else {
        // Pantallas de escritorio
        osmd.EngravingRules.SystemMaxMeasuresCount = 4;
        osmd.EngravingRules.MinimumDistanceBetweenNotes = 1.2;
        osmd.EngravingRules.MinimumDistanceBetweenStaffLines = 2.5;
        osmd.EngravingRules.StaffDistance = 3.5;
        osmd.EngravingRules.StaffLineWidth = 0.08;
        osmd.EngravingRules.NoteHeadWidth = 1.0;
        osmd.zoom = 0.8;
        currentZoom = 0.8;
      }
      
      updateZoomDisplay();
    }

function updateMidiStatusLegend(deviceName = null) {
  if (deviceName) {
    midiStatusLegend.innerHTML = `<i class="ri-plug-line"></i> ${deviceName} Conectado`;
    midiStatusLegend.classList.add('is-visible');
  } else {
    midiStatusLegend.classList.remove('is-visible');
  }
}

    function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    // Añade un cero a la izquierda si los segundos son menores a 10
    const formattedSeconds = remainingSeconds < 10 ? '0' + remainingSeconds : remainingSeconds;
    return `${minutes}:${formattedSeconds}`;
}

    /*
    function initSampler() {
      sampler = new Tone.Sampler({
        urls: { 
          "C4": "C4.mp3", 
          "D#4": "Ds4.mp3", 
          "F#4": "Fs4.mp3", 
          "A4": "A4.mp3" 
        },
        release: 1,
        baseUrl: "https://tonejs.github.io/audio/salamander/"
      }).toDestination();
    } 
    */

    function initSampler() {
        Tone.context.lookAhead = 0;

      sampler = new Tone.Sampler({
        urls: { 
          "C1": "C1.mp3",
          "D#1": "Ds1.mp3",
          "F#1": "Fs1.mp3",
          "A1": "A1.mp3",
          "C2": "C2.mp3",
          "D#2": "Ds2.mp3",
          "F#2": "Fs2.mp3",
          "A2": "A2.mp3",
          "C3": "C3.mp3",
          "D#3": "Ds3.mp3",
          "F#3": "Fs3.mp3",
          "A3": "A3.mp3",
          "C4": "C4.mp3",
          "D#4": "Ds4.mp3",
          "F#4": "Fs4.mp3",
          "A4": "A4.mp3",
          "C5": "C5.mp3",
          "D#5": "Ds5.mp3",
          "F#5": "Fs5.mp3",
          "A5": "A5.mp3",
          "C6": "C6.mp3",
          "D#6": "Ds6.mp3",
          "F#6": "Fs6.mp3",
          "A6": "A6.mp3",
          "C7": "C7.mp3",
        },
        attack: 0.0,    // Ataque casi instantáneo (como piano real)
        decay: 0.2,      // Caída rápida inicial 
        sustain: 0.3,    // Nivel de sostenido (30% del volumen máximo)
        release: 3.5, 
        baseUrl: "https://tonejs.github.io/audio/salamander/"
      }).toDestination();
    }

    function createPiano88Keys() {
      pianoKeys.innerHTML = '';
      const pattern = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
      const blackKeys = { 'C': 'C#', 'D': 'D#', 'F': 'F#', 'G': 'G#', 'A': 'A#' };
      
      // Piano de 88 teclas: A0 a C8
      for (let octave = 0; octave <= 8; octave++) {
        const startNote = octave === 0 ? 9 : 0;
        
        for (let i = startNote; i <= 6; i++) {
          if (octave === 0 && i < 9) continue;
          if (octave === 8 && i > 0) break;
          
          const note = pattern[i % 7];
          const whiteKey = document.createElement('div');
          whiteKey.className = 'key white';
          whiteKey.id = `${note}${octave}`;
          pianoKeys.appendChild(whiteKey);
          
          if (blackKeys[note] && !(octave === 8 && note === 'C')) {
            const blackKey = document.createElement('div');
            blackKey.className = 'key black';
            blackKey.id = `${blackKeys[note]}${octave}`;
            pianoKeys.appendChild(blackKey);
          }
        }
      }
    }

    async function loadMusicXMLFromUrl(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Error de red');
        const text = await response.text();
        await osmd.load(text);
        osmdContainer.innerHTML = ''; 

        setupEngravingRulesForScreenSize();
        
        await osmd.render();
        populateMeasureSelector();
        
        parseMusicXML(text);
        scheduleNotesOnTransport();

        playBtn.disabled = false;
        setStatus('');
      } catch (err) {
        setStatus(`Error: ${err.message}`);
      }
    }


function parseMusicXML(xmlText) {
    parsedNotes = [];
    measureStartTimes = [0];
    const parser = new DOMParser();
    const xml = parser.parseFromString(xmlText, "application/xml");

    let title = xml.querySelector("work-title")?.textContent || 
                xml.querySelector("movement-title")?.textContent || 
                "Partitura Sin Título";
                
    let composer = xml.querySelector("creator[type='composer']")?.textContent || 
                   "Autor Desconocido";

    // Actualizamos la interfaz (Top Bar)
    const titleEl = document.querySelector('.song-title');
    const subtitleEl = document.querySelector('.song-subtitle');
    if (titleEl) titleEl.textContent = title;
    if (subtitleEl) subtitleEl.textContent = composer;

    const divisions = parseInt(xml.querySelector("divisions")?.textContent.trim() || "24", 10);
    const soundTempo = xml.querySelector("direction sound[tempo], sound[tempo]");
    globalTempo = soundTempo ? parseFloat(soundTempo.getAttribute("tempo")) : 120;
    updateBpmDisplay();
    Tone.Transport.bpm.value = globalTempo;

    const openTies = new Map(); // pitch+staff+voice -> noteObject
    
    xml.querySelectorAll('part').forEach((part, partIndex) => {
        let currentBeat = 0;

        const clefSign = part.querySelector('measure[number="1"] clef sign')?.textContent;
        const defaultHand = (clefSign === 'F') ? 'bass' : 'treble';

        const measures = part.querySelectorAll('measure');
        measures.forEach((measure, measureIndex) => {
            if (partIndex === 0 && measureIndex > 0) {
                measureStartTimes.push(currentBeat * (60.0 / globalTempo));
            }
            
            const nodes = measure.querySelectorAll('note, backup, forward');
            nodes.forEach(node => {
                const durationVal = parseFloat(node.querySelector('duration')?.textContent.trim() || '0');
                const durationInBeats = durationVal / divisions;

                if (node.tagName === 'note') {
                    const isChord = !!node.querySelector('chord');
                    const isGrace = !!node.querySelector('grace'); // NUEVO: Detectar grace notes
                    
                    if (!isChord && !isGrace) {
                        currentBeat += durationInBeats;
                    }
                    
                    if (!node.querySelector('rest') && node.querySelector('pitch')) {
                        const step = node.querySelector('step')?.textContent?.trim();
                        const octave = node.querySelector('octave')?.textContent?.trim();
                        const alterElement = node.querySelector('alter');
                        const altValue = alterElement ? parseInt(alterElement.textContent.trim(), 10) : 0;

                        // Manejar todas las alteraciones posibles
                        let accidental = '';
                        if (altValue === 2) accidental = '##';
                        else if (altValue === 1) accidental = '#';
                        else if (altValue === -1) accidental = 'b';
                        else if (altValue === -2) accidental = 'bb';

                        const pitch = `${step}${accidental}${octave}`;
                        
                        const staffNumber = parseInt(node.querySelector('staff')?.textContent);
                        const hand = !isNaN(staffNumber) ? (staffNumber === 1 ? 'treble' : 'bass') : defaultHand;
                        
                        const voice = node.querySelector('voice')?.textContent || '1';

                        const isTieStart = !!node.querySelector('tie[type="start"]');
                        const isTieStop = !!node.querySelector('tie[type="stop"]');
                        
                        const tieKey = `${pitch}-${hand}-${voice}`;

                        if (isTieStop && openTies.has(tieKey)) {
                            // CONTINUACIÓN DE LIGADURA
                            const existingNote = openTies.get(tieKey);
                            
                            // Crear una nota visual separada (para el cursor)
                            const noteStartTime = (currentBeat - durationInBeats) * (60.0 / globalTempo);
                            const continuationNote = {
                                pitch: pitch,
                                startSec: noteStartTime,
                                durSec: durationInBeats * (60.0 / globalTempo),
                                hand: hand,
                                isTied: true,
                                isTiedContinuation: true,
                                isChord: isChord,
                                isGrace: isGrace // NUEVO
                            };
                            parsedNotes.push(continuationNote);
                            
                            // Extender la duración de la nota original (para el audio)
                            existingNote.durSec += durationInBeats * (60.0 / globalTempo);
                            
                            if (!isTieStart) {
                                openTies.delete(tieKey);
                            }
                        } else {
                            // NOTA NUEVA
                            const noteStartTime = (currentBeat - durationInBeats) * (60.0 / globalTempo);
                            
                            // NUEVO: Grace notes tienen duración muy corta
                            const noteDuration = isGrace ? 0.05 : (durationInBeats * (60.0 / globalTempo));
                            
                            const newNote = {
                                pitch: pitch,
                                startSec: noteStartTime,
                                durSec: noteDuration,
                                hand: hand,
                                isTied: isTieStart,
                                isTiedContinuation: false,
                                isChord: isChord,
                                isGrace: isGrace // NUEVO
                            };
                            parsedNotes.push(newNote);

                            if (isTieStart) {
                                openTies.set(tieKey, newNote);
                            }
                        }
                    } else if (node.querySelector('rest')) {

                        const noteStartTime = (currentBeat - durationInBeats) * (60.0 / globalTempo);
                        
                        const staffNumber = parseInt(node.querySelector('staff')?.textContent);
                        const hand = !isNaN(staffNumber) ? (staffNumber === 1 ? 'treble' : 'bass') : defaultHand;
                        
                        const restNote = {
                            pitch: null,
                            startSec: noteStartTime,
                            durSec: durationInBeats * (60.0 / globalTempo),
                            hand: hand,
                            isRest: true,
                            isTied: false,
                            isTiedContinuation: false,
                            isChord: isChord,
                            isGrace: false // NUEVO
                        };
                        parsedNotes.push(restNote);
                    }
                } else if (node.tagName === 'backup') {
                    currentBeat -= durationInBeats;
                } else if (node.tagName === 'forward') {
                    currentBeat += durationInBeats;
                }
            });
        });
    });

    if (openTies.size > 0) {
        console.warn('Advertencia: Se encontraron ligaduras sin cerrar:', Array.from(openTies.keys()));
    }

    parsedNotes.sort((a, b) => a.startSec - b.startSec);
    const lastNote = parsedNotes[parsedNotes.length - 1];
    totalDuration = lastNote ? lastNote.startSec + lastNote.durSec : 0;
    totalTimeSpan.textContent = formatTime(totalDuration);
}


function scheduleNotesOnTransport() {
  if (audioPart) audioPart.dispose();
  if (visualPart) visualPart.dispose();
  Tone.Transport.cancel();
  osmd.cursor.reset();
  osmd.cursor.hide();

  const TIME_TOLERANCE = 0.001;
  
  const notesByTime = new Map();
  parsedNotes.forEach(note => {
    const time = note.startSec / playbackRate;
    
    let foundTime = null;
    for (let existingTime of notesByTime.keys()) {
      if (Math.abs(existingTime - time) < TIME_TOLERANCE) {
        foundTime = existingTime;
        break;
      }
    }
    
    if (foundTime !== null) {
      notesByTime.get(foundTime).push(note);
    } else {
      notesByTime.set(time, [note]);
    }
  });

  // Audio: solo notas reales (sin silencios) Y FILTRADAS POR MANO
  const audioEvents = [];
  notesByTime.forEach((notes, time) => {
    const realNotes = notes.filter(n => {
      if (n.isRest || n.isTiedContinuation) return false;
      
      if (handFilterMode === 'right' && n.hand !== 'treble') return false;
      if (handFilterMode === 'left' && n.hand !== 'bass') return false;
      
      return true;
    });
    
    if (realNotes.length > 0) {
      const uniquePitches = new Set();
      const uniqueNotes = realNotes.filter(note => {
        const normalizedPitch = normalizeNote(note.pitch);
        if (uniquePitches.has(normalizedPitch)) {
          return false;
        }
        uniquePitches.add(normalizedPitch);
        return true;
      });

      const normalizedPitches = uniqueNotes.map(n => normalizeNote(n.pitch));
      
      audioEvents.push({
        time: time,
        pitches: normalizedPitches,
        duration: uniqueNotes[0].durSec / playbackRate,
      });
    }
  });
  
  audioPart = new Tone.Part((time, value) => {
    sampler.triggerAttackRelease(value.pitches, value.duration, time);
  }, audioEvents).start(0);

  // MODIFICADO: Visual ahora TAMBIÉN respeta el filtro de manos para el cursor
  const visualEvents = [];
  notesByTime.forEach((notes, time) => {
    const uniquePitches = new Set();
    const uniqueNotes = notes.filter(note => {
      if (note.isRest) return true; // Siempre incluir silencios
      
      const normalizedPitch = normalizeNote(note.pitch);
      if (uniquePitches.has(normalizedPitch)) {
        return false;
      }
      uniquePitches.add(normalizedPitch);
      return true;
    });
    
    // NUEVO: Verificar si este grupo tiene notas relevantes según el filtro
    const hasRelevantNotes = uniqueNotes.some(note => {
      if (note.isRest) return true; // Los silencios siempre cuentan
      
      if (handFilterMode === 'both') return true;
      if (handFilterMode === 'right') return note.hand === 'treble';
      if (handFilterMode === 'left') return note.hand === 'bass';
      return false;
    });
    
    // Solo agregar evento visual si tiene notas relevantes
    if (hasRelevantNotes) {
      visualEvents.push({ 
        time, 
        notes: uniqueNotes.map(n => ({...n, duration: n.durSec / playbackRate}))
      });
    }
  });

  visualPart = new Tone.Part((time, value) => {
    Tone.Draw.schedule(() => {
      // MODIFICADO: Verificar si hay notas relevantes antes de avanzar cursor
      const relevantNotes = value.notes.filter(note => {
        if (note.isRest) return true;
        
        if (handFilterMode === 'both') return true;
        if (handFilterMode === 'right') return note.hand === 'treble';
        if (handFilterMode === 'left') return note.hand === 'bass';
        return false;
      });
      
      // Solo avanzar cursor si hay notas relevantes
      if (relevantNotes.length > 0) {
        osmd.cursor.next();
      }
      
      // Highlight solo de notas relevantes
      value.notes.forEach(note => {
        if (!note.isRest && !note.isTiedContinuation) {
          const shouldHighlight = 
            handFilterMode === 'both' || 
            (handFilterMode === 'right' && note.hand === 'treble') ||
            (handFilterMode === 'left' && note.hand === 'bass');
          
          if (shouldHighlight) {
            highlightKey(note.pitch, note.duration, note.hand);
          }
        }
      });
      
      if (isLoopMode) {
        checkAndLoopPlayback();
      }
    }, time);
  }, visualEvents).start(0);
  
  const newTotalDuration = totalDuration / playbackRate;
  if (isLoopMode) {
    const loopEndTime = (measureStartTimes[loopMeasureEnd + 1] || totalDuration) / playbackRate;
    Tone.Transport.scheduleRepeat(() => {
      checkAndLoopPlayback();
    }, "8n");
  } else {
    Tone.Transport.scheduleOnce(() => stopPlayback(), newTotalDuration + 0.5);
  }
}



function checkAndLoopPlayback() {
  if (!isLoopMode) return;
  
  const currentTime = Tone.Transport.seconds * playbackRate;
  const loopEndTime = measureStartTimes[loopMeasureEnd + 1] || totalDuration;
  
  // Si pasamos el final del loop, volver al inicio
  if (currentTime >= loopEndTime - 0.1) { // Pequeña tolerancia
    const loopStartTime = measureStartTimes[loopMeasureStart] / playbackRate;
    
    // Detener y reiniciar desde el inicio del loop
    Tone.Transport.seconds = loopStartTime;
    
    // IMPORTANTE: Resetear cursor visual al inicio del loop
    osmd.cursor.reset();
    let cursorTime = -1;
    for (let i = 0; i < parsedNotes.length; i++) {
      const note = parsedNotes[i];
      if (note.startSec < measureStartTimes[loopMeasureStart]) {
        if (note.startSec !== cursorTime) {
          osmd.cursor.next();
          cursorTime = note.startSec;
        }
      } else {
        break;
      }
    }
    
    console.log(`🔁 Loop reiniciado: Compás ${loopMeasureStart + 1} → ${loopMeasureEnd + 1}`);
  }
}


function initNativeMetronome() {
    // Crear contexto de audio independiente (para no interferir con Tone.js)
    if (!metronomeAudioCtx) {
        metronomeAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
}


function playMetronomeClick(isDownbeat = false) {
    if (!metronomeAudioCtx) return;

    const now = metronomeAudioCtx.currentTime;
    
    // Crear oscilador temporal
    const osc = metronomeAudioCtx.createOscillator();
    const gain = metronomeAudioCtx.createGain();
    
    osc.connect(gain);
    gain.connect(metronomeAudioCtx.destination);

    // MODIFICADO: Usar metronomeAccent en lugar de 4 fijo
    // Si metronomeAccent es 0, nunca hay downbeat (todos iguales)
    const actualDownbeat = metronomeAccent > 0 && isDownbeat;
    
    // Frecuencias: 1200Hz para el acento, 800Hz para los demás
    osc.frequency.value = actualDownbeat ? 1200 : 800;
    osc.type = 'sine';

    // Envolvente percusiva MUY corta (como metrónomo digital real)
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(actualDownbeat ? 1.0 : 0.7, now + 0.001);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);

    osc.start(now);
    osc.stop(now + 0.03);
}


function scheduleMetronomeNote() {
    if (!metronomeAudioCtx || !isMetronomeOn) return;
    
    const currentBPM = globalTempo * playbackRate;
    const secondsPerBeat = 60.0 / currentBPM;
    
    // Programar mientras estemos dentro de la ventana de anticipación
    while (metronomeNextNoteTime < metronomeAudioCtx.currentTime + metronomeScheduleAhead) {
        const isDownbeat = metronomeAccent > 0 && (metronomeBeatCount % metronomeAccent === 0);
        
        // Programar el click en el tiempo exacto
        playMetronomeClickScheduled(metronomeNextNoteTime, isDownbeat);
        
        // Avanzar al siguiente beat
        metronomeNextNoteTime += secondsPerBeat;
        metronomeBeatCount++;
    }
}

function playMetronomeClickScheduled(time, isDownbeat = false) {
    if (!metronomeAudioCtx) return;
    
    const osc = metronomeAudioCtx.createOscillator();
    const gain = metronomeAudioCtx.createGain();
    
    osc.connect(gain);
    gain.connect(metronomeAudioCtx.destination);

    const actualDownbeat = metronomeAccent > 0 && isDownbeat;
    osc.frequency.value = actualDownbeat ? 1200 : 800;
    osc.type = 'sine';

    // Programar la envolvente en el tiempo EXACTO
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(actualDownbeat ? 1.0 : 0.7, time + 0.001);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.03);

    osc.start(time);
    osc.stop(time + 0.03);
}

toggleMetronome = async function() {
    if (!metronomeAudioCtx) initNativeMetronome();

    isMetronomeOn = !isMetronomeOn;
    
    const btn = document.getElementById('metronome-btn');
    if (btn) {
        if (isMetronomeOn) btn.classList.add('active');
        else btn.classList.remove('active');
    }

    if (isMetronomeOn) {
        if (metronomeAudioCtx.state === 'suspended') {
            await metronomeAudioCtx.resume();
        }

        // Iniciar el scheduler
        metronomeBeatCount = 0;
        metronomeNextNoteTime = metronomeAudioCtx.currentTime;
        
        metronomeSchedulerId = setInterval(() => {
            scheduleMetronomeNote();
        }, metronomeLookahead);
        
        const currentBPM = globalTempo * playbackRate;
        console.log(`Metrónomo: ON (${currentBPM} BPM, acentuación cada ${metronomeAccent || 'sin acento'})`);
    } else {
        // Detener el scheduler
        if (metronomeSchedulerId) {
            clearInterval(metronomeSchedulerId);
            metronomeSchedulerId = null;
        }
        metronomeBeatCount = 0;
        
        console.log("Metrónomo: OFF");
    }
};

const originalUpdateSpeed = updateSpeed;
updateSpeed = function(newRate) {
    originalUpdateSpeed(newRate);
    
    // Si el metrónomo está activo, reiniciarlo con el nuevo BPM
    if (isMetronomeOn) {
        // Detener el actual
        if (metronomeInterval) {
            clearInterval(metronomeInterval);
        }
        
        // Reiniciar con nuevo tempo
        const currentBPM = globalTempo * playbackRate;
        const intervalMs = (60 / currentBPM) * 1000;
        
        metronomeInterval = setInterval(() => {
            const isDownbeat = (metronomeBeatCount % 4 === 0);
            playMetronomeClick(isDownbeat);
            metronomeBeatCount++;
        }, intervalMs);
        
        console.log(`Metrónomo actualizado: ${currentBPM} BPM`);
    }
};

const speedStep = 0.05;

function updateSpeed(newRate) {
    if (Tone.Transport.state === 'started') {
        stopPlayback();
    }
    
    playbackRate = Math.max(0.25, Math.min(2.0, newRate));
    
    const currentBPM = Math.round(globalTempo * playbackRate);
    speedBpmLabel.textContent = `${currentBPM} BPM`;
    
    // Si el metrónomo está activo, reiniciarlo con el nuevo BPM
    if (isMetronomeOn && metronomeSchedulerId) {
        clearInterval(metronomeSchedulerId);
        
        metronomeBeatCount = 0;
        metronomeNextNoteTime = metronomeAudioCtx.currentTime;
        
        metronomeSchedulerId = setInterval(() => {
            scheduleMetronomeNote();
        }, metronomeLookahead);
        
        console.log(`Metrónomo actualizado: ${currentBPM} BPM`);
    }
    
    scheduleNotesOnTransport();
}

// 3. Función para calcular la velocidad (playbackRate)
function updateMetronomeSpeed() {
    if (!metronomeAudio) return;
    const currentTotalBPM = globalTempo * playbackRate;
    metronomeAudio.playbackRate = currentTotalBPM / 60;
}






function startTutorial() {
    currentTutorialStep = 0;
    
    secondaryTopBar2.classList.add('is-visible');
    
    // Oculta el modal (quita .show) antes de mostrar el overlay
    tutorialModal.classList.remove('show'); 
    
    tutorialOverlay.style.display = 'block'; // Cambiado de 'flex' a 'block'
    setTimeout(() => tutorialOverlay.classList.add('is-visible'), 10);
    
    showTutorialStep(currentTutorialStep);
}


function endTutorial() {
    tutorialModal.classList.remove('show'); 
    
    tutorialOverlay.classList.remove('is-visible');
    setTimeout(() => {
        tutorialOverlay.style.display = 'none';
    }, 400); // Sincroniza con la animación del modal
    
    const highlightedEl = document.querySelector('.tutorial-highlight');
    if (highlightedEl) {
        highlightedEl.classList.remove('tutorial-highlight');
    }

    const parent = document.querySelector('.tutorial-parent-highlight');
    if (parent) {
        parent.classList.remove('tutorial-parent-highlight');
    }
    
    // NUEVO: Restablecer el filtro de manos a "ambas"
    if (isMidiLearnMode) {
        handFilterMode = 'both';
        rightHandOnlyBtn.style.background = 'none';
        rightHandOnlyBtn.style.color = '#1a1a1a';
        leftHandOnlyBtn.style.background = 'none';
        leftHandOnlyBtn.style.color = '#1a1a1a';
        updateStaffOpacity('both');
        
        // Recargar el paso actual con ambas manos
        if (currentLearningIndex > 0) {
            // Retroceder al inicio del paso actual
            const currentTime = parsedNotes[currentLearningIndex - 1]?.startSec;
            let tempIndex = currentLearningIndex - 1;
            
            while (tempIndex > 0 && Math.abs(parsedNotes[tempIndex - 1]?.startSec - currentTime) < 0.001) {
                tempIndex--;
            }
            
            currentLearningIndex = tempIndex;
            prepareFirstLearningStep();
        }
    }
}

function showTutorialStep(stepIndex) {
    // 1. Limpiar highlights anteriores
    const oldHighlightedEl = document.querySelector('.tutorial-highlight');
    if (oldHighlightedEl) {
        oldHighlightedEl.classList.remove('tutorial-highlight');
    }
    const oldParent = document.querySelector('.tutorial-parent-highlight');
    if (oldParent) {
        oldParent.classList.remove('tutorial-parent-highlight');
    }

    // 2. Ocultar el modal (para reposicionarlo)
    const modal = tutorialModal;
    modal.classList.remove('show', 'arrow-bottom');

    const step = tutorialSteps[stepIndex];
    if (!step) return;

    if (step.onShow) {
        step.onShow();
    }

    // 3. Resaltar el nuevo elemento
    const element = document.getElementById(step.elementId);
    if (!element) {
        console.error("Elemento del tutorial no encontrado:", step.elementId);
        return;
    }

    element.classList.add('tutorial-highlight');
    
    // MODIFICADO: Manejar el contenedor padre del piano
    let parentContext;
    if (step.elementId === 'piano-keys') {
        parentContext = document.getElementById('piano-container');
    } else {
        parentContext = element.closest('#top-bar, #secondary-top-bar, #secondary-top-bar2');
    }
    
    if (parentContext) {
        parentContext.classList.add('tutorial-parent-highlight');
    }
    
    if (window.getComputedStyle(element).display === 'none') {
         element.style.display = 'flex'; 
    }
    
    // 4. Actualizar el contenido del modal
    tutorialTitle.textContent = step.title;
    tutorialText.innerHTML = step.text;

    // Mostrar u ocultar el botón "Siguiente" según si requiere interacción
    if (step.requiresClick) {
        tutorialNextBtn.style.display = 'none';
    } else if (stepIndex < tutorialSteps.length - 1) {
        tutorialNextBtn.textContent = 'Siguiente';
        tutorialNextBtn.style.display = 'inline-block';
    } else {
        tutorialNextBtn.textContent = 'Finalizar';
        tutorialNextBtn.style.display = 'inline-block';
    }
    
    // 5. IMPORTANTE: Forzar que el modal sea visible (pero sin animación aún)
    modal.style.display = 'block';
    modal.style.opacity = '0';

    // 6. Calcular posición DESPUÉS de que el modal tenga sus dimensiones
    setTimeout(() => {
        const rect = element.getBoundingClientRect();
        const modalWidth = modal.offsetWidth;
        const modalHeight = modal.offsetHeight;
        const gap = 15;

        let modalTop = rect.bottom + gap;
        let isModalAbove = false;
const shouldGoUp = (step.placement === 'top') || 
                   (step.elementId === 'piano-keys') || 
                   (step.placement !== 'bottom' && (modalTop + modalHeight > window.innerHeight - 10));

if (shouldGoUp) {
    modalTop = rect.top - modalHeight - gap;
    isModalAbove = true;
    modal.classList.add('arrow-bottom');
} else {
    modal.classList.remove('arrow-bottom');
}
        
        let modalLeft = rect.left + (rect.width / 2) - (modalWidth / 2);

        if (modalLeft < 10) {
            modalLeft = 10;
        }
        if (modalLeft + modalWidth > window.innerWidth - 10) {
            modalLeft = window.innerWidth - 10 - modalWidth;
        }

        const buttonCenterX = rect.left + (rect.width / 2);
        const modalLeftEdge = modalLeft;
        const arrowPosition = buttonCenterX - modalLeftEdge;
        const clampedArrowPosition = Math.max(20, Math.min(arrowPosition, modalWidth - 20));

        modal.style.top = `${modalTop}px`;
        modal.style.left = `${modalLeft}px`;
        modal.style.setProperty('--arrow-left', `${clampedArrowPosition}px`);
        
        modal.style.opacity = '';
        modal.classList.add('show');
    }, 10);
}


function nextTutorialStep() {
    currentTutorialStep++;
    
    if (currentTutorialStep < tutorialSteps.length) {
        showTutorialStep(currentTutorialStep);
    } else {
        // Se hizo clic en "Finalizar"
        endTutorial();
    }
}

function updatePracticeProgress() {
    if (parsedNotes.length === 0) {
        const globalFill = document.getElementById('global-progress-fill');
        const globalText = document.getElementById('global-progress-text');
        if (globalFill) globalFill.style.width = '0%';
        if (globalText) globalText.textContent = '0%';
        return;
    }
    
    const percentage = Math.floor((currentLearningIndex / parsedNotes.length) * 100);
    const finalPercent = Math.min(percentage, 100);
    const globalFill = document.getElementById('global-progress-fill');
    const globalText = document.getElementById('global-progress-text');
    if (globalFill) globalFill.style.width = `${finalPercent}%`;
    if (globalText) globalText.textContent = `${finalPercent}%`;
    window.parent.postMessage({
        type: 'progressUpdate',
        percent: finalPercent,
        title: osmd.sheet.title ? osmd.sheet.title.text : 'Partitura'
    }, '*');
}


function updateGlobalProgressByChunks() {
    if (!osmd || !osmd.sheet) return;
    
    const totalMeasures = osmd.sheet.SourceMeasures.length;
    const chunkProgress = Math.floor((unlockedMeasureCount / totalMeasures) * 100);
    const finalPercent = Math.max(0, Math.min(chunkProgress, 100));
    const globalFill = document.getElementById('global-progress-fill');
    if (globalFill) {
        globalFill.style.width = `${finalPercent}%`;
        
        // Opcional: Cambiar color si llega al 100%
        if (finalPercent >= 100) {
            globalFill.style.backgroundColor = '#27ae60'; // Verde más oscuro
        }
    }
    const globalText = document.getElementById('global-progress-text');
    if (globalText) {
        globalText.textContent = `${finalPercent}%`;
    }
    
    window.parent.postMessage({
        type: 'progressUpdate',
        percent: finalPercent,
        title: osmd.sheet.title ? osmd.sheet.title.text : 'Partitura'
    }, '*');
}

window.addEventListener('message', function(event) {
    const data = event.data;
    if (data && data.type === 'restoreProgress') {
        const savedPercent = parseInt(data.percent);
        if (!isNaN(savedPercent) && savedPercent > 0) {
            restoreFogStateFromPercent(savedPercent);
            updateGlobalProgressByChunks();
        }
    }
});




/*
function restoreFogStateFromPercent(percent) {
    if (!osmd || !osmd.sheet) {
        setTimeout(() => restoreFogStateFromPercent(percent), 500);
        return;
    }

    const totalMeasures = osmd.sheet.SourceMeasures.length;
    let measuresToUnlock = Math.floor((percent / 100) * totalMeasures);
    measuresToUnlock = Math.ceil(measuresToUnlock / MEASURES_PER_CHUNK) * MEASURES_PER_CHUNK;
    measuresToUnlock = Math.max(MEASURES_PER_CHUNK, Math.min(measuresToUnlock, totalMeasures));

    unlockedMeasureCount = measuresToUnlock;
    
    if (percent >= 100) isPieceCompleted = true;
    
    if (isMidiLearnMode) {
        setRangeOpacity(0, unlockedMeasureCount, 1);
        setRangeOpacity(unlockedMeasureCount, totalMeasures, 0.15);
        populateMeasureSelector();
        const lastChunkIndex = Math.max(0, unlockedMeasureCount - MEASURES_PER_CHUNK);
        measureSelect.value = lastChunkIndex;
        jumpToMeasureInLearnMode(lastChunkIndex);
    }
    updateGlobalProgressByChunks();
}
*/

function restoreFogStateFromPercent(percent) {
    if (!osmd || !osmd.sheet) {
        setTimeout(() => restoreFogStateFromPercent(percent), 500);
        return;
    }

    const totalMeasures = osmd.sheet.SourceMeasures.length;
    let measuresToUnlock = Math.floor((percent / 100) * totalMeasures);
    measuresToUnlock = Math.ceil(measuresToUnlock / MEASURES_PER_CHUNK) * MEASURES_PER_CHUNK;
    measuresToUnlock = Math.max(MEASURES_PER_CHUNK, Math.min(measuresToUnlock, totalMeasures));
    unlockedMeasureCount = measuresToUnlock;
    
    if (percent >= 100) isPieceCompleted = true;
    if (isMidiLearnMode) {
        setRangeOpacity(0, unlockedMeasureCount, 1);
        setRangeOpacity(unlockedMeasureCount, totalMeasures, 0.15);
        populateMeasureSelector();
        const lastChunkIndex = Math.max(0, unlockedMeasureCount - MEASURES_PER_CHUNK);
        measureSelect.value = lastChunkIndex;
    }
    updateGlobalProgressByChunks();
}




function updateMeasureSelectDisplay() {
    // Si estamos al principio o fuera de los límites, resetea al compás 1.
    if (currentLearningIndex === 0 || currentLearningIndex > parsedNotes.length) {
        measureSelect.value = 0;
        return;
    }
    const currentNoteTime = parsedNotes[currentLearningIndex - 1].startSec;

    let currentMeasureIndex = 0;
    for (let i = measureStartTimes.length - 1; i >= 0; i--) {
        // Usamos una pequeña tolerancia (0.001s)
        if (currentNoteTime >= measureStartTimes[i] - 0.001) {
            currentMeasureIndex = i;
            break;
        }
    }

    // Actualiza el valor del dropdown
    measureSelect.value = currentMeasureIndex;
}

function jumpToMeasureInLearnMode(measureIndex) {
    if (!isMidiLearnMode) return;
    expectedNotes.clear();
    clearAllHighlights();
    const startTime = measureStartTimes[measureIndex] || 0;
    let newIndex = 0;
    for (let i = 0; i < parsedNotes.length; i++) {
        if (parsedNotes[i].startSec >= startTime - 0.001) { 
            newIndex = i;
            break;
        }
    }
    currentLearningIndex = newIndex;
    osmd.cursor.hide();
    osmd.cursor.reset();
    let uniqueTimeSteps = new Set();
    for(let i = 0; i < currentLearningIndex; i++) {
        if (i === 0 || (parsedNotes[i].startSec > parsedNotes[i-1].startSec + 0.001)) {
           uniqueTimeSteps.add(parsedNotes[i].startSec);
        }
    }
    uniqueTimeSteps.forEach(() => {
        osmd.cursor.next();
    });
    
    prepareFirstLearningStep(); 
    osmd.cursor.show();
    measureSelect.value = measureIndex;
}


function playFromMeasure(measureIndex) {
    clearAllHighlights();

    if (Tone.Transport.state === 'started') stopPlayback();
    
    const startTime = measureStartTimes[measureIndex] || 0;
    
    osmd.cursor.reset();
    
    let currentTime = -1;
    parsedNotes.forEach(note => {
        if (note.startSec < startTime && note.startSec !== currentTime) {
            osmd.cursor.next();
            currentTime = note.startSec;
        }
    });

    if (isLoopMode) {
        Tone.Transport.cancel();
        scheduleNotesOnTransport();
    }
    
    // Sincronizar metrónomo
    if (isMetronomeOn) {
        metronomeBeatCount = 0;
        
        if (metronomeSchedulerId) {
            clearInterval(metronomeSchedulerId);
        }
        
        metronomeNextNoteTime = metronomeAudioCtx.currentTime + 0.1;
        
        metronomeSchedulerId = setInterval(() => {
            scheduleMetronomeNote();
        }, metronomeLookahead);
    }
    
    Tone.Transport.start(Tone.now() + 0.1, startTime / playbackRate);
    updatePlayButton(true);
    osmd.cursor.show();
    startProgressUpdate();
}

function stopPlayback() {
    Tone.Transport.stop();
    osmd.cursor.reset();
    osmd.cursor.hide();
    updatePlayButton(false);
    stopProgressUpdate();
    
    clearAllHighlights();
    waterfallScrollOffset = 0;

    progressBar.value = 0;
    progressBar.style.setProperty('--progress', '0%');
    currentTimeSpan.textContent = '0:00';
    
    // Pausar metrónomo
    if (isMetronomeOn && metronomeSchedulerId) {
        clearInterval(metronomeSchedulerId);
        metronomeSchedulerId = null;
        metronomeBeatCount = 0;
    }
}

function startProgressUpdate() {
    stopProgressUpdate();
    progressInterval = setInterval(() => {
        // Obtenemos el tiempo actual de Tone.js
        const currentTime = Tone.Transport.seconds;
      
        // Corregimos la duración total para que coincida con la velocidad de reproducción
        const effectiveTotalDuration = totalDuration / playbackRate;
        const progress = (currentTime / effectiveTotalDuration) * 100;

        progressBar.value = Math.min(progress, 100);
        progressBar.style.setProperty('--progress', `${progress}%`);

        // --- LÍNEA NUEVA ---
        // Actualiza el texto con el tiempo actual formateado
        currentTimeSpan.textContent = formatTime(currentTime);

    }, 100); // Se actualiza 10 veces por segundo
}

    function stopProgressUpdate() {
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
    }

    function addEventListeners() {
      
playBtn.addEventListener('click', async () => {
    await Tone.start();
    
    if (Tone.Transport.state === 'started') {
        // PAUSAR
        Tone.Transport.pause();
        updatePlayButton(false);
        stopProgressUpdate();
        activeHighlightTimeouts.forEach(clearTimeout);
        activeHighlightTimeouts = [];
        
        // Pausar metrónomo
        if (isMetronomeOn && metronomeSchedulerId) {
            clearInterval(metronomeSchedulerId);
            metronomeSchedulerId = null;
        }
    } else {
        // REPRODUCIR
        clearAllHighlights(); 
        
        // NUEVO: Sincronizar metrónomo con Tone.js
        if (isMetronomeOn) {
            metronomeBeatCount = 0;
            
            // Detener scheduler anterior si existe
            if (metronomeSchedulerId) {
                clearInterval(metronomeSchedulerId);
            }
            
            // CLAVE: Sincronizar con el tiempo de inicio de Tone.js
            // Tone.js inicia en Tone.now() + 0.1, entonces el metrónomo también
            metronomeNextNoteTime = metronomeAudioCtx.currentTime + 0.1;
            
            // Reiniciar el scheduler
            metronomeSchedulerId = setInterval(() => {
                scheduleMetronomeNote();
            }, metronomeLookahead);
            
            const currentBPM = globalTempo * playbackRate;
            console.log(`🎵 Metrónomo sincronizado (${currentBPM} BPM)`);
        }
        
        Tone.Transport.start(Tone.now() + 0.1);
        updatePlayButton(true);
        osmd.cursor.show();
        startProgressUpdate();
    }
});



 rightHandOnlyBtn.addEventListener('click', toggleRightHandOnly);
  leftHandOnlyBtn.addEventListener('click', toggleLeftHandOnly);
  showKeyNamesBtn.addEventListener('click', toggleKeyNames);

speedUpBtn.addEventListener('click', () => {
        updateSpeed(playbackRate + 0.05);
    });

    speedDownBtn.addEventListener('click', () => {
        updateSpeed(playbackRate - 0.05);
    });


     accentUpBtn.addEventListener('click', () => {
        metronomeAccent = Math.min(6, metronomeAccent + 1);
        accentValueSpan.textContent = metronomeAccent;
        
        // Si el metrónomo está activo, reiniciarlo con la nueva acentuación
        if (isMetronomeOn) {
            metronomeBeatCount = 0; // Resetear contador para que empiece en downbeat
            console.log(`Acentuación cambiada a: cada ${metronomeAccent} beats`);
        }
    });

    accentDownBtn.addEventListener('click', () => {
        metronomeAccent = Math.max(0, metronomeAccent - 1);
        accentValueSpan.textContent = metronomeAccent;
        
        if (isMetronomeOn) {
            metronomeBeatCount = 0;
            console.log(`Acentuación cambiada a: ${metronomeAccent === 0 ? 'sin acento' : 'cada ' + metronomeAccent + ' beats'}`);
        }
    });

micBtn.addEventListener('click', toggleMicMode);
muteBtn.addEventListener('click', toggleMutePiano);

restartChunkBtn.addEventListener('click', restartCurrentChunk);

metronomeBtn.addEventListener('click', toggleMetronome);
 
      pianoBtn.addEventListener('click', () => {
        togglePianoView();
      });
      
      // Controles de zoom
      zoomInBtn.addEventListener('click', () => {
        currentZoom = Math.min(2.0, currentZoom + 0.1);
        applyZoom();
      });
      
      zoomOutBtn.addEventListener('click', () => {
        currentZoom = Math.max(0.5, currentZoom - 0.1);
        applyZoom();
      });

      successModalCloseBtn.addEventListener('click', hideSuccessModal);


 
      midiLearnBtn.addEventListener('click', toggleMidiLearnMode);
      
      // Redimensionar ventana
window.addEventListener('resize', () => {
  const newIsMobile = window.innerWidth <= 768;
  if (newIsMobile !== isMobile) {
    isMobile = newIsMobile;
    if (osmd) {
      setupEngravingRulesForScreenSize();
      osmd.render();
    }
  }
  // Redimensionar el canvas del waterfall con los nuevos tamaños de teclas
  if (waterfallCanvas) {
    resizeWaterfallCanvas();
  }
});
      
 //cursorBtn.addEventListener('click', toggleCursorType);
  fullscreenBtn.addEventListener('click', toggleFullScreen);

  // Opcional pero recomendado: Actualiza el ícono si el usuario sale con la tecla ESC
  document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) {
      fullscreenBtn.querySelector('i').className = 'ri-fullscreen-line';
    }
  });

progressBar.addEventListener('input', () => {
  // 1. Calcula a qué tiempo quiere saltar el usuario (en segundos)
  const seekTime = (progressBar.value / 100) * totalDuration;

  const progressValue = (progressBar.value / 100) * 100; // El valor ya es 0-100
progressBar.style.setProperty('--progress', `${progressValue}%`);

  // 2. Encuentra a qué compás corresponde ese tiempo
  let targetMeasureIndex = 0;
  for (let i = 0; i < measureStartTimes.length; i++) {
    if (measureStartTimes[i] <= seekTime) {
      targetMeasureIndex = i;
    } else {
      break;
    }
  }

  // 3. Llama a tu función para reproducir desde ese compás
  // Esto mantiene el cursor visual y el audio perfectamente sincronizados.
  playFromMeasure(targetMeasureIndex);
});



measureSelect.addEventListener('change', () => {
    const selectedMeasureIndex = parseInt(measureSelect.value, 10);
    
    // --- NUEVO: SINCRONIZAR TIMELINE AL SELECCIONAR COMPÁS ---
    if (measureStartTimes.length > 0 && totalDuration > 0) {
        const startTime = measureStartTimes[selectedMeasureIndex] || 0;
        // Calculamos el porcentaje (0 a 100)
        const progressPercent = (startTime / totalDuration) * 100;
        
        // Actualizamos el input oculto y la barra visual
        originalProgressBar.value = progressPercent;
        updateCustomSliderUI(progressPercent); 
        // Nota: updateCustomSliderUI ahora (ver abajo) actualizará el texto del compás también
    }
    // ---------------------------------------------------------

    // Habilitar measure-until y actualizar sus opciones
    measureUntil.disabled = false;
    updateMeasureUntilOptions(selectedMeasureIndex);
    
    // Lógica de Modos (Igual que antes)
    if (isLoopMode) {
        loopMeasureStart = selectedMeasureIndex;
        if (measureUntil.value !== '-1') {
            loopMeasureEnd = parseInt(measureUntil.value, 10);
        }
        jumpToMeasureInLearnMode(loopMeasureStart);
    } 
    else if (isMidiLearnMode) {
        jumpToMeasureInLearnMode(selectedMeasureIndex);
    }
    else {
        playFromMeasure(selectedMeasureIndex);
    }
});

  measureUntil.addEventListener('change', () => {
    const untilValue = measureUntil.value;
    
    if (untilValue === '-1') {
        // Desactivar modo loop
        deactivateLoopMode();
    } else {
        // Activar modo loop
        loopMeasureStart = parseInt(measureSelect.value, 10);
        loopMeasureEnd = parseInt(untilValue, 10);
        isLoopMode = true;
        cancelLoopBtn.style.display = 'flex';
        cancelLoopBtn.classList.add('active');
        
        console.log(`Loop activado: compases ${loopMeasureStart + 1} a ${loopMeasureEnd + 1}`);
        
        // Saltar al inicio del loop
        jumpToMeasureInLearnMode(loopMeasureStart);
    }
});

// NUEVO: Event listener para cancelar loop
cancelLoopBtn.addEventListener('click', () => {
    deactivateLoopMode();
    measureUntil.value = '-1';
});



      toolsToggleBtn.addEventListener('click', () => {
        secondaryTopBar.classList.toggle('is-visible');
    });

     modalCloseBtn.addEventListener('click', hideModal);

   startTutorialBtn.addEventListener('click', () => {
    if (tutorialAlertTimeout) {
        clearTimeout(tutorialAlertTimeout);
        tutorialMidiAlert.classList.remove('show');
    }
    if (midiAccess && midiAccess.inputs.size > 0) {
        startTutorial();
    } else {
        tutorialMidiAlert.classList.add('show');
        tutorialAlertTimeout = setTimeout(() => {
            tutorialMidiAlert.classList.remove('show');
            tutorialAlertTimeout = null;
        }, 3500);
    }
});
    tutorialCloseBtn.addEventListener('click', endTutorial);
    tutorialNextBtn.addEventListener('click', nextTutorialStep);

    // Opcional: Cierra el tutorial si se hace clic en el fondo (el overlay)
    tutorialOverlay.addEventListener('click', (e) => {
        if (e.target === tutorialOverlay) {
            endTutorial();
        }
    });


    }



// Variable para evitar bucles infinitos de actualización
let lastVisualMeasureIndex = -1;

function updateCustomSliderUI(percent) {
    // 1. Actualizar la barra visual (Ancho y Bolita)
    const fill = document.getElementById('track-fill');
    const knob = document.getElementById('track-knob');
    if (fill) fill.style.width = percent + '%';
    if (knob) knob.style.left = percent + '%';

    // 2. --- NUEVO: SINCRONIZAR TEXTO DEL COMPÁS (Timeline -> Select) ---
    // Solo si tenemos datos de tiempos
    if (measureStartTimes.length > 0 && totalDuration > 0) {
        const currentTime = (percent / 100) * totalDuration;
        
        // Buscar en qué compás estamos basado en el tiempo actual
        let currentMeasureIndex = 0;
        for (let i = measureStartTimes.length - 1; i >= 0; i--) {
            // Usamos una pequeña tolerancia (+0.1) para asegurar que el cambio se sienta natural
            if (currentTime >= measureStartTimes[i] - 0.1) {
                currentMeasureIndex = i;
                break;
            }
        }

        // Solo actualizar el DOM si el compás cambió (Optimización)
        if (currentMeasureIndex !== lastVisualMeasureIndex) {
            lastVisualMeasureIndex = currentMeasureIndex;
            
            // A. Actualizar el texto visual (Ej: "8")
            const display = document.getElementById('custom-measure-display');
            if (display) display.textContent = currentMeasureIndex + 1;

            // B. Sincronizar el select oculto (SIN disparar evento 'change' para evitar bucle infinito)
            const nativeSelect = document.getElementById('measure-select');
            if (nativeSelect) nativeSelect.value = currentMeasureIndex;
            
            // C. Marcar opción en la lista desplegable
            const opts = document.querySelectorAll('.measure-option');
            opts.forEach((el, idx) => {
                 if(idx === currentMeasureIndex) el.classList.add('current');
                 else el.classList.remove('current');
            });
        }
    }
}



function updateMeasureUntilOptions(startIndex) {
    if (!osmd || !osmd.sheet) return;

    const totalMeasures = osmd.sheet.SourceMeasures.length;
    const limit = isMidiLearnMode ? Math.min(unlockedMeasureCount, totalMeasures) : totalMeasures;
    
    measureUntil.innerHTML = '<option value="-1">Sin límite</option>';
    for (let i = startIndex + 1; i < limit; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Compás ${i + 1}`;
        measureUntil.appendChild(option);
    }
}


// NUEVA FUNCIÓN: Desactivar modo loop
function deactivateLoopMode() {
    isLoopMode = false;
    loopMeasureStart = -1;
    loopMeasureEnd = -1;
    cancelLoopBtn.style.display = 'none';
    cancelLoopBtn.classList.remove('active');
    console.log('Modo loop desactivado');
}

function toggleKeyNames() {
  showKeyNames = !showKeyNames;
  
  if (showKeyNames) {
    showKeyNamesBtn.style.background = '#e0e0e0';
    showKeyNamesOnPiano();
  } else {
    showKeyNamesBtn.style.background = 'none';
    hideKeyNamesOnPiano();
  }
  
  console.log(`Mostrar nombres de teclas: ${showKeyNames}`);
}

function togglePianoView() {
    // Ciclo: full <-> waterfall-only (Eliminado piano-only)
    if (pianoViewMode === 'full') {
        // Cambiar a Waterfall Only
        pianoViewMode = 'waterfall-only';
        
        pianoContainer.classList.remove('piano-only');
        pianoContainer.classList.add('waterfall-only');
        

        pianoBtn.style.backgroundColor = '#e0e0e0';
        
    } else {
        // Volver a Full View
        pianoViewMode = 'full';
        
        pianoContainer.classList.remove('waterfall-only');
        pianoContainer.classList.remove('piano-only');
        
        // Mostrar partitura
        document.getElementById('sheet-music-wrapper').style.display = 'block';
        
        // Quitar fondo del botón
        pianoBtn.style.backgroundColor = 'transparent';
    }

    setTimeout(() => {
        resizeWaterfallCanvas();
    }, 100);

}
// Función para mostrar nombres en las teclas blancas
function showKeyNamesOnPiano() {
  const whiteKeys = document.querySelectorAll('.key.white');
  
  whiteKeys.forEach(key => {
    const noteName = key.id.replace('#', '');
    const displayName = getAngloSaxonNoteName(noteName);
    
    // Crear elemento para el nombre
    const nameElement = document.createElement('div');
    nameElement.className = 'key-name';
    nameElement.textContent = displayName;
    nameElement.style.cssText = `
      position: absolute;
      bottom: 5px;
      width: 100%;
      text-align: center;
      font-size: 10px;
      font-weight: bold;
      color: #333;
      pointer-events: none;
      z-index: 10;
    `;
    
    key.appendChild(nameElement);
    key.classList.add('has-name');
  });
}

// Función para ocultar nombres de las teclas
function hideKeyNamesOnPiano() {
  const keyNames = document.querySelectorAll('.key-name');
  keyNames.forEach(nameElement => {
    nameElement.remove();
  });
  
  const keysWithNames = document.querySelectorAll('.key.has-name');
  keysWithNames.forEach(key => {
    key.classList.remove('has-name');
  });
}

// Función para convertir a sistema anglosajón
function getAngloSaxonNoteName(noteId) {
  // Mapa de conversión para notas con sostenidos
  const noteMap = {
    'C': 'C', 'C#': 'C#',
    'D': 'D', 'D#': 'D#', 
    'E': 'E',
    'F': 'F', 'F#': 'F#',
    'G': 'G', 'G#': 'G#',
    'A': 'A', 'A#': 'A#',
    'B': 'B'
  };
  
  // Extraer la nota y la octava (ej: "C4", "D#5")
  const noteMatch = noteId.match(/^([A-G]#?)(\d+)$/);
  if (noteMatch) {
    const note = noteMatch[1];
    const octave = noteMatch[2];
    return `${noteMap[note] || note}`;
  }
  
  return noteId; // Fallback
}

function populateMeasureSelector() {
    if (!osmd || !osmd.sheet) return;

    const totalMeasures = osmd.sheet.SourceMeasures.length;
    measureSelect.innerHTML = '';
    const limit = isMidiLearnMode ? Math.min(unlockedMeasureCount, totalMeasures) : totalMeasures;

    for (let i = 0; i < limit; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Compás ${i + 1}`;
        measureSelect.appendChild(option);
    }
    measureUntil.innerHTML = '<option value="-1">Sin límite</option>';
}

function restartCurrentChunk() {
    // Evitar ejecuciones si no estamos en modo aprendizaje o ya se está reiniciando
    if (!isMidiLearnMode || isRestarting) return;
    
    isRestarting = true;
    let targetMeasureIndex = 0;
    if (isLoopMode) {
        // Regresar al inicio del bucle seleccionado
        targetMeasureIndex = loopMeasureStart;
    } 
    else if (isPieceCompleted) {
        // Obtener compás actual y regresar 2 atrás
        const currentMs = getCurrentMeasureIndex();
        targetMeasureIndex = Math.max(0, currentMs - 2);
    } 
    else {
        targetMeasureIndex = Math.max(0, unlockedMeasureCount - MEASURES_PER_CHUNK);
    }
    jumpToMeasureInLearnMode(targetMeasureIndex);
    isRestarting = false;
}


function toggleCursorType() {
  if (!osmd || !osmd.cursor) return;

  // CORRECCIÓN: Se usa .cursorOptions en lugar de .Options
  const newType = osmd.cursor.cursorOptions.type === 1 ? 3 : 1;
  osmd.cursor.cursorOptions.type = newType;

  // Cambia el color del botón para dar feedback visual
  if (newType === 3) {
     osmd.cursor.cursorOptions.alpha = 0.45;
    osmd.cursor.cursorOptions.color = "rgba(52, 152, 219, 0.45)";
  } else {
    osmd.cursor.cursorOptions.alpha =0.8;
    osmd.cursor.cursorOptions.color = "rgba(52, 152, 219, 0.8)";
  }
}

function clearAllHighlights() {
  // OPTIMIZACIÓN: Limpiar timeouts más rápido
  for (let i = activeHighlightTimeouts.length - 1; i >= 0; i--) {
    clearTimeout(activeHighlightTimeouts[i]);
  }
  activeHighlightTimeouts.length = 0;

  // OPTIMIZACIÓN: Usar querySelectorAll una sola vez
  const activeKeys = document.querySelectorAll('.active-treble, .active-bass');
  for (const key of activeKeys) {
    key.classList.remove('active-treble', 'active-bass');
  }
}

function toggleFullScreen() {
  const icon = fullscreenBtn.querySelector('i');
  if (!document.fullscreenElement) {
    // Entrar en pantalla completa
    document.documentElement.requestFullscreen();
    icon.className = 'ri-fullscreen-exit-line'; // Cambia al ícono de "salir"
  } else {
    // Salir de pantalla completa
    if (document.exitFullscreen) {
      document.exitFullscreen();
      icon.className = 'ri-fullscreen-line'; // Cambia al ícono de "entrar"
    }
  }
}

    function applyZoom() {
      if (osmd) {
        osmd.zoom = currentZoom;
        osmd.render();
        updateZoomDisplay();

      }
    }

    function updateZoomDisplay() {
      zoomLabel.textContent = `${Math.round(currentZoom * 100)}%`;
    }

    function updatePlayButton(isPlaying) {
      playIcon.style.display = isPlaying ? 'none' : 'block';
      pauseIcon.style.display = isPlaying ? 'block' : 'none';
    }

    function updateBpmDisplay() {
      const currentBPM = Math.round(globalTempo * currentSpeed);
      speedBpmLabel.textContent = `${currentBPM} BPM`;
    }


function highlightKey(noteName, durSec, hand, persist = false) {
    const noteId = normalizeNote(noteName);
    const el = document.getElementById(noteId);
    if (!el) return;

    const highlightClass = hand === 'treble' ? 'active-treble' : 'active-bass';
    el.classList.add(highlightClass);
    
    // NUEVO: Agregar efecto de flash
    createNoteFlashPiano(noteName, hand);

    if (!persist) {
        const highlightDuration = Math.max(80, durSec * 1000 / currentSpeed);
        const timeoutId = setTimeout(() => {
            el.classList.remove(highlightClass);
            activeHighlightTimeouts = activeHighlightTimeouts.filter(id => id !== timeoutId);
        }, highlightDuration);
        activeHighlightTimeouts.push(timeoutId);
    }
}


function highlightKeyInstant(noteName, hand) {
    const noteId = normalizeNote(noteName);
    const el = document.getElementById(noteId);
    if (!el) return;

    const highlightClass = hand === 'treble' ? 'active-treble' : 'active-bass';
    el.classList.add(highlightClass);
}

function normalizeNote(noteName) {
    const flatToSharp = {
        // Bemoles simples
        'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#',
        // Naturales enarmónicos
        'Cb': 'B', 'Fb': 'E', 'E#': 'F', 'B#': 'C',
        // Dobles bemoles
        'Dbb': 'C', 'Ebb': 'D', 'Fbb': 'D#', 'Gbb': 'F', 'Abb': 'G', 
        'Bbb': 'A', 'Cbb': 'A#',
        // Dobles sostenidos
        'C##': 'D', 'D##': 'E', 'E##': 'F#', 'F##': 'G', 
        'G##': 'A', 'A##': 'B', 'B##': 'C#'
    };
    
    // Regex mejorado para capturar dobles alteraciones
    const match = noteName.match(/^([A-G])(bb|##|b|#)?(\d+)$/);
    if (!match) {
        console.warn(`No se pudo normalizar la nota: ${noteName}`);
        return noteName;
    }
    
    const [, noteLetter, alteration, octave] = match;
    const noteWithAlt = noteLetter + (alteration || ''); // Ej: "C##", "Dbb", "E"
    let normalizedNote = flatToSharp[noteWithAlt] || noteWithAlt;
    let finalOctave = parseInt(octave);
    
    // Casos especiales de cambio de octava
    if (noteWithAlt === 'Cb') {
        normalizedNote = 'B';
        finalOctave -= 1;
    } else if (noteWithAlt === 'Cbb') {
        normalizedNote = 'A#';
        finalOctave -= 1;
    } else if (noteWithAlt === 'B#') {
        normalizedNote = 'C';
        finalOctave += 1;
    } else if (noteWithAlt === 'B##') {
        normalizedNote = 'C#';
        finalOctave += 1;
    }
    
    return normalizedNote + finalOctave;
}

function advanceLearningStep() {
    const activeKeys = document.querySelectorAll('.active-treble, .active-bass');
    activeKeys.forEach(key => key.classList.remove('active-treble', 'active-bass'));
    activeHighlightTimeouts.forEach(clearTimeout);
    activeHighlightTimeouts.length = 0;
    expectedNotes.clear();

    if (isLoopMode && parsedNotes[currentLearningIndex]) {
        const currentMsIndex = getCurrentMeasureIndex();
        if (currentMsIndex > loopMeasureEnd) {
             jumpToMeasureInLearnMode(loopMeasureStart);
             return; 
        }
    }

    const totalMeasures = osmd.sheet.SourceMeasures.length;
    if (currentLearningIndex >= parsedNotes.length) {
        if (!isPieceCompleted) {
            showSuccessModal("🎉 ¡Felicidades! Has completado la pieza.<br>Has desbloqueado el <strong>Modo Libre</strong>.");
            showConfetti(300);
            isPieceCompleted = true;
            unlockedMeasureCount = totalMeasures;
            updateGlobalProgressByChunks();
        }
        toggleMidiLearnMode();
        return;
    }

    // --- LÓGICA DE NIEBLA Y CHECKPOINTS ---
    if (isMidiLearnMode && parsedNotes[currentLearningIndex]) {
        const nextNoteTime = parsedNotes[currentLearningIndex].startSec;
        let nextNoteMeasureIndex = 0;
        for (let i = measureStartTimes.length - 1; i >= 0; i--) {
            if (nextNoteTime >= measureStartTimes[i] - 0.001) {
                nextNoteMeasureIndex = i;
                break;
            }
        }

     


      if (unlockedMeasureCount < totalMeasures) {
            if (nextNoteMeasureIndex >= unlockedMeasureCount) {
                const oldLimit = unlockedMeasureCount;
                unlockedMeasureCount += MEASURES_PER_CHUNK;
                if (unlockedMeasureCount > totalMeasures){ unlockedMeasureCount = totalMeasures};
                setRangeOpacity(oldLimit, unlockedMeasureCount, 1);
                populateMeasureSelector();
                updateGlobalProgressByChunks(); 
                
                showSuccessToast(`¡Sección Superada!`);
            }
        }


    }

    let notesInStep = [];
    let foundValidStep = false;
    const TIME_TOLERANCE = 0.001;

    while (currentLearningIndex < parsedNotes.length && !foundValidStep) {
        const nextNoteTime = parsedNotes[currentLearningIndex].startSec;

        notesInStep = [];      
        while (currentLearningIndex < parsedNotes.length && 
               Math.abs(parsedNotes[currentLearningIndex].startSec - nextNoteTime) < TIME_TOLERANCE) {
            notesInStep.push(parsedNotes[currentLearningIndex]);
            currentLearningIndex++;
        }

        const filteredNotes = notesInStep.filter(note => 
            !note.isRest &&
            !note.isTiedContinuation &&
            (handFilterMode === 'both' || 
            (handFilterMode === 'right' && note.hand === 'treble') ||
            (handFilterMode === 'left' && note.hand === 'bass'))
        );

        if (filteredNotes.length > 0) {
            foundValidStep = true;
            osmd.cursor.next();
            
            const uniquePitches = new Set();
            filteredNotes.forEach(note => { 
                 const normalizedNote = normalizeNote(note.pitch);
                 if (!uniquePitches.has(normalizedNote)) {
                    uniquePitches.add(normalizedNote);
                    expectedNotes.add(normalizedNote);
                    highlightKeyInstant(note.pitch, note.hand);
                 }
            });
        } else {
            osmd.cursor.next();
        }
    }

    if (!foundValidStep && currentLearningIndex >= parsedNotes.length) {
         showSuccessModal("¡Felicidades, has completado la pieza!");
         showConfetti(200);
         toggleMidiLearnMode();
    }
    
    updateMeasureSelectDisplay();
    updatePracticeProgress();
}




function autoCorrelate(buf, sampleRate) {
    let SIZE = buf.length;
    let rms = 0;

    for (let i = 0; i < SIZE; i++) {
        const val = buf[i];
        rms += val * val;
    }
    rms = Math.sqrt(rms / SIZE);

    if (rms < MIC_THRESHOLD) return -1; // Silencio

    let r1 = 0, r2 = SIZE - 1, thres = 0.2;
    for (let i = 0; i < SIZE / 2; i++) {
        if (Math.abs(buf[i]) < thres) { r1 = i; break; }
    }
    for (let i = 1; i < SIZE / 2; i++) {
        if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }
    }

    buf = buf.slice(r1, r2);
    SIZE = buf.length;

    let c = new Array(SIZE).fill(0);
    for (let i = 0; i < SIZE; i++) {
        for (let j = 0; j < SIZE - i; j++) {
            c[i] = c[i] + buf[j] * buf[j + i];
        }
    }

    let d = 0; while (c[d] > c[d + 1]) d++;
    let maxval = -1, maxpos = -1;
    for (let i = d; i < SIZE; i++) {
        if (c[i] > maxval) {
            maxval = c[i];
            maxpos = i;
        }
    }
    let T0 = maxpos;

    return sampleRate / T0;
}


function getNoteFromFrequency(frequency) {
    const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const pitchNum = 12 * (Math.log(frequency / 440) / Math.log(2)) + 69;
    const midi = Math.round(pitchNum);
    const noteName = noteNames[midi % 12];
    const octave = Math.floor(midi / 12) - 1;
    return noteName + octave;
}

// 3. Iniciar Escucha
async function startMicrophoneListener() {
    if (audioContext) return; 

    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        microphoneStream = stream;
        
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        source.connect(analyser);

        const bufferLength = analyser.fftSize;
        const buffer = new Float32Array(bufferLength);

        console.log("🎤 Micrófono activado");
        
        micInterval = setInterval(() => {
            if (!isMicActive) return;

            analyser.getFloatTimeDomainData(buffer);
            const frequency = autoCorrelate(buffer, audioContext.sampleRate);

            if (frequency !== -1) {
                const noteName = getNoteFromFrequency(frequency);
                
                // Debounce para evitar rebotes rápidos
                const now = Date.now();
                if (noteName !== lastMicNote || (now - lastMicTime > 300)) {
                    
                    // AQUÍ ESTÁ LA MAGIA: Enviamos la nota al sistema central
                    processInputNote(noteName); 
                    
                    lastMicNote = noteName;
                    lastMicTime = now;
                    
                    // Efecto visual de soltar la tecla
                    setTimeout(() => unhighlightMidiKey(noteName), 200);
                }
            }
        }, 50); // Muestreo cada 50ms

    } catch (err) {
        console.error("Error micrófono:", err);
        showModal("⚠️ No se pudo acceder al micrófono. Verifica permisos.");
        toggleMicMode(); // Apagar si falló
    }
}

// 4. Detener Escucha
function stopMicrophoneListener() {
    if (micInterval) clearInterval(micInterval);
    if (microphoneStream) {
        microphoneStream.getTracks().forEach(track => track.stop());
    }
    if (audioContext) {
        audioContext.close();
    }
    audioContext = null;
    analyser = null;
    micInterval = null;
}


function toggleMicMode() {
    isMicActive = !isMicActive;

    if (isMicActive) {
        // 1. Activar estado visual del botón
        micBtn.classList.add('active');
        
        // 2. Si estaba reproduciendo, detener
        stopPlayback();

        // 3. Configurar variables de "Modo Aprendizaje Libre"
        // Necesitamos isMidiLearnMode en true para que processInputNote funcione
        isMidiLearnMode = true; 
        currentInputSource = 'mic';
        
        // Desbloquear TOTALMENTE la pieza (Modo Libre)
        const totalMeasures = osmd.sheet.SourceMeasures.length;
        unlockedMeasureCount = totalMeasures; 
        
        // Quitar la niebla (Fog of War) completamente
        setRangeOpacity(0, totalMeasures, 1);
        
        // 4. Configurar el Cursor para modo espera (Azul)
        currentLearningIndex = 0;
        osmd.cursor.show();
        Object.assign(osmd.cursor.cursorOptions, {
            type: 5,
            alpha: 0.7,
            color: "rgba(52, 152, 219, 0.7)"
        });

        // 5. MANEJO DE LA INTERFAZ (UI)
        // Mostrar la barra secundaria
        secondaryTopBar2.classList.add('is-visible');
        
        // --- AQUÍ ESTÁ EL CAMBIO SOLICITADO ---
        if (restartChunkBtn) restartChunkBtn.style.display = 'none';
        
        // Asegurarse que el selector de compás sí se vea y se actualice
        populateMeasureSelector();
        measureSelect.value = 0;

        // 6. Preparar el sistema para escuchar la primera nota
        // Resetear filtros de mano a 'ambas' por defecto en modo micrófono
        handFilterMode = 'both';
        rightHandOnlyBtn.style.background = 'none';
        leftHandOnlyBtn.style.background = 'none';
        
        prepareFirstLearningStep();
        
        // 7. Iniciar el listener del micrófono
        startMicrophoneListener();
        updateMidiStatusLegend("Micrófono Activo");

    } else {
        // APAGAR MODO
        micBtn.classList.remove('active');
        stopMicrophoneListener();
        
        // Desactivar variables lógicas
        isMidiLearnMode = false;
        
        if (currentInputSource === 'mic') {
            currentInputSource = 'none';
            updateMidiStatusLegend(null);
        }

        // Ocultar la barra secundaria
        secondaryTopBar2.classList.remove('is-visible');

        // RESTAURAR LA UI (Importante para cuando vuelvas a usar MIDI normal)
        // Esperamos un poco a que termine la animación de cierre para restaurar el display
        setTimeout(() => {
            if (restartChunkBtn) restartChunkBtn.style.display = 'inline-flex';
        }, 300);
        
        // Restaurar cursor normal y controles
        osmd.cursor.reset();
        osmd.cursor.hide();
        playBtn.disabled = false;
        progressBar.disabled = false;
        
        // Restaurar opacidad visual si es necesario (opcional)
        setRangeOpacity(0, osmd.sheet.SourceMeasures.length, 1);
    }
}


function toggleMutePiano() {
    isPianoMuted = !isPianoMuted;

    if (isPianoMuted) {
        // --- ACTIVAR SILENCIO ---
        // En Tone.js, -Infinity decibelios es silencio absoluto
        if (sampler) sampler.volume.value = -Infinity;
        
        // Cambio visual: Icono de mute y color activo (rojo o gris según tu CSS)
        muteBtn.innerHTML = '<i class="ph ph-speaker-x"></i>';
        muteBtn.classList.add('active'); 
        // Opcional: ponerlo rojo para que sea evidente
        muteBtn.style.color = '#e74c3c'; 
        
    } else {
        // --- ACTIVAR SONIDO ---
        // 0 decibelios es el volumen estándar (sin ganancia ni pérdida)
        if (sampler) sampler.volume.value = 0;
        
        // Restaurar icono y color
        muteBtn.innerHTML = '<i class="ph ph-speaker-high"></i>';
        muteBtn.classList.remove('active');
        muteBtn.style.color = ''; // Volver al color original
    }
}


function showSuccessToast(message) {
    const toast = document.getElementById('success-toast');
    const msgSpan = document.getElementById('success-toast-message');
    
    if (toast && msgSpan) {
        msgSpan.textContent = message;
        toast.classList.add('show');
        setTimeout(() => {
            toast.classList.remove('show');
        }, 2500);
    }
}

function showWarningToast(message) {
    const toast = document.getElementById('success-toast');
    const msgSpan = document.getElementById('success-toast-message');
    const icon = toast.querySelector('i');
    
    if (toast && msgSpan) {
        // Guardar clase original del icono
        const originalIconClass = icon.className;
        
        // Cambiar estilos a warning
        toast.classList.add('warning');
        icon.className = 'ri-alert-line'; // Cambia el icono a alerta
        msgSpan.textContent = message;
        
        toast.classList.add('show');
        
        setTimeout(() => {
            toast.classList.remove('show');
            // Esperar a que termine la animación para restaurar estilos
            setTimeout(() => {
                toast.classList.remove('warning');
                icon.className = originalIconClass; // Restaurar icono original
            }, 500);
        }, 3000);
    }
}

function updateStaffFogOverlay() {
    // Borrar niebla anterior
    const oldFogs = document.querySelectorAll('.fog-overlay');
    oldFogs.forEach(el => el.remove());

    if (!osmd || !osmd.graphic) return;

    const containerRect = osmdContainer.getBoundingClientRect();

    for (let i = unlockedMeasureCount; i < osmd.graphic.measureList.length; i++) {
        const measures = osmd.graphic.measureList[i];
        if (!measures) continue;
        const bbox = measures[0].boundingBox; 
        const positionAndShape = measures[0].PositionAndShape;
        const absX = positionAndShape.AbsolutePosition.x * 10; // Escala aprox OSMD (suelen ser unidades * 10)
        const width = positionAndShape.Size.width * 10;
        const absY = positionAndShape.AbsolutePosition.y * 10;
    }
}


    function setStatus(text) { 
      statusDiv.textContent = text;
      statusDiv.style.display = text ? 'block' : 'none';
    }


function showSuccessModal(message) {
  successModalMessage.textContent = message;
  successModal.style.display = 'flex';
  setTimeout(() => {
    successModal.classList.add('is-visible');
  }, 10);
}


function hideSuccessModal() {
  successModal.classList.remove('is-visible');
  setTimeout(() => {
    successModal.style.display = 'none';
  }, 300); 
}


function showConfetti(count = 100) {
  const colors = ['#6f42c1', '#48aee9', '#28a745', '#ffc107', '#dc3545'];
  for (let i = 0; i < count; i++) {
    const confetti = document.createElement('div');
    confetti.className = 'confetti';
    confetti.style.left = `${Math.random() * 100}vw`;
    confetti.style.top = `${-20 - Math.random() * 10}vh`; 
    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
    confetti.style.animationDelay = `${Math.random() * 0.5}s`;
    confetti.style.animationDuration = `${3 + Math.random() * 2}s`;
    
    document.body.appendChild(confetti);
    setTimeout(() => confetti.remove(), 5000);
  }
}



let customLoopState = 0; // 0: Inactivo, 1: Seleccionando Final, 2: Activo
let isDraggingLoopThumb = false;

// A. Al presionar el botón de Loop
function toggleLoopMenu() {
    const btn = document.getElementById('btn-loop-active');
    const dropdown = document.getElementById('loop-dropdown');
    const track = document.getElementById('track-container');
    
    // Si ya hay loop activo, cancelamos
    if (customLoopState !== 0) {
        deactivateLoopMode();
        return;
    }

    // 1. Definir Inicio del Loop (Compás actual)
    const currentMsIndex = parseInt(document.getElementById('measure-select').value);
    const currentTime = measureStartTimes[currentMsIndex] || 0;
    const startPct = (currentTime / totalDuration) * 100;
    
    // Visual: Poner Pin de Inicio con número
    const pinStart = document.getElementById('loop-pin-start');
    pinStart.style.left = startPct + '%';
    pinStart.setAttribute('data-measure', currentMsIndex + 1);
    pinStart.classList.add('visible');
    
    // Estado: Esperando selección de final
    customLoopState = 1;
    btn.classList.add('btn-on');
    track.classList.add('selecting-loop');
    
    loopMeasureStart = currentMsIndex;

    // 2. Desplegar Dropdown con opciones "Hasta..."
    populateLoopDropdown(currentMsIndex);
    dropdown.classList.add('open');
}


function populateLoopDropdown(startIndex) {
    const container = document.getElementById('loop-end-list');
    const totalMeasures = osmd.sheet.SourceMeasures.length;
    const limit = isMidiLearnMode ? unlockedMeasureCount : totalMeasures;
    
    container.innerHTML = '<div style="padding:8px; font-size:11px; color:#888; border-bottom:1px solid #eee; font-weight:600;">REPETIR HASTA...</div>';

    for (let i = startIndex + 1; i < limit; i++) {
        const div = document.createElement('div');
        div.className = 'measure-option';
        div.innerHTML = `<span>Compás ${i + 1}</span>`;
        div.onclick = () => {
            finalizeLoop(i);
        };
        container.appendChild(div);
    }
}


function finalizeLoop(endIndex) {
    const dropdown = document.getElementById('loop-dropdown');
    const track = document.getElementById('track-container');
    const pinEnd = document.getElementById('loop-pin-end');
    const loopThumb = document.getElementById('loop-thumb-end');
    const loopRegion = document.getElementById('loop-region');

    // Cerrar UI de selección
    dropdown.classList.remove('open');
    track.classList.remove('selecting-loop');
    
    // Calcular posición del final
    const endTime = measureStartTimes[endIndex] || totalDuration;
    const endPct = (endTime / totalDuration) * 100;

    // Visual: Pin Final con número
    pinEnd.style.left = endPct + '%';
    pinEnd.setAttribute('data-measure', endIndex + 1);
    pinEnd.classList.add('visible');
    
    // Visual: Thumb arrastrable
    loopThumb.style.left = endPct + '%';
    loopThumb.setAttribute('data-measure', endIndex + 1);
    loopThumb.classList.add('visible');

    // Región azul
    const startPct = parseFloat(document.getElementById('loop-pin-start').style.left);
    loopRegion.style.left = startPct + '%';
    loopRegion.style.width = (endPct - startPct) + '%';
    loopRegion.classList.add('active');
    loopRegion.style.opacity = '0.3';

    // LÓGICA INTERNA
    loopMeasureEnd = endIndex;
    isLoopMode = true;
    
    customLoopState = 2;
    document.getElementById('cancel-loop-btn').style.display = 'flex';
    
    // MODIFICADO: Re-programar el transporte con loop
    if (Tone.Transport.state === 'started') {
        stopPlayback();
    }
    scheduleNotesOnTransport(); // Re-programar con loop
    
    // Saltar al inicio del loop
    if (isMidiLearnMode) {
        jumpToMeasureInLearnMode(loopMeasureStart);
    } else {
        playFromMeasure(loopMeasureStart);
    }
}

const originalDeactivateLoop = deactivateLoopMode;
deactivateLoopMode = function() {
    const wasLooping = isLoopMode;
    originalDeactivateLoop();
    
    customLoopState = 0;
    document.getElementById('loop-pin-start').classList.remove('visible');
    document.getElementById('loop-pin-end').classList.remove('visible');
    document.getElementById('loop-thumb-end').classList.remove('visible');
    document.getElementById('loop-region').classList.remove('active');
    document.getElementById('btn-loop-active').classList.remove('btn-on');
    document.getElementById('track-container').classList.remove('selecting-loop');
    document.getElementById('loop-dropdown').classList.remove('open');
    document.getElementById('cancel-loop-btn').style.display = 'none';
     if (wasLooping && Tone.Transport.state === 'started') {
        const wasPlaying = true;
        const currentTime = Tone.Transport.seconds;
        
        stopPlayback();
        scheduleNotesOnTransport(); // Re-programar sin loop
        
        if (wasPlaying) {
            Tone.Transport.start(Tone.now() + 0.1, currentTime);
            updatePlayButton(true);
            osmd.cursor.show();
            startProgressUpdate();
        }
    }
}

const loopThumbEnd = document.getElementById('loop-thumb-end');

loopThumbEnd.addEventListener('mousedown', (e) => {
    e.stopPropagation();
    isDraggingLoopThumb = true;
    loopThumbEnd.style.cursor = 'grabbing';
});

function setRangeOpacity(startMeasureIndex, endMeasureIndex, opacity) {
    if (!osmd || !osmd.graphic) return;

    // Recorremos los compases solicitados
    for (let i = startMeasureIndex; i < endMeasureIndex; i++) {
        // Validación de límites
        if (i >= osmd.graphic.measureList.length) break;

        const measures = osmd.graphic.measureList[i];
        if (!measures) continue;

        // Recorremos los pentagramas del compás
        for (let staffIndex = 0; staffIndex < measures.length; staffIndex++) {
            const staffEntry = measures[staffIndex].staffEntries;
            
            // Recorremos las entradas
            for (let j = 0; j < staffEntry.length; j++) {
                const voiceEntries = staffEntry[j].graphicalVoiceEntries;
                
                for (let v = 0; v < voiceEntries.length; v++) {
                    // AQUÍ ESTÁ LA CORRECCIÓN: Definimos 'notes' dentro del bucle correcto
                    const notes = voiceEntries[v].notes;
                    
                    for (let n = 0; n < notes.length; n++) {
                        const svgElement = notes[n].getSVGGElement();
                        if (opacity < 1) {
                                svgElement.style.filter = "blur(2px) grayscale(100%)";
                                svgElement.style.opacity = "0.3"; // Un poco más visible pero borroso
                            } else {
                                svgElement.style.filter = "none";
                                svgElement.style.opacity = "1";
                            }
                        svgElement.style.transition = "all 0.5s ease";
                    }
                }
            }
        }
    }
}

function initFogOfWar() {
    // 1. Asegurar que los primeros 4 compases sean visibles (Opacidad 1)
    setRangeOpacity(0, unlockedMeasureCount, 1);
    
    // 2. Ocultar (bajar opacidad) todo lo demás hasta el final de la pieza
    const totalMeasures = osmd.sheet.SourceMeasures.length;
    setRangeOpacity(unlockedMeasureCount, totalMeasures, 0.15); // 0.15 es muy tenue
}

function toggleMidiLearnMode() {
    // Si ya está activo, lo desactivamos (comportamiento toggle normal)
    if (isMidiLearnMode) {
        isMidiLearnMode = false;
        currentInputSource = 'none';
        
        midiLearnBtn.classList.remove('active');
        midiLearnBtn.style.background = '';
        midiLearnBtn.innerHTML = '<i class="ph-fill ph-play-circle"></i><span>Comenzar</span>';
        updateMidiStatusLegend(null); 

        const globalContainer = document.getElementById('global-progress-container');
        if (globalContainer) globalContainer.classList.remove('is-visible');

        const totalMeasures = osmd.sheet.SourceMeasures.length;
        setRangeOpacity(0, totalMeasures, 1);
        
        playBtn.disabled = false;
        progressBar.disabled = false;
        clearAllHighlights(); 
        osmd.cursor.reset();
        osmd.cursor.hide();
    
        Object.assign(osmd.cursor.cursorOptions, {
            type: 1,
            alpha: 0.8,
            color: "rgba(52, 152, 219, 0.8)"
        });
    
        secondaryTopBar2.classList.remove('is-visible');
        handFilterMode = 'both';
        updateStaffOpacity('both'); 
        rightHandOnlyBtn.style.background = 'none';
        leftHandOnlyBtn.style.background = 'none';
        
        populateMeasureSelector();
        return; // Salimos de la función
    }

    // --- INTENTO DE ACTIVACIÓN ---
    
    // 1. Verificación estricta de MIDI
    let hasMidi = false;
    if (midiAccess && midiAccess.inputs.size > 0) {
        hasMidi = true;
    }

    // 2. Si NO hay MIDI, mostramos alerta y cancelamos
    if (!hasMidi) {
        showWarningToast("⚠️ Conecta tu teclado MIDI para practicar");
        return; 
    }

    isMidiLearnMode = true;
    const globalContainer = document.getElementById('global-progress-container');
        if (globalContainer) globalContainer.classList.add('is-visible');
    stopPlayback(); 

    updateMidiStatusLegend("Teclado MIDI");
    currentInputSource = 'midi'; 

   if (isPieceCompleted) {
    unlockedMeasureCount = osmd.sheet.SourceMeasures.length;
} else {
    unlockedMeasureCount = Math.max(unlockedMeasureCount || 0, MEASURES_PER_CHUNK);
}
    
    populateMeasureSelector(); 

    setTimeout(() => {
         setRangeOpacity(0, unlockedMeasureCount, 1);      
        const total = osmd.sheet.SourceMeasures.length;
        setRangeOpacity(unlockedMeasureCount, total, 0.15);
    }, 100);

    midiLearnBtn.classList.add('active');
    midiLearnBtn.style.background = '#ea4335';
    midiLearnBtn.innerHTML = '<i class="ph-fill ph-pause-circle"></i><span>Detener</span>';
    midiLearnBtn.classList.remove('pulse-animation');
    
    playBtn.disabled = true;
    progressBar.disabled = true;
    currentLearningIndex = 0;
    osmd.cursor.show();

    Object.assign(osmd.cursor.cursorOptions, {
        type: 5,
        alpha: 0.7,
        color: "rgba(52, 152, 219, 0.7)"
    });
    
    handFilterMode = 'both';
    rightHandOnlyBtn.style.background = 'none';
    leftHandOnlyBtn.style.background = 'none';
    secondaryTopBar2.classList.add('is-visible');

    prepareFirstLearningStep(); 
    measureSelect.value = 0;

    if (tutorialOverlay.classList.contains('is-visible') && currentTutorialStep === 0) {
        nextTutorialStep(); 
    }
}


function prepareFirstLearningStep() {
  clearAllHighlights();
  expectedNotes.clear();

  if (currentLearningIndex >= parsedNotes.length) {
    showSuccessModal("¡Felicidades, has completado la pieza!");
    showConfetti(200);
    toggleMidiLearnMode();
    return;
  }

  let notesInStep = [];
  let foundValidStep = false;
  const TIME_TOLERANCE = 0.001;

  while (currentLearningIndex < parsedNotes.length && !foundValidStep) {
    const nextNoteTime = parsedNotes[currentLearningIndex].startSec;
    notesInStep.length = 0;
    
    while (currentLearningIndex < parsedNotes.length && 
           Math.abs(parsedNotes[currentLearningIndex].startSec - nextNoteTime) < TIME_TOLERANCE) {
      notesInStep.push(parsedNotes[currentLearningIndex]);
      currentLearningIndex++;
    }

    const filteredNotes = notesInStep.filter(note => 
      !note.isRest &&
      !note.isTiedContinuation &&
      (handFilterMode === 'both' || 
      (handFilterMode === 'right' && note.hand === 'treble') ||
      (handFilterMode === 'left' && note.hand === 'bass'))
    );

    if (filteredNotes.length > 0) {
      foundValidStep = true;
      
      // OPTIMIZACIÓN: Usar Set directamente
      const uniquePitches = new Set();
      
      for (const note of filteredNotes) {
        const normalizedNote = normalizeNote(note.pitch);
        
        if (!uniquePitches.has(normalizedNote)) {
          uniquePitches.add(normalizedNote);
          expectedNotes.add(normalizedNote);
          highlightKeyInstant(note.pitch, note.hand);
        }
      }
    }else {
      osmd.cursor.next(); 
    }
  }

  if (!foundValidStep && currentLearningIndex >= parsedNotes.length) {
    alert("¡No hay notas para la mano seleccionada en esta pieza!");
    toggleMidiLearnMode();
  }
  updatePracticeProgress();
}


function updateStaffOpacity(mode) {
    if (!osmd || !osmd.graphic) {
        console.warn("OSMD no está listo.");
        return;
    }
    
    const svgContainer = osmdContainer.querySelector('svg');
    if (!svgContainer) return;
    const allGroups = Array.from(svgContainer.querySelectorAll('g'));
    
    const staffLineContainers = allGroups.filter(group => {
        const subGroups = group.querySelectorAll('g');
        let staffCount = 0;
        subGroups.forEach(sub => {
            const paths = sub.querySelectorAll(':scope > path');
            if (paths.length >= 5) staffCount++;
        });
        return staffCount >= 1;
    });
    
    staffLineContainers.forEach((container, index) => {
        const isTreble = index % 2 === 0;
        
        switch (mode) {
            case 'right':
                container.style.opacity = isTreble ? '1' : '0.2';
                break;
            case 'left':
                container.style.opacity = isTreble ? '0.2' : '1';
                break;
            case 'both':
            default:
                container.style.opacity = '1';
                break;
        }
        container.style.transition = 'opacity 0.3s ease';
    });
}

function toggleRightHandOnly() {
  const wasPlaying = Tone.Transport.state === 'started';
  const currentTime = wasPlaying ? Tone.Transport.seconds : 0;
  
  if (handFilterMode === 'right') {
    // Si ya está activo, desactivar
    handFilterMode = 'both';
    rightHandOnlyBtn.style.background = 'none';
    leftHandOnlyBtn.style.background = 'none';
    rightHandOnlyBtn.style.color = '#1a1a1a';
    leftHandOnlyBtn.style.color = '#1a1a1a';
  } else {
    // Activar solo mano derecha
    handFilterMode = 'right';
    rightHandOnlyBtn.style.background = '#e0e0e0';
    rightHandOnlyBtn.style.color = '#3498db';
    leftHandOnlyBtn.style.background = 'none';
    leftHandOnlyBtn.style.color = '#1a1a1a';

    if (tutorialOverlay.classList.contains('is-visible') && currentTutorialStep === 2) {
        nextTutorialStep();
    }
  }
  
  updateStaffOpacity(handFilterMode);
  
  // NUEVO: Re-programar el audio con el nuevo filtro
  if (!isMidiLearnMode) {
    scheduleNotesOnTransport();
    
    // Si estaba reproduciendo, continuar desde donde estaba
    if (wasPlaying) {
      Tone.Transport.start(Tone.now(), currentTime);
      updatePlayButton(true);
      osmd.cursor.show();
      startProgressUpdate();
    }
  } else {
    skipToNextRelevantNote();
  }
}

function toggleLeftHandOnly() {
  const wasPlaying = Tone.Transport.state === 'started';
  const currentTime = wasPlaying ? Tone.Transport.seconds : 0;
  
  if (handFilterMode === 'left') {
    // Si ya está activo, desactivar
    handFilterMode = 'both';
    rightHandOnlyBtn.style.background = 'none';
    leftHandOnlyBtn.style.background = 'none';
    rightHandOnlyBtn.style.color = '#1a1a1a';
    leftHandOnlyBtn.style.color = '#1a1a1a';
  } else {
    // Activar solo mano izquierda
    handFilterMode = 'left';
    leftHandOnlyBtn.style.background = '#e0e0e0';
    leftHandOnlyBtn.style.color = '#3498db';
    rightHandOnlyBtn.style.background = 'none';
    rightHandOnlyBtn.style.color = '#1a1a1a';
  }

  updateStaffOpacity(handFilterMode);
  
  // NUEVO: Re-programar el audio con el nuevo filtro
  if (!isMidiLearnMode) {
    scheduleNotesOnTransport();
    
    // Si estaba reproduciendo, continuar desde donde estaba
    if (wasPlaying) {
      Tone.Transport.start(Tone.now(), currentTime);
      updatePlayButton(true);
      osmd.cursor.show();
      startProgressUpdate();
    }
  } else {
    skipToNextRelevantNote();
  }
  
  console.log(`Modo de mano: ${handFilterMode}`);
}


function skipToNextRelevantNote() {
  if (!isMidiLearnMode) return;
  
  clearAllHighlights();
  expectedNotes.clear();
  
  const TIME_TOLERANCE = 0.001;
  let foundRelevantNote = false;
  
  // Retroceder al inicio del paso actual para recalcular
  let tempIndex = currentLearningIndex - 1;
  const currentTime = parsedNotes[tempIndex]?.startSec;
  
  // Retroceder hasta el inicio del acorde/paso actual
  while (tempIndex > 0 && Math.abs(parsedNotes[tempIndex - 1]?.startSec - currentTime) < TIME_TOLERANCE) {
    tempIndex--;
  }
  
  // Restaurar el índice al inicio del paso actual
  currentLearningIndex = tempIndex;
  
  // Buscar la siguiente nota relevante para la mano seleccionada
  while (currentLearningIndex < parsedNotes.length && !foundRelevantNote) {
    const nextNoteTime = parsedNotes[currentLearningIndex].startSec;
    const notesInStep = [];
    
    // Recopilar todas las notas en este momento
    const stepStartIndex = currentLearningIndex;
    while (currentLearningIndex < parsedNotes.length && 
           Math.abs(parsedNotes[currentLearningIndex].startSec - nextNoteTime) < TIME_TOLERANCE) {
      notesInStep.push(parsedNotes[currentLearningIndex]);
      currentLearningIndex++;
    }
    
    // Filtrar por mano seleccionada
    const filteredNotes = notesInStep.filter(note => 
      !note.isRest &&
      !note.isTiedContinuation &&
      (handFilterMode === 'both' || 
      (handFilterMode === 'right' && note.hand === 'treble') ||
      (handFilterMode === 'left' && note.hand === 'bass'))
    );
    
    if (filteredNotes.length > 0) {
      // Encontramos notas relevantes, preparar para tocarlas
      foundRelevantNote = true;
      
      // Avanzar el cursor a la posición correcta
      osmd.cursor.reset();
      let cursorTime = -1;
      for (let i = 0; i < stepStartIndex; i++) {
        if (parsedNotes[i].startSec !== cursorTime) {
          osmd.cursor.next();
          cursorTime = parsedNotes[i].startSec;
        }
      }
      
      // Highlight de las notas esperadas
      const uniquePitches = new Set();
      filteredNotes.forEach(note => {
        const normalizedNote = normalizeNote(note.pitch);
        if (!uniquePitches.has(normalizedNote)) {
          uniquePitches.add(normalizedNote);
          expectedNotes.add(normalizedNote);
          highlightKey(note.pitch, note.durSec, note.hand, true);
        }
      });
      
      console.log(`Saltando a notas relevantes (${handFilterMode}):`, Array.from(expectedNotes));
    } else {
      // No hay notas relevantes en este paso, avanzar cursor automáticamente
      osmd.cursor.next();
    }
  }
  
  if (!foundRelevantNote) {
    // No se encontraron más notas para la mano seleccionada
    showSuccessModal(`¡Has completado todas las notas de la mano ${handFilterMode === 'right' ? 'derecha' : 'izquierda'}!`);
    showConfetti(100);
  }
}

function reloadCurrentStepWithHandFilter() {
  if (!isMidiLearnMode) return;
  
  const TIME_TOLERANCE = 0.001;
  
  const currentStepNotes = [];
  const targetTime = parsedNotes[currentLearningIndex - 1]?.startSec;
  
  let tempIndex = currentLearningIndex - 1;
  while (tempIndex >= 0 && Math.abs(parsedNotes[tempIndex]?.startSec - targetTime) < TIME_TOLERANCE) {
    currentStepNotes.unshift(parsedNotes[tempIndex]);
    tempIndex--;
  }
  
  clearAllHighlights();
  expectedNotes.clear();
  
  const filteredNotes = currentStepNotes.filter(note => 
    handFilterMode === 'both' || 
    (handFilterMode === 'right' && note.hand === 'treble') ||
    (handFilterMode === 'left' && note.hand === 'bass')
  );
  
  if (filteredNotes.length > 0) {
    const uniquePitches = new Set();
    
    filteredNotes.forEach(note => {
      const normalizedNote = normalizeNote(note.pitch);
      
      if (!uniquePitches.has(normalizedNote)) {
        uniquePitches.add(normalizedNote);
        expectedNotes.add(normalizedNote);
        highlightKey(note.pitch, note.durSec, note.hand, true);
      }
    });
    
    console.log(`Notas esperadas (${handFilterMode}):`, Array.from(expectedNotes));
  } else {
    console.log(`Paso actual no tiene notas de ${handFilterMode}, avanzando...`);
    advanceLearningStep();
  }
}




function initMidiInput() {
    if (navigator.requestMIDIAccess) {
        navigator.requestMIDIAccess()
            .then(onMIDISuccess, onMIDIFailure);
    } 
}



function onMIDISuccess(access) {
    midiAccess = access;
    for (var input of midiAccess.inputs.values()) {
        input.onmidimessage = onMIDIMessage;
    }
    checkMidiConnectionStatus();
    midiAccess.onstatechange = (event) => {
        const port = event.port;
        if (port.type !== 'input') return;
        if (port.state === 'connected') {
             port.onmidimessage = onMIDIMessage;
        }
        checkMidiConnectionStatus();
    };
}

// Nueva función auxiliar para manejar la lógica de conexión
function checkMidiConnectionStatus() {
    // A. Control del Botón Tutorial
    const tutorialBtn = document.getElementById('start-tutorial-btn');
    
    // Si hay al menos 1 entrada conectada Y activa
    if (midiAccess.inputs.size > 0) {
        if (tutorialBtn) tutorialBtn.style.display = 'inline-block'; // O 'block' o 'flex' segun tu diseño
        
        // Actualizar leyenda (opcional, toma el primero)
        const firstInput = midiAccess.inputs.values().next().value;
        if (firstInput) updateMidiStatusLegend(firstInput.name);

    } else {
        if (tutorialBtn) tutorialBtn.style.display = 'none';
        updateMidiStatusLegend(null);
        if (isMidiLearnMode) {
            console.log("MIDI desconectado: Saliendo de modo aprendizaje...");
            showWarningToast("⚠️ MIDI desconectado. Saliendo del modo aprendizaje.");
            toggleMidiLearnMode(); // Esto apaga el modo
        }
    }
}


function onMIDIFailure() {
    showModal("⚠️ No se pudo acceder a tus dispositivos MIDI. Asegúrate de dar permiso en el navegador.");
    isMidiLearnMode = false;
    midiLearnBtn.style.background = 'none';
    playBtn.disabled = false;
}

function onMIDIMessage(event) {
    const command = event.data[0] & 0xf0; 
    const note = event.data[1];
    const velocity = event.data.length > 2 ? event.data[2] : 0;
    const pitchName = midiNoteToPitchName(note);
    if (command === 176 && note === 64) {
        if (velocity >= 64) {
            isSustainPedalDown = true;
        } else {
            isSustainPedalDown = false;
            releaseSustainedNotes(); 
        }
        return; 
    }
    if (command === 144 && velocity > 0) {
        if (isMidiLearnMode && currentInputSource === 'midi' && sampler && sampler.loaded) {
            sampler.triggerAttack(pitchName, undefined, velocity / 127); 
        }
        if (sustainedNotes.has(pitchName)) {
            sustainedNotes.delete(pitchName);
        }

        requestAnimationFrame(() => {
            processInputNote(pitchName);
        });
    } else if (command === 128 || (command === 144 && velocity === 0)) {
        if (isSustainPedalDown) {
            if (isMidiLearnMode && currentInputSource === 'midi') {
                sustainedNotes.add(pitchName);
            }
        } else {
            if (isMidiLearnMode && currentInputSource === 'midi' && sampler && sampler.loaded) {
                sampler.triggerRelease(pitchName);
            }
        }
        requestAnimationFrame(() => {
            unhighlightMidiKey(pitchName);
        });
    }
}



function releaseSustainedNotes() {
    if (!sampler || !sampler.loaded) return;
    const notesToRelease = Array.from(sustainedNotes);
    
    if (notesToRelease.length > 0) {
        sampler.triggerRelease(notesToRelease);
        sustainedNotes.clear();
    }
}





function processInputNote(noteName) {
    if (!isMidiLearnMode || isRestarting) return;
    highlightMidiKey(noteName);

    if (expectedNotes.size > 0) {
        const normalizedNote = normalizeNote(noteName);
        if (expectedNotes.has(normalizedNote)) {
            createNoteFlashPiano(noteName, 'treble'); 
            if (tutorialOverlay.classList.contains('is-visible')) {
                const currentStepData = tutorialSteps[currentTutorialStep];
                if (currentStepData && currentStepData.targetAction === 'play-correct-note') {
                    nextTutorialStep();
                }
            }
            
            expectedNotes.delete(normalizedNote);
            if (expectedNotes.size === 0) {
                if (currentLearningIndex > 0) {
                    advanceLearningStep(); 
                } else {
                    prepareFirstLearningStep(); 
                }
            }
        } else {

          const currentMeasureIdx = getCurrentMeasureIndex();
            const challengeStartMeasure = Math.max(0, unlockedMeasureCount - MEASURES_PER_CHUNK);
            if (!isPieceCompleted && currentMeasureIdx >= challengeStartMeasure) {
                showWarningToast("⚠️ Error en sección de prueba. Reiniciando...");
                    restartCurrentChunk();
            }
        }
    }
}


function getCurrentMeasureIndex() {
    if (!parsedNotes[currentLearningIndex]) return 0;
    const currentNoteTime = parsedNotes[currentLearningIndex].startSec;

    for (let i = measureStartTimes.length - 1; i >= 0; i--) {
        if (currentNoteTime >= measureStartTimes[i] - 0.001) {
            return i;
        }
    }
    return 0;
}

/*
function onMIDIMessage(event) {
    const command = event.data[0];
    const note = event.data[1];
    const velocity = event.data.length > 2 ? event.data[2] : 0;

    if (command === 144 && velocity > 0) {
        // NOTE ON - Colorear la tecla
        const pitchName = midiNoteToPitchName(note);
        highlightMidiKey(pitchName);
        
        // Lógica existente del modo aprendizaje
        if (isMidiLearnMode && expectedNotes.size > 0) {
            // NORMALIZAR la nota MIDI para comparación
            const normalizedMidiNote = normalizeNote(pitchName);
            
            // Verificar si la nota normalizada está en expectedNotes
            if (expectedNotes.has(normalizedMidiNote)) {
                sampler.triggerAttackRelease(pitchName, '8n');
                expectedNotes.delete(normalizedMidiNote);
                createNoteFlashPiano(pitchName, 'treble');
                console.log(`¡Correcto! Nota ${pitchName} (normalizada: ${normalizedMidiNote}). Faltan ${expectedNotes.size}.`);
                
                if (expectedNotes.size === 0) {

                        if (currentLearningIndex > 0) {
                            advanceLearningStep();
                        } else {
                            prepareFirstLearningStep();
                        }
                }
            } else {
                console.log(`Nota ${pitchName} (normalizada: ${normalizedMidiNote}) no está en expectedNotes:`, Array.from(expectedNotes));
            }
        }
    } else if (command === 128 || (command === 144 && velocity === 0)) {
        // NOTE OFF - Quitar el color
        const pitchName = midiNoteToPitchName(note);
        unhighlightMidiKey(pitchName);
    }
}
*/

// Añade estas nuevas funciones para el coloreado MIDI
function highlightMidiKey(noteName) {
    const noteId = noteName.replace('b', '#');
    const el = document.getElementById(noteId);
    if (el) {
        el.classList.add('midi-active');
    }
}

function unhighlightMidiKey(noteName) {
    const noteId = noteName.replace('b', '#');
    const el = document.getElementById(noteId);
    if (el) {
        el.classList.remove('midi-active');
    }
}









function midiNoteToPitchName(midiNote) {
    const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const octave = Math.floor(midiNote / 12) - 1;
    const noteName = noteNames[midiNote % 12];
    return noteName + octave;
}


function showModal(message, duration = 0) {
    modalMessage.innerHTML = message; 
    //modalMessage.textContent = message;
    midiModal.style.display = 'flex';
    setTimeout(() => {
        midiModal.classList.add('is-visible');
    }, 10);

    if (duration > 0) {
        setTimeout(() => {
            hideModal();
        }, duration);
    }
}


function hideModal() {
    midiModal.classList.remove('is-visible');
    // Esperamos a que la transición termine para ocultarlo con display:none
    setTimeout(() => {
        midiModal.style.display = 'none';
    }, 300);
}


/* ==========================================================================
   ADAPTADOR JS (BRIDGE) - Versión Actualizada
   ========================================================================== */

// 1. Modales
let activeModalId = null;
function toggleModal(name) {
  const modalId = `modal-${name}`;
  const modalEl = document.getElementById(modalId);
  const btnEl = document.getElementById(name === 'metronome' ? 'metronome-modal-btn' : 'tools-toggle-btn');
  
  if (activeModalId === modalId) { closeAllModals(); return; }
  closeAllModals();
  
  modalEl.classList.add('is-open');
  if(btnEl) btnEl.classList.add('active');
  activeModalId = modalId;
}

function closeAllModals() {
  document.querySelectorAll('.modal-popup').forEach(el => el.classList.remove('is-open'));
  document.querySelectorAll('.tool-btn').forEach(el => el.classList.remove('active'));
  activeModalId = null;
}

document.addEventListener('click', (e) => {
  if (!e.target.closest('.controls-right') && !e.target.closest('.modal-popup')) {
    closeAllModals();
  }
});

// 2. Puente para el Selector de Compases (CRUCIAL)
// Sobrescribimos la función original para que llene AMBOS selectores
const originalPopulate = populateMeasureSelector;

populateMeasureSelector = function() {
    // 1. Ejecutar lógica original (llena el <select> oculto)
    if(originalPopulate) originalPopulate();
    
    // 2. Llenar nuestro dropdown visual
    const container = document.getElementById('measure-list-custom');
    const nativeSelect = document.getElementById('measure-select');
    
    if (!container || !nativeSelect) return;
    container.innerHTML = '';
    
    Array.from(nativeSelect.options).forEach((opt, index) => {
        const div = document.createElement('div');
        div.className = 'measure-option';
        // Formato visual más limpio: "1", "2", etc.
        const label = opt.text.replace('Compás ', '');
        div.innerHTML = `<span>Compás ${label}</span>`;
        
        div.onclick = (e) => {
            e.stopPropagation(); // Evitar cerrar inmediatamente
            
            // ACTUAR COMO SI FUERA EL SELECT NATIVO
            nativeSelect.value = opt.value;
            nativeSelect.dispatchEvent(new Event('change')); // Disparar lógica de salto
            
            // Actualizar display visual
            document.getElementById('custom-measure-display').textContent = label;
            toggleMeasureDropdown(); // Cerrar ahora
        };
        container.appendChild(div);
    });
    
    // Actualizar texto inicial
    updateCustomMeasureDisplay();
};

let measureDropdownOpen = false;
function toggleMeasureDropdown() {
    const dropdown = document.getElementById('measure-dropdown');
    measureDropdownOpen = !measureDropdownOpen;
    
    if (measureDropdownOpen) {
        dropdown.classList.add('open');
        // Asegurar que se muestre el valor actual
        updateCustomMeasureDisplay(); 
    } else {
        dropdown.classList.remove('open');
    }
}

function updateCustomMeasureDisplay() {
    const nativeSelect = document.getElementById('measure-select');
    const display = document.getElementById('custom-measure-display');
    if(nativeSelect && display) {
        const text = nativeSelect.options[nativeSelect.selectedIndex]?.text || "-";
        display.textContent = text.replace('Compás ', '');
        
        // Marcar la opción seleccionada en la lista (azul)
        const opts = document.querySelectorAll('.measure-option');
        opts.forEach((el, idx) => {
             if(idx === nativeSelect.selectedIndex) el.classList.add('current');
             else el.classList.remove('current');
        });
    }
}

// Escuchar cambios automáticos (ej. avance de aprendizaje)
const nativeSelect = document.getElementById('measure-select');
if(nativeSelect) {
    // Cuando el JS original cambia el select oculto, actualizamos el visual
    nativeSelect.addEventListener('change', updateCustomMeasureDisplay);
    
    // Interceptar la función de actualización del JS original
    const oldUpdateDisplay = updateMeasureSelectDisplay;
    updateMeasureSelectDisplay = function() {
        oldUpdateDisplay();
        updateCustomMeasureDisplay();
    }
}

// 3. Slider de Progreso Visual
const trackContainer = document.getElementById('track-container');
const originalProgressBar = document.getElementById('progress-bar');
let isDraggingTrack = false;

setInterval(() => {
    // Solo actualizamos si el usuario NO está arrastrando y si hay reproducción
    if (!isDraggingTrack && Tone.Transport.state === 'started') {
        const val = originalProgressBar.value;
        // Actualizar visuales
        document.getElementById('track-fill').style.width = val + '%';
        document.getElementById('track-knob').style.left = val + '%';
        
        // Sincronizar texto de compás (función que creamos antes)
        updateCustomSliderUI(val); 
    }
}, 100);

// Eventos de Ratón / Toque
trackContainer.addEventListener('mousedown', (e) => { isDraggingTrack = true; handleTrackMove(e); });
document.addEventListener('mousemove', (e) => { if(isDraggingTrack) handleTrackMove(e); });

document.addEventListener('mouseup', (e) => {
    if (!isDraggingLoopThumb) return;
    
    isDraggingLoopThumb = false;
    loopThumbEnd.style.cursor = 'grab';
    
    // Calcular compás final según posición
    const finalPct = parseFloat(loopThumbEnd.style.left);
    const finalTime = (finalPct / 100) * totalDuration;
    let finalMeasure = 0;
    
    for (let i = measureStartTimes.length - 1; i >= 0; i--) {
        if (measureStartTimes[i] <= finalTime) {
            finalMeasure = i;
            break;
        }
    }
    
    // Actualizar variables internas
    loopMeasureEnd = finalMeasure;
    
    // Ajustar a la posición exacta del compás (snap)
    const exactTime = measureStartTimes[finalMeasure];
    const exactPct = (exactTime / totalDuration) * 100;
    
    loopThumbEnd.style.left = exactPct + '%';
    document.getElementById('loop-pin-end').style.left = exactPct + '%';
    
    const startPct = parseFloat(document.getElementById('loop-pin-start').style.left);
    document.getElementById('loop-region').style.width = (exactPct - startPct) + '%';
    
    console.log(`Loop actualizado: Compás ${loopMeasureStart + 1} a ${loopMeasureEnd + 1}`);
});

document.addEventListener('mouseup', () => { 
    if(isDraggingTrack) {
        isDraggingTrack = false;
        
        // 1. Calculamos dónde cayó el slider (0-100)
        const currentPct = parseFloat(originalProgressBar.value);
        
        // 2. Calculamos a qué compás corresponde ese porcentaje
        // (Necesario para el Modo Aprendizaje)
        let targetMeasureIndex = 0;
        if (measureStartTimes.length > 0 && totalDuration > 0) {
            const seekTime = (currentPct / 100) * totalDuration;
            for (let i = 0; i < measureStartTimes.length; i++) {
                if (measureStartTimes[i] <= seekTime) {
                    targetMeasureIndex = i;
                } else {
                    break;
                }
            }
        }

        // 3. Lógica de Decisión según el Modo
        if (isLoopMode) {
             // Si hay loop, forzamos el inicio del loop para evitar confusiones
             jumpToMeasureInLearnMode(loopMeasureStart);
        }
        else if (isMidiLearnMode) {
            // --- MODO APRENDIZAJE ---
            // Solo posicionar, preparar notas esperadas y detener audio.
            jumpToMeasureInLearnMode(targetMeasureIndex);
            // Actualizar selector visual para que coincida
            const nativeSelect = document.getElementById('measure-select');
            if(nativeSelect) {
                nativeSelect.value = targetMeasureIndex;
                updateCustomMeasureDisplay();
            }
        } 
        else {
            // --- MODO NORMAL ---
            if (Tone.Transport.state === 'started') {
                // Si ya estaba sonando, saltar y seguir sonando
                playFromMeasure(targetMeasureIndex);
            } else {
                // Si estaba en pausa, SOLO mover cursor y cabezal de audio (Seek)
                // Sin Play.
                const seekTime = measureStartTimes[targetMeasureIndex] || 0;
                Tone.Transport.seconds = seekTime / playbackRate;
                
                // Actualizar cursor OSMD visualmente sin play
                osmd.cursor.reset();
                let cursorTime = -1;
                parsedNotes.forEach(note => {
                     if (note.startSec < seekTime && note.startSec !== cursorTime) {
                        osmd.cursor.next();
                        cursorTime = note.startSec;
                     }
                });
                osmd.cursor.show();
                
                // Sincronizar UI
                const nativeSelect = document.getElementById('measure-select');
                if(nativeSelect) {
                    nativeSelect.value = targetMeasureIndex;
                    updateCustomMeasureDisplay();
                }
            }
        }
    }
});

function handleTrackMove(e) {
    const rect = trackContainer.getBoundingClientRect();
    let pct = ((e.clientX - rect.left) / rect.width) * 100;
    if (pct < 0) pct = 0; if (pct > 100) pct = 100;
    
    // Actualizar visualmente mientras se arrastra
    updateCustomSliderUI(pct); // Usa la función que actualiza texto y barra
    
    // Actualizar valor oculto
    originalProgressBar.value = pct;
}


document.addEventListener('mousemove', (e) => {
    if (!isDraggingLoopThumb) return;
    
    const rect = trackContainer.getBoundingClientRect();
    let newPct = ((e.clientX - rect.left) / rect.width) * 100;
    
    const startPct = parseFloat(document.getElementById('loop-pin-start').style.left);
    if (newPct <= startPct) return;
    if (newPct > 100) newPct = 100;

    loopThumbEnd.style.left = newPct + '%';
    document.getElementById('loop-pin-end').style.left = newPct + '%';
    
    // Actualizar región
    const loopRegion = document.getElementById('loop-region');
    loopRegion.style.width = (newPct - startPct) + '%';
    
    // Calcular a qué compás corresponde
    const newTime = (newPct / 100) * totalDuration;
    let newEndMeasure = 0;
    for (let i = measureStartTimes.length - 1; i >= 0; i--) {
        if (measureStartTimes[i] <= newTime) {
            newEndMeasure = i;
            break;
        }
    }
    
    // Actualizar número en el thumb
    loopThumbEnd.setAttribute('data-measure', newEndMeasure + 1);
    document.getElementById('loop-pin-end').setAttribute('data-measure', newEndMeasure + 1);
});

// Listener de Clic/Soltar en el Timeline
document.addEventListener('mouseup', (e) => { 
    // CASO A: Estamos definiendo el final del loop
    if (customLoopState === 1 && !e.target.closest('.loop-thumb')) {
        const rect = trackContainer.getBoundingClientRect();
        let clickPct = ((e.clientX - rect.left) / rect.width) * 100;
        
        // Convertir a compás
        const clickTime = (clickPct / 100) * totalDuration;
        let targetMeasure = 0;
        for (let i = measureStartTimes.length - 1; i >= 0; i--) {
            if (measureStartTimes[i] <= clickTime) {
                targetMeasure = i;
                break;
            }
        }
        
        // Validar que sea posterior al inicio
        if (targetMeasure > loopMeasureStart) {
            finalizeLoop(targetMeasure);
        } else {
            deactivateLoopMode();
        }
        return;
    }

    // CASO B: Arrastre normal de reproducción (Tu código existente)
    if(isDraggingTrack) {
        isDraggingTrack = false;
        // ... (Tu lógica existente de mouseup para saltar compás) ...
        const currentPct = parseFloat(originalProgressBar.value);
        let targetMeasureIndex = 0;
        if (measureStartTimes.length > 0 && totalDuration > 0) {
            const seekTime = (currentPct / 100) * totalDuration;
            for (let i = 0; i < measureStartTimes.length; i++) {
                if (measureStartTimes[i] <= seekTime) targetMeasureIndex = i;
                else break;
            }
        }

        if (isLoopMode) {
             jumpToMeasureInLearnMode(loopMeasureStart);
        }
        else if (isMidiLearnMode) {
            jumpToMeasureInLearnMode(targetMeasureIndex);
            const nativeSelect = document.getElementById('measure-select');
            if(nativeSelect) {
                nativeSelect.value = targetMeasureIndex;
                updateCustomMeasureDisplay();
            }
        } 
        else {
            if (Tone.Transport.state === 'started') {
                playFromMeasure(targetMeasureIndex);
            } else {
                const seekTime = measureStartTimes[targetMeasureIndex] || 0;
                Tone.Transport.seconds = seekTime / playbackRate;
                osmd.cursor.reset();
                let cursorTime = -1;
                parsedNotes.forEach(note => {
                     if (note.startSec < seekTime && note.startSec !== cursorTime) {
                        osmd.cursor.next();
                        cursorTime = note.startSec;
                     }
                });
                osmd.cursor.show();
                const nativeSelect = document.getElementById('measure-select');
                if(nativeSelect) {
                    nativeSelect.value = targetMeasureIndex;
                    updateCustomMeasureDisplay();
                }
            }
        }
    }
});

// Cerrar el dropdown de loop si hacen clic fuera
document.addEventListener('click', (e) => {
    if (!e.target.closest('.loop-tools') && !e.target.closest('#track-container') && customLoopState === 1) {
        // Si hacen clic fuera mientras seleccionan, cancelar selección
        deactivateLoopMode();
    }
});



// Inicialización
setTimeout(populateMeasureSelector, 1500); // Esperar un poco a que OSMD cargue
  </script>
</body>
</html>         
