<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Reproductor MusicXML</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #fafafa;
      color: #1a1a1a;
      padding-bottom: 140px;
    }
    
    /* Top Bar - Minimalista */
    #top-bar {
      background: #fff;
      border-bottom: 1px solid #e0e0e0;
      padding: 10px 20px;
      position: sticky;
      top: 0;
      z-index: 1000;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    }
    
    #title-section {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    #song-title {
      font-size: 14px;
      font-weight: 600;
      color: #1a1a1a;
    }
    
    #song-composer {
      font-size: 12px;
      color: #999;
    }
    
    .controls {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    
    .btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 6px;
      border-radius: 4px;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .btn:hover:not(:disabled) {
      background: #f5f5f5;
    }
    
    .btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    
    .btn svg {
      width: 20px;
      height: 20px;
      fill: #1a1a1a;
    }
    
    /* Progress Bar */
    #progress-bar-container {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: #e0e0e0;
      cursor: pointer;
    }
    
    #progress-bar {
      height: 100%;
      background: #3498db;
      width: 0%;
      transition: width 0.1s linear;
    }
    
    /* Speed Controls - MEJORADO */

    
 
    
   #osmd-container {
      max-width: 1200px;
      margin: 32px auto;
      padding: 20px;
      min-height: 300px;
      cursor: pointer;
      border: 1px solid #e0e0e0;
      background-color: white;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      overflow-x: auto;
      /* MÁRGENES HORIZONTALES MEJORADOS */
      margin-left: 16px;
      margin-right: 16px;
    }
    
    /* Controles de zoom para móviles */
    #zoom-controls {
      display: none;
      justify-content: center;
      gap: 10px;
      margin: 10px auto;
      padding: 0 20px;
      max-width: 1200px;
    }
    
    .zoom-btn {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 6px 12px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .zoom-btn:hover {
      background: #f5f5f5;
    }
    
    .zoom-display {
      font-size: 14px;
      padding: 6px 12px;
      color: #666;
    }
    
    /* Piano - 88 Keys Minimalista */
    #piano-container {
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100%;
      background: #fff;
      padding: 12px 0;
      overflow-x: auto;
      overflow-y: hidden;
      box-shadow: 0 -1px 3px rgba(0,0,0,0.08);
      border-top: 1px solid #e0e0e0;
      transition: transform 0.3s ease;
    }
    
    #piano-container.hidden {
      transform: translateY(100%);
    }
    
    #piano-keys {
      display: flex;
      justify-content: center;
      min-width: 100%;
      padding: 0 10px;
    }
    
    .key {
      border: 1px solid #ddd;
      position: relative;
      transition: all 0.05s;
    }
    
    .key.white {
      width: 16px;
      height: 90px;
      background: #fff;
      border-right: 1px solid #e0e0e0;
    }
    
    .key.black {
      width: 10px;
      height: 58px;
      background: #1a1a1a;
      margin-left: -5px;
      margin-right: -5px;
      z-index: 2;
    }
    
    .key.active {
      background: #3498db !important;
      box-shadow: 0 0 8px rgba(52, 152, 219, 0.6) !important;
    }
    
    #status {
      text-align: center;
      padding: 40px 20px;
      color: #999;
      font-size: 13px;
    }
    
    /* Mobile adjustments - ESCALADO PARA MÓVILES */
    @media (max-width: 768px) {
      #zoom-controls {
        display: flex;
      }
      
      #osmd-container {
        margin: 16px 12px; /* Márgenes reducidos pero consistentes */
        padding: 10px;
      }
      
      /* Aplicamos zoom automático en móviles */
      .mobile-zoom {
        transform: scale(0.85);
        transform-origin: top center;
      }
      
      .key.white {
        width: 13px;
        height: 75px;
      }
      
      .key.black {
        width: 8px;
        height: 48px;
        margin-left: -4px;
        margin-right: -4px;
      }
      
   
    }
    
    @media (max-width: 480px) {
      #top-bar {
        padding: 8px 12px;
      }
      
      .controls {
        gap: 12px;
      }
      
    

      
      /* Zoom más agresivo en pantallas muy pequeñas */
      .mobile-zoom {
        transform: scale(0.75);
        transform-origin: top center;
      }
      
      #osmd-container {
        margin: 12px 8px; /* Márgenes aún más reducidos */
      }
    }

    /* AGREGA ESTOS ESTILOS PARA EL NUEVO CONTROL DE VELOCIDAD */
.speed-group {
    display: flex;
    align-items: center;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    background-color: #fff;
    box-shadow: 0 1px 2px rgba(0,0,0,0.04);
}

.speed-ctrl-btn {
    font-size: 20px;
    font-weight: 500;
    padding: 2px 14px;
    line-height: 1;
    border-radius: 0; /* Quitamos bordes individuales */
    background-color: transparent;
}
.speed-ctrl-btn:hover:not(:disabled) {
    background-color: #f5f5f5;
}

.speed-display {

    text-align: center;
    min-width: 80px;
    border-left: 1px solid #e0e0e0;
    border-right: 1px solid #e0e0e0;
}

.speed-bpm {
    font-size: 14px;
    font-weight: 600;
    display: block;
    color: #1a1a1a;
}

.speed-value {
    font-size: 11px;
    color: #999;
    display: block;
    margin-top: 2px;
}
  </style>
</head>
<body>

  <div id="top-bar">
    <div id="title-section">
      <span id="song-title"></span>
      <span id="song-composer"></span>
    </div>
    
    <div class="controls">
      <button id="piano-btn" class="btn" title="Mostrar/Ocultar Piano">
       <img src="https://lh3.googleusercontent.com/d/1vMHUODAn781r96RNhefO3HWZrqtMM_0u=s96-c" style="height: 16.5px; width: 15.5px">
      </button>
      
      <button id="play-btn" class="btn" disabled>
        <svg id="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
        <svg id="pause-icon" viewBox="0 0 24 24" style="display:none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
      </button>
      
      <!-- CONTROL DE VELOCIDAD MEJORADO -->
     <div class="speed-group">
  <button id="speed-down-btn" class="btn speed-ctrl-btn">−</button>
  <div class="speed-display">
    <span class="speed-bpm" id="speed-bpm">120 BPM</span>
    <span class="speed-value" id="speed-label">1.00x</span>
  </div>
  <button id="speed-up-btn" class="btn speed-ctrl-btn">+</button>
</div>

    </div>
    
    <div id="progress-bar-container">
      <div id="progress-bar"></div>
    </div>
  </div>

  <!-- Controles de zoom para móviles -->
  <div id="zoom-controls">
    <button class="zoom-btn" id="zoom-out">−</button>
    <span class="zoom-display" id="zoom-label">100%</span>
    <button class="zoom-btn" id="zoom-in">+</button>
  </div>

  <div id="osmd-container"></div>
  <div id="status">Cargando...</div>
  
  <div id="piano-container">
    <div id="piano-keys"></div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@latest/build/opensheetmusicdisplay.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>

  <script>
    const playBtn = document.getElementById('play-btn');
    const playIcon = document.getElementById('play-icon');
    const pauseIcon = document.getElementById('pause-icon');
    const pianoBtn = document.getElementById('piano-btn');
    const osmdContainer = document.getElementById('osmd-container');
    const statusDiv = document.getElementById('status');
    const pianoContainer = document.getElementById('piano-container');
    const pianoKeys = document.getElementById('piano-keys');
    const progressBar = document.getElementById('progress-bar');
    const progressBarContainer = document.getElementById('progress-bar-container');
    const speedLabel = document.getElementById('speed-label');
    const speedBpmLabel = document.getElementById('speed-bpm');
   const speedUpBtn = document.getElementById('speed-up-btn');
const speedDownBtn = document.getElementById('speed-down-btn');
    const zoomInBtn = document.getElementById('zoom-in');
    const zoomOutBtn = document.getElementById('zoom-out');
    const zoomLabel = document.getElementById('zoom-label');

    let osmd = null;
    let sampler = null;
    let parsedNotes = [];
    let measureStartTimes = [];
    let globalTempo = 120;
    let playbackRate = 1.0;
    let currentSpeed = 1.0;
    let totalDuration = 0;
    let isPlaying = false;
    let audioPart = null;
    let visualPart = null;
    let progressInterval = null;
    let currentZoom = 1.0;
    let isMobile = window.innerWidth <= 768;
    
    const MUSICXML_URL = 'https://storage.googleapis.com/mozartacademy-files/midi/clowns-dmitri-kabalevsky.musicxml';

    document.addEventListener('DOMContentLoaded', async () => {
      setStatus('Inicializando...');
      initOSMD();
      createPiano88Keys();
      addEventListeners();
      initSampler();
      
      setStatus('Cargando sonidos de piano...');
      await Tone.loaded();
      setStatus('Cargando partitura...');
      await loadMusicXMLFromUrl(MUSICXML_URL);
    });

    function initOSMD() {
      try {
        osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay(osmdContainer, {
          backend: 'svg',
          drawTitle: true,
          followCursor: true,
          autoResize: true,
          drawingParameters: "compacttight",
          cursorsOptions: [{ 
            type: 1, 
            color: "rgba(52,152,219,0.7)", 
            alpha: 0.7, 
            follow: true 
          }]
        });
        
        // Configuración para pantallas grandes (hasta 4 compases por línea)
        setupEngravingRulesForScreenSize();
        
      } catch (e) { 
        setStatus('Error al inicializar'); 
      }
    }

    // Función para configurar reglas según el tamaño de pantalla
    function setupEngravingRulesForScreenSize() {
      if (!osmd || !osmd.EngravingRules) return;
      
      const width = window.innerWidth;
      
      if (width <= 480) {
        // Pantallas muy pequeñas - máxima compresión
        osmd.EngravingRules.SystemMaxMeasuresCount = 4;
        osmd.EngravingRules.MinimumDistanceBetweenNotes = 0.8;
        osmd.EngravingRules.MinimumDistanceBetweenStaffLines = 2.0;
        osmd.EngravingRules.StaffDistance = 2.8;
        osmd.EngravingRules.StaffLineWidth = 0.06;
        osmd.EngravingRules.NoteHeadWidth = 0.8;
        osmd.zoom = 0.7;
        currentZoom = 0.7;
      } else if (width <= 768) {
        // Tablets y móviles grandes
        osmd.EngravingRules.SystemMaxMeasuresCount = 4;
        osmd.EngravingRules.MinimumDistanceBetweenNotes = 1.0;
        osmd.EngravingRules.MinimumDistanceBetweenStaffLines = 2.2;
        osmd.EngravingRules.StaffDistance = 3.0;
        osmd.EngravingRules.StaffLineWidth = 0.07;
        osmd.EngravingRules.NoteHeadWidth = 0.9;
        osmd.zoom = 0.8;
        currentZoom = 0.8;
      } else {
        // Pantallas de escritorio
        osmd.EngravingRules.SystemMaxMeasuresCount = 4;
        osmd.EngravingRules.MinimumDistanceBetweenNotes = 1.2;
        osmd.EngravingRules.MinimumDistanceBetweenStaffLines = 2.5;
        osmd.EngravingRules.StaffDistance = 3.5;
        osmd.EngravingRules.StaffLineWidth = 0.08;
        osmd.EngravingRules.NoteHeadWidth = 1.0;
        osmd.zoom = 1.0;
        currentZoom = 1.0;
      }
      
      updateZoomDisplay();
    }

    function initSampler() {
      sampler = new Tone.Sampler({
        urls: { 
          "C4": "C4.mp3", 
          "D#4": "Ds4.mp3", 
          "F#4": "Fs4.mp3", 
          "A4": "A4.mp3" 
        },
        release: 1,
        baseUrl: "https://tonejs.github.io/audio/salamander/"
      }).toDestination();
    }

    function createPiano88Keys() {
      pianoKeys.innerHTML = '';
      const pattern = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
      const blackKeys = { 'C': 'C#', 'D': 'D#', 'F': 'F#', 'G': 'G#', 'A': 'A#' };
      
      // Piano de 88 teclas: A0 a C8
      for (let octave = 0; octave <= 8; octave++) {
        const startNote = octave === 0 ? 9 : 0;
        
        for (let i = startNote; i <= 6; i++) {
          if (octave === 0 && i < 9) continue;
          if (octave === 8 && i > 0) break;
          
          const note = pattern[i % 7];
          const whiteKey = document.createElement('div');
          whiteKey.className = 'key white';
          whiteKey.id = `${note}${octave}`;
          pianoKeys.appendChild(whiteKey);
          
          if (blackKeys[note] && !(octave === 8 && note === 'C')) {
            const blackKey = document.createElement('div');
            blackKey.className = 'key black';
            blackKey.id = `${blackKeys[note]}${octave}`;
            pianoKeys.appendChild(blackKey);
          }
        }
      }
    }

    async function loadMusicXMLFromUrl(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Error de red');
        const text = await response.text();
        await osmd.load(text);
        osmdContainer.innerHTML = ''; 
        
        // Aplicar reglas de tamaño antes de renderizar
        setupEngravingRulesForScreenSize();
        
        await osmd.render();
        
        parseMusicXML(text);
        scheduleNotesOnTransport();

        playBtn.disabled = false;
        setStatus('');
      } catch (err) {
        setStatus(`Error: ${err.message}`);
      }
    }
    
    function parseMusicXML(xmlText) {
      parsedNotes = [];
      measureStartTimes = [0];
      const parser = new DOMParser();
      const xml = parser.parseFromString(xmlText, 'application/xml');
      
      const divisions = parseInt(xml.querySelector('divisions')?.textContent.trim() || '24', 10);
      const soundTempo = xml.querySelector('direction sound[tempo], sound[tempo]');
      globalTempo = soundTempo ? parseFloat(soundTempo.getAttribute('tempo')) : 120;
      updateBpmDisplay();
      Tone.Transport.bpm.value = globalTempo;

      let currentBeat = 0;
      const measures = xml.querySelectorAll('part:first-of-type measure');
      measures.forEach((measure, measureIndex) => {
        if (measureIndex > 0) measureStartTimes.push(currentBeat * (60.0 / globalTempo));

        const nodes = measure.querySelectorAll('note, backup, forward');
        nodes.forEach(node => {
          const durationVal = parseFloat(node.querySelector('duration')?.textContent.trim() || '0');
          if (node.tagName === 'note') {
            const isChord = !!node.querySelector('chord');
            if (!node.querySelector('rest') && node.querySelector('pitch')) {
              const step = node.querySelector('step')?.textContent?.trim();
              const octave = node.querySelector('octave')?.textContent?.trim();
              const alt = parseInt(node.querySelector('alter')?.textContent?.trim() || '0', 10);
              const accidental = alt === 1 ? '#' : alt === -1 ? 'b' : '';
              
              parsedNotes.push({
                pitch: `${step}${accidental}${octave}`,
                startSec: currentBeat * (60.0 / globalTempo),
                durSec: (durationVal / divisions) * (60.0 / globalTempo)
              });
            }
            if (!isChord) currentBeat += (durationVal / divisions);
          } else if (node.tagName === 'backup') {
            currentBeat -= (durationVal / divisions);
          } else if (node.tagName === 'forward') {
            currentBeat += (durationVal / divisions);
          }
        });
      });
      
      const lastNote = parsedNotes[parsedNotes.length - 1];
      totalDuration = lastNote ? lastNote.startSec + lastNote.durSec : 0;
    }

    function scheduleNotesOnTransport() {
    if (audioPart) audioPart.dispose();
    if (visualPart) visualPart.dispose();
    Tone.Transport.cancel();
    osmd.cursor.reset();
    osmd.cursor.hide();

    // Aplica el 'playbackRate' a cada nota al momento de programarla
    const audioEvents = parsedNotes.map(note => ({
        time: note.startSec / playbackRate, // Se divide el tiempo
        pitch: note.pitch,
        duration: note.durSec / playbackRate // Se divide la duración
    }));

    const notesByTime = new Map();
    parsedNotes.forEach(note => {
        const time = note.startSec / playbackRate; // Usa el tiempo ajustado
        if (!notesByTime.has(time)) {
            notesByTime.set(time, []);
        }
        notesByTime.get(time).push({
            ...note,
            duration: note.durSec / playbackRate // Guarda la duración ajustada
        });
    });

    const visualEvents = [];
    notesByTime.forEach((notes, time) => {
        visualEvents.push({ time, notes });
    });

    audioPart = new Tone.Part((time, value) => {
        sampler.triggerAttackRelease(value.pitch, value.duration, time);
    }, audioEvents).start(0);

    visualPart = new Tone.Part((time, value) => {
        Tone.Draw.schedule(() => {
            osmd.cursor.next();
            value.notes.forEach(note => highlightKey(note.pitch, note.duration));
        }, time);
    }, visualEvents).start(0);

    // Ajusta la duración total
    const newTotalDuration = totalDuration / playbackRate;
    Tone.Transport.scheduleOnce(() => stopPlayback(), newTotalDuration + 0.5);
}
    
    function playFromMeasure(measureIndex) {
    if (Tone.Transport.state === 'started') stopPlayback();
    
    const startTime = measureStartTimes[measureIndex] || 0;
    
    // Resetear cursor visual
    osmd.cursor.reset();
    
    // Encontrar todas las notas antes del tiempo de inicio
    const notesBeforeStart = parsedNotes.filter(n => n.startSec < startTime);
    
    // Avanzar el cursor hasta la posición correcta
    let currentTime = -1;
    parsedNotes.forEach(note => {
        if (note.startSec < startTime && note.startSec !== currentTime) {
            osmd.cursor.next();
            currentTime = note.startSec;
        }
    });
    
    // Iniciar reproducción
    Tone.Transport.start(Tone.now() + 0.1, startTime / playbackRate);
    updatePlayButton(true);
    osmd.cursor.show();
    startProgressUpdate();
}

    function stopPlayback() {
      Tone.Transport.stop();
      osmd.cursor.reset();
      osmd.cursor.hide();
      updatePlayButton(false);
      stopProgressUpdate();
      progressBar.style.width = '0%';
    }

    function startProgressUpdate() {
      stopProgressUpdate();
      progressInterval = setInterval(() => {
        const progress = (Tone.Transport.seconds / totalDuration) * 100;
        progressBar.style.width = `${Math.min(progress, 100)}%`;
      }, 100);
    }

    function stopProgressUpdate() {
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
    }

    function addEventListeners() {
      playBtn.addEventListener('click', async () => {
        await Tone.start();
        if (Tone.Transport.state === 'started') {
          Tone.Transport.pause();
          updatePlayButton(false);
          stopProgressUpdate();
        } else {
          Tone.Transport.start(Tone.now() + 0.1);
          updatePlayButton(true);
          osmd.cursor.show();
          startProgressUpdate();
        }
      });

      // CONTROL DE VELOCIDAD CORREGIDO
  const speedStep = 0.05; // Cuánto cambiará la velocidad con cada clic

function updateSpeed(newRate) {
    // Detener la reproducción si está activa
    if (Tone.Transport.state === 'started') {
        stopPlayback();
    }
    
    // Limitar la velocidad entre 0.25x y 2.0x
    playbackRate = Math.max(0.25, Math.min(2.0, newRate));
    
    // Actualizar la interfaz
    const currentBPM = Math.round(globalTempo * playbackRate);
    speedLabel.textContent = `${playbackRate.toFixed(2)}x`;
    speedBpmLabel.textContent = `${currentBPM} BPM`;
    
    // Volver a programar las notas con la nueva velocidad
    scheduleNotesOnTransport();
}

speedUpBtn.addEventListener('click', () => {
    updateSpeed(playbackRate + speedStep);
});

speedDownBtn.addEventListener('click', () => {
    updateSpeed(playbackRate - speedStep);
});

      pianoBtn.addEventListener('click', () => {
        pianoContainer.classList.toggle('hidden');
      });
      
      // Controles de zoom
      zoomInBtn.addEventListener('click', () => {
        currentZoom = Math.min(2.0, currentZoom + 0.1);
        applyZoom();
      });
      
      zoomOutBtn.addEventListener('click', () => {
        currentZoom = Math.max(0.5, currentZoom - 0.1);
        applyZoom();
      });
      
      // Redimensionar ventana
      window.addEventListener('resize', () => {
        const newIsMobile = window.innerWidth <= 768;
        if (newIsMobile !== isMobile) {
          isMobile = newIsMobile;
          if (osmd) {
            setupEngravingRulesForScreenSize();
            osmd.render();
          }
        }
      });
      
      progressBarContainer.addEventListener('click', (e) => {
        const rect = progressBarContainer.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        const newTime = percent * totalDuration;
        Tone.Transport.seconds = newTime;
        
        osmd.cursor.reset();
        const notesBeforeNewTime = parsedNotes.filter(n => n.startSec < newTime);
        const uniqueTimestamps = new Set(notesBeforeNewTime.map(n => n.startSec));
        uniqueTimestamps.forEach(() => {
          osmd.cursor.next();
        });
      });
      
osmdContainer.addEventListener('click', (event) => {
    if (!osmd?.graphic?.measureList) return;
    
    const rect = osmdContainer.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const clickY = event.clientY - rect.top;
    
    let closestMeasureIndex = -1;
    let minDistance = Infinity;
    
    osmd.graphic.measureList.forEach((measureStaffEntries, measureIndex) => {
        if (!measureStaffEntries || measureStaffEntries.length === 0) return;
        
        // Iterar sobre todas las staffEntries del compás
        measureStaffEntries.forEach(staffEntries => {
            if (!staffEntries || staffEntries.length === 0) return;
            
            // Tomar la primera GraphicalStaffEntry válida
            const graphicalStaffEntry = staffEntries[0];
            if (!graphicalStaffEntry || !graphicalStaffEntry.boundingBox) return;
            
            const bbox = graphicalStaffEntry.boundingBox;
            const centerX = bbox.x + bbox.width / 2;
            const centerY = bbox.y + bbox.height / 2;
            
            const distance = Math.sqrt(
                Math.pow(clickX - centerX, 2) + 
                Math.pow(clickY - centerY, 2)
            );
            
            if (distance < minDistance && distance < 100) { // Límite de distancia
                minDistance = distance;
                closestMeasureIndex = measureIndex;
            }
        });
    });
    
    if (closestMeasureIndex !== -1 && closestMeasureIndex < measureStartTimes.length) {
        alert(`Reproduciendo desde compás ${closestMeasureIndex + 1}`);
        playFromMeasure(closestMeasureIndex);
    }
});
    }

    function applyZoom() {
      if (osmd) {
        osmd.zoom = currentZoom;
        osmd.render();
        updateZoomDisplay();
      }
    }

    function updateZoomDisplay() {
      zoomLabel.textContent = `${Math.round(currentZoom * 100)}%`;
    }

    function updatePlayButton(isPlaying) {
      playIcon.style.display = isPlaying ? 'none' : 'block';
      pauseIcon.style.display = isPlaying ? 'block' : 'none';
    }

    function updateBpmDisplay() {
      const currentBPM = Math.round(globalTempo * currentSpeed);
      speedLabel.textContent = `${currentSpeed.toFixed(2)}x`;
      speedBpmLabel.textContent = `${currentBPM} BPM`;
    }

    function highlightKey(noteName, durSec) {
      const noteId = noteName.replace('b', '#');
      const el = document.getElementById(noteId);
      if (!el) return;
      el.classList.add('active');
      const highlightDuration = Math.max(80, durSec * 1000 / currentSpeed);
      setTimeout(() => el.classList.remove('active'), highlightDuration);
    } 

    function setStatus(text) { 
      statusDiv.textContent = text;
      statusDiv.style.display = text ? 'block' : 'none';
    }
  </script>
</body>
</html>
