<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Reproductor MusicXML Light</title>
  <link href="https://cdn.jsdelivr.net/npm/remixicon@4.5.0/fonts/remixicon.css" rel="stylesheet"/>
  <style>
    :root {
      --primary-color: #3498db;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #ffffff; /* Fondo blanco para integrarse en artículos */
      color: #1a1a1a;
      overflow: hidden; /* Evitamos scroll en el body, lo haremos en el contenedor */
    }
    
    /* Top Bar Simplificada */
    #top-bar {
      background: #f8f9fa;
      border-bottom: 1px solid #e0e0e0;
      padding: 8px 15px;
      display: flex;
      justify-content: flex-start; /* Alineado a la izquierda */
      align-items: center;
      gap: 15px;
      height: 50px;
    }

    .btn {
      background: white;
      border: 1px solid #ddd;
      cursor: pointer;
      padding: 6px 12px;
      border-radius: 4px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
    }

    .btn:hover {
      background: #f0f0f0;
      border-color: #ccc;
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn i {
      font-size: 18px;
    }

    /* Contenedor de la partitura con Scroll Horizontal */
    #sheet-wrapper {
        width: 100%;
        height: calc(100vh - 50px); /* Resto de la pantalla */
        overflow-x: auto; /* Permite scroll horizontal */
        overflow-y: hidden;
        display: flex;
        align-items: center; /* Centrar verticalmente la partitura */
        background-color: #fff;
    }

    #osmd-container {
      /* Importante: No restringir el ancho para que crezca horizontalmente */
      width: auto; 
      min-width: 100%;
      padding: 0 20px;
    }

    #status {
      font-size: 12px;
      color: #666;
      margin-left: auto; /* Empuja el status a la derecha */
    }

    /* Ocultar barra de scroll pero permitir funcionalidad (Opcional, estética) */
    #sheet-wrapper::-webkit-scrollbar {
        height: 8px;
    }
    #sheet-wrapper::-webkit-scrollbar-thumb {
        background: #ccc;
        border-radius: 4px;
    }
    #sheet-wrapper::-webkit-scrollbar-track {
        background: #f1f1f1;
    }

  </style>
</head>
<body>

  <div id="top-bar">
    <button id="play-btn" class="btn" disabled title="Reproducir/Pausar">
      <i id="play-icon" class="ri-play-fill"></i>
      <i id="pause-icon" class="ri-pause-fill" style="display:none;"></i>
    </button>
    
    <button id="stop-btn" class="btn" disabled title="Detener y volver al inicio">
        <i class="ri-stop-fill"></i>
    </button>

    <div style="display: flex; align-items: center; gap: 5px; font-size: 12px; border: 1px solid #ddd; padding: 2px; border-radius: 4px; background: white;">
        <button id="speed-down" class="btn" style="border:none; padding: 2px 8px;">-</button>
        <span id="bpm-display" style="min-width: 60px; text-align: center;">120 BPM</span>
        <button id="speed-up" class="btn" style="border:none; padding: 2px 8px;">+</button>
    </div>

    <div id="status">Cargando...</div>
  </div>

  <div id="sheet-wrapper">
    <div id="osmd-container"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@latest/build/opensheetmusicdisplay.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>

  <script>
    // Elementos DOM
    const playBtn = document.getElementById('play-btn');
    const stopBtn = document.getElementById('stop-btn');
    const playIcon = document.getElementById('play-icon');
    const pauseIcon = document.getElementById('pause-icon');
    const osmdContainer = document.getElementById('osmd-container');
    const statusDiv = document.getElementById('status');
    const bpmDisplay = document.getElementById('bpm-display');
    const speedUpBtn = document.getElementById('speed-up');
    const speedDownBtn = document.getElementById('speed-down');

    // Variables Globales
    let osmd = null;
    let sampler = null;
    let audioPart = null;
    let visualPart = null;
    let parsedNotes = [];
    let globalTempo = 120;
    let playbackRate = 1.0;
    let totalDuration = 0;

    // Inicialización
    document.addEventListener('DOMContentLoaded', async () => {
      setStatus('Cargando motor de audio...');
      
      // 1. Inicializar OSMD en modo Horizontal
      initOSMD();

      // 2. Cargar Sampler (Sonidos)
      await initSampler();
      
      // 3. Cargar Archivo XML
      const urlParams = new URLSearchParams(window.location.search);
      const fileId = urlParams.get('file'); 
      
      if (!fileId) {
        setStatus('Cargando partitura...');
        const dynamicUrl = `https://storage.googleapis.com/mozartacademy-files/xml/Ode%20to%20Joy.musicxml`;
        //const dynamicUrl = `https://storage.googleapis.com/mozartacademy-files/xml/${encodeURIComponent(fileId)}`;
        await loadMusicXMLFromUrl(dynamicUrl);
      } else {
        setStatus('⚠️ Error: No se especificó ?file=archivo.xml');
      }
    });

    function initOSMD() {
      osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay(osmdContainer, {
        backend: 'svg',
        drawTitle: false, // Generalmente redundante en embeds de teoría
        drawSubtitle: false,
        drawComposer: false,
        followCursor: true,
        autoResize: true,
        // --- LA CLAVE MÁGICA PARA MODO HORIZONTAL ---
        renderSingleHorizontalStaffline: true, 
        // -------------------------------------------
        drawingParameters: "compact", // Reduce márgenes
        drawMeasureNumbers: true,
        cursorsOptions: [{ 
            type: 1, 
            color: "rgba(52, 152, 219, 0.5)", 
            alpha: 0.5, 
            follow: true 
        }]
      });
    }

    async function initSampler() {
        // Usamos un set más ligero para cargar rápido
        sampler = new Tone.Sampler({
            urls: { "C4": "C4.mp3", "C5": "C5.mp3", "A3": "A3.mp3", "A4": "A4.mp3" },
            release: 1,
            baseUrl: "https://tonejs.github.io/audio/salamander/"
        }).toDestination();
        await Tone.loaded();
    }

    async function loadMusicXMLFromUrl(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Error al descargar XML');
        const text = await response.text();
        
        await osmd.load(text);
        
        // Ajuste de Zoom para que se vea bien en horizontal
        osmd.zoom = 0.8;
        await osmd.render();
        
        parseMusicXML(text);
        scheduleNotes();
        
        playBtn.disabled = false;
        stopBtn.disabled = false;
        setStatus('Listo para reproducir');
        updateBpmDisplay();

      } catch (err) {
        setStatus('Error: ' + err.message);
        console.error(err);
      }
    }

    // --- LÓGICA DE AUDIO (Simplificada de la versión completa) ---
    
    function parseMusicXML(xmlText) {
       // Parsing básico para obtener tiempos y notas para Tone.js
       // (Misma lógica esencial que la versión full, pero sin metadatos de manos/colores)
       parsedNotes = [];
       const parser = new DOMParser();
       const xml = parser.parseFromString(xmlText, "application/xml");
       
       // Detectar Tempo
       const soundTempo = xml.querySelector("direction sound[tempo], sound[tempo]");
       globalTempo = soundTempo ? parseFloat(soundTempo.getAttribute("tempo")) : 120;
       Tone.Transport.bpm.value = globalTempo;

       const divisions = parseInt(xml.querySelector("divisions")?.textContent || "24", 10);
       
       xml.querySelectorAll('part').forEach((part) => {
           let currentBeat = 0;
           part.querySelectorAll('measure').forEach((measure) => {
               measure.querySelectorAll('note, backup, forward').forEach(node => {
                   const durationVal = parseFloat(node.querySelector('duration')?.textContent || '0');
                   const durationInBeats = durationVal / divisions;

                   if (node.tagName === 'note') {
                       const isChord = !!node.querySelector('chord');
                       const isRest = !!node.querySelector('rest');
                       
                       if (!isChord) currentBeat += durationInBeats;

                       if (!isRest && node.querySelector('pitch')) {
                           // Construir nota (Ej: C4)
                           const step = node.querySelector('step').textContent;
                           const octave = node.querySelector('octave').textContent;
                           const alter = node.querySelector('alter')?.textContent;
                           let accidental = '';
                           if(alter === '1') accidental = '#';
                           if(alter === '-1') accidental = 'b';
                           
                           const pitch = `${step}${accidental}${octave}`;
                           const startTime = (currentBeat - durationInBeats) * (60 / globalTempo);
                           
                           parsedNotes.push({
                               pitch: pitch,
                               startTime: startTime,
                               duration: durationInBeats * (60 / globalTempo),
                               isChord: isChord
                           });
                       }
                   } else if (node.tagName === 'backup') {
                       currentBeat -= durationInBeats;
                   } else if (node.tagName === 'forward') {
                       currentBeat += durationInBeats;
                   }
               });
           });
       });
       
       parsedNotes.sort((a, b) => a.startTime - b.startTime);
       if(parsedNotes.length > 0) {
           const last = parsedNotes[parsedNotes.length-1];
           totalDuration = last.startTime + last.duration;
       }
    }

    function scheduleNotes() {
        if (audioPart) audioPart.dispose();
        if (visualPart) visualPart.dispose();
        Tone.Transport.cancel();
        osmd.cursor.reset();
        
        // Agrupar notas por tiempo para acordes
        const notesByTime = new Map();
        parsedNotes.forEach(n => {
            const t = n.startTime / playbackRate; // Ajuste por velocidad
            if (!notesByTime.has(t)) notesByTime.set(t, []);
            notesByTime.get(t).push(n);
        });

        // Eventos de Audio
        const audioEvents = [];
        notesByTime.forEach((notes, time) => {
            audioEvents.push({
                time: time,
                pitches: notes.map(n => n.pitch),
                duration: notes[0].duration / playbackRate
            });
        });

        audioPart = new Tone.Part((time, value) => {
            sampler.triggerAttackRelease(value.pitches, value.duration, time);
        }, audioEvents).start(0);

        // Eventos Visuales (Cursor)
        // En modo horizontal, el cursor avanza nota a nota
        // Usamos Tone.Draw para sincronizar con la pantalla
        const visualEvents = Array.from(notesByTime.keys()).map(t => ({ time: t }));
        
        visualPart = new Tone.Part((time) => {
            Tone.Draw.schedule(() => {
                osmd.cursor.next();
            }, time);
        }, visualEvents).start(0);
    }

    // --- CONTROLES UI ---

    playBtn.addEventListener('click', async () => {
        await Tone.start();
        if (Tone.Transport.state === 'started') {
            pausePlayback();
        } else {
            startPlayback();
        }
    });

    stopBtn.addEventListener('click', () => {
        stopPlayback();
    });

    function startPlayback() {
        Tone.Transport.start();
        playIcon.style.display = 'none';
        pauseIcon.style.display = 'inline-block';
        osmd.cursor.show();
    }

    function pausePlayback() {
        Tone.Transport.pause();
        playIcon.style.display = 'inline-block';
        pauseIcon.style.display = 'none';
    }

    function stopPlayback() {
        Tone.Transport.stop();
        playIcon.style.display = 'inline-block';
        pauseIcon.style.display = 'none';
        osmd.cursor.reset(); // Vuelve al inicio
        // Asegurarse que el scroll vuelva al inicio
        document.getElementById('sheet-wrapper').scrollLeft = 0;
    }

    function setStatus(text) {
        statusDiv.textContent = text;
    }
    
    // Control de Velocidad
    speedUpBtn.addEventListener('click', () => changeSpeed(0.1));
    speedDownBtn.addEventListener('click', () => changeSpeed(-0.1));

    function changeSpeed(delta) {
        playbackRate = Math.max(0.5, Math.min(2.0, playbackRate + delta));
        
        // Recalcular audio si está reproduciendo
        const wasPlaying = Tone.Transport.state === 'started';
        if(wasPlaying) Tone.Transport.pause();
        
        scheduleNotes(); // Reprogramar con nuevos tiempos
        updateBpmDisplay();
        
        if(wasPlaying) Tone.Transport.start();
    }

    function updateBpmDisplay() {
        bpmDisplay.textContent = `${Math.round(globalTempo * playbackRate)} BPM`;
    }

  </script>
</body>
</html>
