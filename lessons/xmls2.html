<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Reproductor MusicXML Light</title>
  <link href="https://cdn.jsdelivr.net/npm/remixicon@4.5.0/fonts/remixicon.css" rel="stylesheet"/>
  <style>
    :root {
      --primary-color: #3498db;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #ffffff;
      color: #1a1a1a;
      display: flex;
      flex-direction: column; 
      height: 100vh; 
      overflow: hidden; 
    }
    
    /* 1. Contenedor Principal */
    #sheet-wrapper {
        flex-grow: 1; 
        width: 100%;
        overflow-x: auto; 
        overflow-y: hidden;
        display: flex;
        /* align-items: center;  <-- ELIMINAMOS ESTO AQUÍ para evitar conflictos de scroll */
        background-color: #fff;
        position: relative;
        margin-bottom: -50px;
    }

    /* 2. Contenedor OSMD */
    #osmd-container {
      height: 100%; 
      display: flex;
      align-items: center; /* Centrado vertical del SVG */
      
      width: auto; 
      min-width: 100%;
      padding: 20 20px;
      touch-action: pan-x;
    }

    /* 3. REGLA MÁGICA PARA EL SVG */
    /* Esto fuerza a la partitura a encogerse si la pantalla es muy bajita */
    #osmd-container svg {
        max-height: 90%; /* Deja un pequeño margen (10%) para que no toque los bordes */
        width: auto !important; /* Mantiene la proporción correcta */
        display: block; /* Evita espacios extra en inline */
    }

    /* Barra de Controles */
 #control-bar {
  position: fixed; /* Flota sobre el contenido */
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  width: 80%;
  max-width: 400px;
  height: 50px;
  background: rgba(255, 255, 255, 0.9); /* Fondo claro con transparencia */
  backdrop-filter: blur(10px); /* Efecto de desenfoque */
  border-radius: 12px; /* Forma de píldora */
  padding: 0 25px;
  display: flex;
  align-items: center;
  gap: 15px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.1);
  z-index: 1000;
}

.btn {
  background: transparent;
  border: none;
  cursor: pointer;
  display: flex;
  color: #1a1a1a;
}

.btn i { font-size: 30px; }
.btn:hover { transform: scale(1.1); }

.progress-container {
  flex-grow: 1;
  height: 8px;
  background: rgba(0, 0, 0, 0.05);
  border-radius: 4px;
  overflow: hidden;
}

.progress-bar {
  width: 0%; /* Inicia en cero */
  height: 100%;
  background: #1a1a1a;
  border-radius: 4px;
  transition: width 0.1s linear;
}

#time-display {
  font-family: -apple-system, sans-serif;
  font-weight: 600;
  font-size: 16px;
  color: #1a1a1a;
  min-width: 90px;
  text-align: right;
}


    #sheet-wrapper::-webkit-scrollbar { height: 8px; }
    #sheet-wrapper::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }
    #sheet-wrapper::-webkit-scrollbar-track { background: #f1f1f1; }

  </style>
</head>
<body>

  <div id="sheet-wrapper">
    <div id="osmd-container"></div>
  </div>

  <div id="control-bar">
    <button id="play-btn" class="btn" disabled title="Reproducir/Pausar">
      <i id="play-icon" class="ri-play-fill"></i>
      <i id="pause-icon" class="ri-pause-fill" style="display:none;"></i>
    </button>

 <div class="progress-container">
    <div id="dynamic-progress" class="progress-bar"></div>
  </div>

  <div id="time-display">0:00 / 0:00</div>
    


  </div>

  <script src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@latest/build/opensheetmusicdisplay.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>

  <script>
    // Elementos DOM
    const playBtn = document.getElementById('play-btn');

    const playIcon = document.getElementById('play-icon');
    const pauseIcon = document.getElementById('pause-icon');
    const osmdContainer = document.getElementById('osmd-container');

    const sheetWrapper = document.getElementById('sheet-wrapper');
    const progressBar = document.getElementById('dynamic-progress');
const timeDisplay = document.getElementById('time-display');
let duration = 0;

    // Variables Globales
    let osmd = null;
    let sampler = null;
    let audioPart = null;
    let visualPart = null;
    let parsedNotes = [];
    let globalTempo = 120;
    let playbackRate = 1.0;

    document.addEventListener('DOMContentLoaded', async () => {

      initOSMD();
      await initSampler();
      
      const urlParams = new URLSearchParams(window.location.search);
      const fileId = urlParams.get('file'); 
      
      if (fileId) {

       const dynamicUrl = `https://storage.googleapis.com/mozartacademy-files/xml/${encodeURIComponent(fileId)}`;
        await loadMusicXMLFromUrl(dynamicUrl);
      } else {
      }
    });

    function initOSMD() {
      osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay(osmdContainer, {
        backend: 'svg',
        drawTitle: false,
        drawSubtitle: false,
        drawComposer: false,
        followCursor: true, 
        autoResize: false, 
        renderSingleHorizontalStaffline: true, 
        drawingParameters: "compact",
        drawMeasureNumbers: true,
        cursorsOptions: [{ 
            type: 1, 
            color: "rgba(52, 152, 219, 0.5)", 
            alpha: 0.5, 
            follow: true 
        }]
      });
    }

    async function initSampler() {
        sampler = new Tone.Sampler({
            urls: { "C4": "C4.mp3", "C5": "C5.mp3", "A3": "A3.mp3", "A4": "A4.mp3" },
            release: 1,
            baseUrl: "https://tonejs.github.io/audio/salamander/"
        }).toDestination();
        await Tone.loaded();
    }

    async function loadMusicXMLFromUrl(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Error al descargar XML');
        const text = await response.text();
        
        await osmd.load(text);
        
        // Ajuste de Zoom un poco más agresivo para pantallas pequeñas
        osmd.zoom = 0.8; 
        
        await osmd.render();
        
        parseMusicXML(text);
        scheduleNotes();
        
        playBtn.disabled = false;


        updateBpmDisplay();

      } catch (err) {

        console.error(err);
      }
    }

    function parseMusicXML(xmlText) {
       parsedNotes = [];
       const parser = new DOMParser();
       const xml = parser.parseFromString(xmlText, "application/xml");
       
       const soundTempo = xml.querySelector("direction sound[tempo], sound[tempo]");
       globalTempo = soundTempo ? parseFloat(soundTempo.getAttribute("tempo")) : 120;
       Tone.Transport.bpm.value = globalTempo;

       const divisions = parseInt(xml.querySelector("divisions")?.textContent || "24", 10);
       
       xml.querySelectorAll('part').forEach((part) => {
           let currentBeat = 0;
           part.querySelectorAll('measure').forEach((measure) => {
               measure.querySelectorAll('note, backup, forward').forEach(node => {
                   const durationVal = parseFloat(node.querySelector('duration')?.textContent || '0');
                   const durationInBeats = durationVal / divisions;

                   if (node.tagName === 'note') {
                       const isChord = !!node.querySelector('chord');
                       const isRest = !!node.querySelector('rest');
                       
                       if (!isChord) currentBeat += durationInBeats;

                       if (!isRest && node.querySelector('pitch')) {
                           const step = node.querySelector('step').textContent;
                           const octave = node.querySelector('octave').textContent;
                           const alter = node.querySelector('alter')?.textContent;
                           let accidental = '';
                           if(alter === '1') accidental = '#';
                           if(alter === '-1') accidental = 'b';
                           
                           const pitch = `${step}${accidental}${octave}`;
                           const startTime = (currentBeat - durationInBeats) * (60 / globalTempo);
                           
                           parsedNotes.push({
                               pitch: pitch,
                               startTime: startTime,
                               duration: durationInBeats * (60 / globalTempo),
                               isChord: isChord
                           });
                       }
                   } else if (node.tagName === 'backup') {
                       currentBeat -= durationInBeats;
                   } else if (node.tagName === 'forward') {
                       currentBeat += durationInBeats;
                   }
               });
           });
       });
       parsedNotes.sort((a, b) => a.startTime - b.startTime);
    }

    function scheduleNotes() {
        if (audioPart) audioPart.dispose();
        if (visualPart) visualPart.dispose();
        Tone.Transport.cancel();
        osmd.cursor.reset();
        
        const notesByTime = new Map();
        parsedNotes.forEach(n => {
            const t = n.startTime / playbackRate; 
            if (!notesByTime.has(t)) notesByTime.set(t, []);
            notesByTime.get(t).push(n);
        });

        const audioEvents = [];
        notesByTime.forEach((notes, time) => {
            audioEvents.push({
                time: time,
                pitches: notes.map(n => n.pitch),
                duration: notes[0].duration / playbackRate
            });
        });

        audioPart = new Tone.Part((time, value) => {
            sampler.triggerAttackRelease(value.pitches, value.duration, time);
        }, audioEvents).start(0);

        const visualEvents = Array.from(notesByTime.keys()).map(t => ({ time: t }));
        
        visualPart = new Tone.Part((time) => {
            Tone.Draw.schedule(() => {
                osmd.cursor.next();
            }, time);
        }, visualEvents).start(0);
    }

    // --- CONTROLES UI ---

    playBtn.addEventListener('click', async () => {
        await Tone.start();
        if (Tone.Transport.state === 'started') {
            pausePlayback();
        } else {
            startPlayback();
        }
    });



function startPlayback() {
    Tone.Transport.start();
    playIcon.style.display = 'none';
    pauseIcon.style.display = 'inline-block';
    osmd.cursor.show();
    
    // Calcular duración total (última nota)
    if (parsedNotes.length > 0) {
        const lastNote = parsedNotes[parsedNotes.length - 1];
        duration = lastNote.startTime + lastNote.duration;
    }
    
    updateUI(); // Iniciar actualización visual
}

    function pausePlayback() {
        Tone.Transport.pause();
        playIcon.style.display = 'inline-block';
        pauseIcon.style.display = 'none';
    }


function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function updateUI() {
    if (Tone.Transport.state === 'started') {
        const currentTime = Tone.Transport.seconds;
        const totalTime = duration / playbackRate;
        
        // Actualizar barra
        const progress = (currentTime / totalTime) * 100;
        progressBar.style.width = `${Math.min(progress, 100)}%`;
        
        // Actualizar texto
        timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(totalTime)}`;
        
        requestAnimationFrame(updateUI);
    }
}


  </script>
</body>
</html>
