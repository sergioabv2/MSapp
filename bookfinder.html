<html lang="es"> 
<head> 
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Piano Virtual - Free Play</title>
  <link href="https://cdn.jsdelivr.net/npm/remixicon@4.5.0/fonts/remixicon.css" rel="stylesheet"/>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f4f4f4; 
        color: #333;
      overflow: hidden;
      height: 100vh;
    }
    
    /* Top Bar */
    #top-bar {
      background: rgba(255, 255, 255, 0.95); 
  border-bottom: 1px solid #ddd;
      padding: 12px 20px;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      display: flex;
      justify-content: space-between;
      align-items: center;
      backdrop-filter: blur(10px);
    }
    
    .title {
      font-size: 18px;
      font-weight: 600;
      color: #333;
    }
    
    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    
    /* --- ESTILO BASE DEL BOT√ìN (SIN COLOR) --- */
.btn {
  cursor: pointer;
  padding: 8px 16px;
  border-radius: 6px;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 14px;
  font-weight: 500;
  border: 1px solid transparent; /* Borde base */
}

.btn:active {
  transform: translateY(0);
}

/* --- TEMA AZUL (Por defecto) --- */
body.theme-blue .btn {
  background: rgba(52, 152, 219, 0.2);
  border-color: #3498db;
  color: #3498db;
}
body.theme-blue .btn:hover {
  background: rgba(52, 152, 219, 0.3);
}
body.theme-blue .key.active {
  background: #3498db !important;
  box-shadow: 0 0 15px rgba(52, 152, 219, 0.8) !important;
}
body.theme-blue .key.black.active {
  background: #2980b9 !important;
}

/* --- TEMA NARANJA --- */
body.theme-orange .btn {
  background: rgba(221, 158, 55, 0.2);
  border-color: #DD9E37;
  color: #DD9E37;
}
body.theme-orange .btn:hover {
  background: rgba(221, 158, 55, 0.3);
}
body.theme-orange .key.active {
  background: #DD9E37 !important;
  box-shadow: 0 0 15px rgba(221, 158, 55, 0.8) !important;
}
body.theme-orange .key.black.active {
  background: #b9812f !important; /* Naranja m√°s oscuro */
}


body.theme-red .btn {
  background: rgba(231, 76, 60, 0.2); /* Rojo (de #e74c3c) */
  border-color: #e74c3c;
  color: #e74c3c;
}
body.theme-red .btn:hover {
  background: rgba(231, 76, 60, 0.3);
}
body.theme-red .key.active {
  background: #e74c3c !important; /* Rojo */
  box-shadow: 0 0 15px rgba(231, 76, 60, 0.8) !important;
}
body.theme-red .key.black.active {
  background: #c0392b !important; /* Rojo m√°s oscuro */
}
    
    .btn:active {
      transform: translateY(0);
    }
    
    .btn i {
      font-size: 18px;
    }
    
    #show-key-names-btn.active {
      background: rgba(52, 152, 219, 0.4);
    }
    
    /* Piano Container */
    #piano-container {
      position: relative;
      left: 0;
      bottom: 0;
      width: 100%;
      height: calc(100vh - 60px);
      top: 60px;
      background: #e9e9e9;
      overflow: hidden;
    }

    #piano-container::before {
  content: '';
  position: absolute;
  bottom: 0; /* Coincide con el 'bottom' de #piano-keys */
  left: 0;
  width: 100%;
  height: 122px; /* Coincide con el 'height' de #piano-keys */
  background: #2a2a2a;
  border-top: 1px solid #333;
  z-index: 1; /* Se pone detr√°s de las teclas */
}
    
    #waterfall-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: calc(100% - 142px);
      pointer-events: none;
      z-index: 1;
    }
    
    /* Piano Keys */
    #piano-keys {
      position: absolute;
      bottom: 25px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      justify-content: center;
      z-index: 2;
      height: 102px;
    }
    
    .key {
      border: 1px solid #ddd;
      position: relative;
      transition: all 0.05s;
      cursor: pointer;
      user-select: none;
    }
    
    .key.white {
      width: 16px;
      height: 90px;
      background: #fff;
      border: 1px solid #ccc;
      border-right: 1px solid #e0e0e0;
    }
    
    .key.black {
      width: 10px;
      height: 58px;
      background: #333;
      border: 1px solid #555;
      margin-left: -5px;
      margin-right: -5px;
      z-index: 2;
    }
    

.active-note-label {
  position: absolute;
  top: -20px; /* Posici√≥n por encima de la tecla */
  left: 50%;
  transform: translateX(-50%);
  color: #f1f1f1; /* Color de texto blanco/claro */
  font-size: 10px;
  font-weight: bold;
  pointer-events: none;
  background: rgba(0, 0, 0, 0.6); /* Fondo semi-transparente */
  padding: 2px 4px;
  border-radius: 3px;
  white-space: nowrap; /* Evita que el texto se rompa */
  z-index: 10;
}

.key.black .active-note-label {
  color: #fff; /* Asegura que sean blancas en teclas negras */
  background: rgba(0, 0, 0, 0.7);
}

/* --- NUEVO: Estilo para etiquetas de nota DENTRO de la carcasa --- */
.casing-note-label {
  position: absolute;
  top: 50%; /* Centrado verticalmente */
  transform: translate(-50%, -50%); /* Centrado horizontal (con 'left' de JS) y vertical */
  color: #f1f1f1;
  font-size: 11px;
  font-weight: 600;
  pointer-events: none;
  background: rgba(0, 0, 0, 0.4); /* Fondo sutil como en tu imagen */
  padding: 2px 6px;
  border-radius: 4px;
  white-space: nowrap;
  z-index: 5; /* Asegura que est√© sobre la carcasa (z-index: 4) */
}

    .key.midi-active {
      background-color: #e0e0e0 !important;
      box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.2) !important;
    }

    .key.white.midi-active {
      background-color: #e8e8e8 !important;
    }

    .key.black.midi-active {
      background-color: #555555 !important;
      box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.4) !important;
    }
    
    /* Key Labels */
    .key-name {
      position: absolute;
      bottom: 5px;
      width: 100%;
      text-align: center;
      font-size: 10px;
      font-weight: bold;
      color: #555;
      pointer-events: none;
      z-index: 10;
    }
    
    .key.black .key-name {
      color: #f1f1f1;
      bottom: 3px;
      font-size: 8px;
    }

    #piano-top-casing {
  position: absolute;
  bottom: 122px; /* A 10px del borde superior de las teclas blancas */
  left: 0;
  width: 100%;
  height: 20px; /* Altura de la carcasa */
  background: #2a2a2a; /* Color negro/gris oscuro */
  box-shadow: inset 0 -2px 5px rgba(0,0,0,0.3); /* Peque√±a sombra interna */
  z-index: 4; /* Encima del hit-line y las teclas */
}
    
    /* Hit Line */
    .hit-line {
      position: absolute;
      bottom: 122px;
      left: 0;
      right: 0;
      height: 2px;
      background: rgba(255, 0, 0, 1);
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
      z-index: 5;
      pointer-events: none;
    }
    
    /* MIDI Status */
    #midi-status {
      position: fixed;
      bottom: 120px;
      left: 20px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px 16px;
      border-radius: 8px;
      border: 1px solid #ccc;
      font-size: 13px;
      display: none;
      align-items: center;
      gap: 8px;
      backdrop-filter: blur(10px);
      z-index: 999;
    }
    
    #midi-status.connected {
      display: flex;
      border-color: #e74c3c;
    }
    
    #midi-status i {
      color: #e74c3c;
      font-size: 16px;
    }

    #note-display {
  position: fixed;
  top: 80px;
  left: 20px;
  background: rgba(255, 255, 255, 0.85);
  padding: 20px 30px;
  border-radius: 12px;
  border: 1px solid #ccc;
  backdrop-filter: blur(10px);
  z-index: 999;
  min-width: 180px;
}

#note-text {
  font-size: 32px;
  font-weight: 300;
  font-family: 'SF Pro Display', -apple-system, sans-serif;
  color: #333 !important;
  letter-spacing: 2px;
  text-align: center;
  display: block;
}



    #text-note-display {
      position: fixed;
      top: 80px;
      left: 20px;
      background: rgba(255, 255, 255, 0.85);
      padding: 20px 30px;
      border-radius: 12px;
      border: 1px solid #ccc;
      backdrop-filter: blur(10px);
      z-index: 999;
      min-width: 180px;
    }

    #note-text {
      font-size: 32px;
      font-weight: 300;
      font-family: 'SF Pro Display', -apple-system, sans-serif;
      color: #fff;
      letter-spacing: 2px;
      text-align: center;
      display: block;
    }

    /* Nuevo display de pentagrama a la derecha */
    #staff-display {
      position: fixed;
      top: 80px;
      right: 20px;
      background: rgba(255, 255, 255, 0.85);
      padding: 10px;
      border-radius: 12px;
      border: 1px solid #ccc;
      backdrop-filter: blur(10px);
      z-index: 999;
      height: 130px; /* Ajusta este valor seg√∫n necesites */
  overflow: hidden; 
    }

    #staff-svg {
      display: block;
      /* Ajustar tama√±o si es necesario */
    }

    /* Estilos para los elementos del pentagrama */
    .staff-line {
      stroke: #aaa;
      stroke-width: 1;
    }
    .ledger-line {
      stroke: #888;
      stroke-width: 1;
    }
    .note-head {
      fill: #333;
    }
    .note-accidental {
      fill: #333;
      font-size: 20px;
      font-family: serif;
    }
    .clef {
      fill: #333;
      font-size: 70px; /* Clave de Sol */
      font-family: serif;
    }
    .bass-clef {
      font-size: 40px; /* Clave de Fa */
    }
    
    /* Mobile Adjustments */
    @media (max-width: 768px) {
      #top-bar {
        padding: 10px 15px;
      }

      .clef{
        font-size: 45px;
      }
      
      .title {
        font-size: 16px;
      }
      
      .btn {
        padding: 6px 12px;
        font-size: 13px;
      }
      
      .key.white {
        width: 13px;
        height: 75px;
      }
      
      .key.black {
        width: 8px;
        height: 48px;
        margin-left: -4px;
        margin-right: -4px;
      }
    }
    
    @media (max-width: 500px) {
      .key.white {
        width: 11px;
        height: 65px;
      }
      
      .key.black {
        width: 7px;
        height: 42px;
      }
    }
  </style>
</head>
<body>

  <div id="top-bar">
    <div class="title">üéπ Free Play</div>
    <div class="controls">
      <button id="colorChange" class="btn" title="Selecciona color">
        <span>Azul</span>
      </button>
    </div>
  </div>

  <div id="note-display">
  <span id="note-text">---</span>
</div>

<div id="staff-display">
<svg id="staff-svg" width="200" height="150"></svg>
</div>

  <div id="midi-status">
    <i class="ri-plug-line"></i>
    <span id="midi-device-name">MIDI Conectado</span>
  </div>

  <div id="piano-container">
    <canvas id="waterfall-canvas"></canvas>
    <div id="piano-top-casing"></div>
    <div class="hit-line"></div>
    <div id="piano-keys"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>

  <script>
    // === VARIABLES GLOBALES ===
    const pianoKeys = document.getElementById('piano-keys');
    const waterfallCanvas = document.getElementById('waterfall-canvas');
    const waterfallCtx = waterfallCanvas.getContext('2d');
    const midiStatus = document.getElementById('midi-status');
    const midiDeviceName = document.getElementById('midi-device-name');
    const colorChangeBtn = document.getElementById('colorChange');
    const pianoTopCasing = document.getElementById('piano-top-casing');
    
    let sampler = null;
    let midiAccess = null;
    let showKeyNames = false;
    let whiteKeyWidth = 16;
    let blackKeyWidth = 10;
    let animationId = null;
    
    // Array para almacenar las notas activas y sus historias
    let activeNotes = {}; // { noteName: { startTime, xPos, isBlack, keyWidth } }
    let noteHistory = []; // Historial de notas completadas con duraci√≥n fija
    
    // Mapa para almacenar posiciones X de las teclas
    let keyPositions = {};
    let pianoStartX = 0;
    
    const pixelsPerSecond = 150;
    const fadeOutDuration = 3000; 


    const COLORS = {
      blue: {
        white: '52, 152, 219',  // #3498db (El azul que ya ten√≠as)
        black: '41, 128, 185',  // #2980b9
        name: 'Azul'
      },
      orange: {
        white: '221, 158, 55', // #DD9E37
        black: '187, 134, 47', // Un naranja m√°s oscuro
        name: 'Naranja'
      },
     red: { 
        white: '231, 76, 60',  // #e74c3c (Un rojo vivo, puedes ajustarlo si quieres otro)
        black: '192, 57, 43',  // #c0392b (Un rojo m√°s oscuro)
        name: 'Rojo' 
      }
    };

    let currentColorKey = 'blue';

    // === CONSTANTES PARA DETECCI√ìN DE ACORDES ===
 const NOTE_NAMES = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
 const CHORD_MAP = {
 '0,4,7': { name: 'Major', short: '' },
'0,3,7': { name: 'Minor', short: 'm' },
 '0,3,6': { name: 'Diminished', short: 'dim' },
'0,4,8': { name: 'Augmented', short: 'aug' },
'0,4,7,10': { name: 'Dominant 7th', short: '7' }, 
'0,4,7,11': { name: 'Major 7th', short: 'maj7' }, 
'0,3,7,10': { name: 'Minor 7th', short: 'm7' },
'0,3,6,9': { name: 'Diminished 7th', short: 'dim7' }, 
'0,3,6,10': { name: 'Half-Diminished 7th', short: 'm7b5' } 
};

const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
 const staffSvg = document.getElementById('staff-svg');
 const STAFF_LINE_GAP = 10; 
 const STAFF_Y_TOP = 40;

 const NOTE_STAFF_OFFSET = { 
'C': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'A': 5, 'B': 6 
 };
    
    // === INICIALIZACI√ìN ===
    document.addEventListener('DOMContentLoaded', async () => {
      createPiano88Keys();
      updateKeyDimensions();
      calculateKeyPositions();
      initSampler();
      initMidiInput();
      resizeWaterfallCanvas();
      startWaterfallAnimation();
      addEventListeners();

      document.body.classList.add('theme-blue');
      
      await Tone.loaded();
      console.log('Piano listo para tocar!');
    });
    
    // === SAMPLER (SONIDO DEL PIANO) ===
    function initSampler() {
      sampler = new Tone.Sampler({
                urls: { 
            "C1": "C1.mp3", "Eb1": "Ds1.mp3", "Gb1": "Fs1.mp3", "A1": "A1.mp3",
            "C2": "C2.mp3", "Eb2": "Ds2.mp3", "Gb2": "Fs2.mp3", "A2": "A2.mp3",
            "C3": "C3.mp3", "Eb3": "Ds3.mp3", "Gb3": "Fs3.mp3", "A3": "A3.mp3",
            "C4": "C4.mp3", "Eb4": "Ds4.mp3", "Gb4": "Fs4.mp3", "A4": "A4.mp3",
            "C5": "C5.mp3", "Eb5": "Ds5.mp3", "Gb5": "Fs5.mp3", "A5": "A5.mp3",
            "C6": "C6.mp3", "Eb6": "Ds6.mp3", "Gb6": "Fs6.mp3", "A6": "A6.mp3",
            "C7": "C7.mp3",
          },
        attack: 0.01,
        decay: 0.2,
        sustain: 0.3,
        release: 3.5,
        baseUrl: "https://tonejs.github.io/audio/salamander/"
      }).toDestination();
    }
    
    // === CREAR PIANO DE 88 TECLAS ===
    function createPiano88Keys() {
      pianoKeys.innerHTML = '';
      const pattern = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
      const blackKeys = { 'C': 'Db', 'D': 'Eb', 'F': 'Gb', 'G': 'Ab', 'A': 'Bb' };
      
      for (let octave = 0; octave <= 8; octave++) {
        const startNote = octave === 0 ? 9 : 0;
        
        for (let i = startNote; i <= 6; i++) {
          if (octave === 0 && i < 9) continue;
          if (octave === 8 && i > 0) break;
          
          const note = pattern[i % 7];
          const noteName = `${note}${octave}`;
          
          const whiteKey = document.createElement('div');
          whiteKey.className = 'key white';
          whiteKey.id = noteName;
          whiteKey.dataset.note = noteName;
          pianoKeys.appendChild(whiteKey);
          
          if (blackKeys[note] && !(octave === 8 && note === 'C')) {
            const blackNoteName = `${blackKeys[note]}${octave}`;
            const blackKey = document.createElement('div');
            blackKey.className = 'key black';
            blackKey.id = blackNoteName;
            blackKey.dataset.note = blackNoteName;
            pianoKeys.appendChild(blackKey);
          }
        }
      }
    }
    
    // === DIMENSIONES DE TECLAS ===
    function updateKeyDimensions() {
      const whiteKey = document.querySelector('.key.white');
      const blackKey = document.querySelector('.key.black');
      
      if (whiteKey) whiteKeyWidth = whiteKey.offsetWidth;
      if (blackKey) blackKeyWidth = blackKey.offsetWidth;
    }
    
    // === CALCULAR POSICIONES X DE TODAS LAS TECLAS ===
    function calculateKeyPositions() {
      keyPositions = {};
      const pianoKeysRect = pianoKeys.getBoundingClientRect();
      pianoStartX = pianoKeysRect.left;
      
      const allKeys = document.querySelectorAll('.key');
      allKeys.forEach(key => {
        const rect = key.getBoundingClientRect();
        const noteName = key.dataset.note;
        const isBlack = noteName.includes('b');
        const keyWidth = isBlack ? blackKeyWidth : whiteKeyWidth;
        
        keyPositions[noteName] = rect.left + (keyWidth / 2);
      });
      
      console.log('Posiciones calculadas:', Object.keys(keyPositions).length, 'teclas');
    }
    
    // === CANVAS WATERFALL ===
    function resizeWaterfallCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const container = document.getElementById('piano-container');
      
      waterfallCanvas.width = window.innerWidth * dpr;
      waterfallCanvas.height = (container.clientHeight - 142) * dpr;
      
      waterfallCanvas.style.width = `${window.innerWidth}px`;
      waterfallCanvas.style.height = `${container.clientHeight - 142}px`;
      
      setTimeout(() => {
        calculateKeyPositions();
      }, 100);
    }
    
    // === DIBUJAR WATERFALL ===
    function drawWaterfall() {
      const dpr = window.devicePixelRatio || 1;
      waterfallCtx.clearRect(0, 0, waterfallCanvas.width, waterfallCanvas.height);
      
      const currentTime = Date.now();
      const canvasHeight = waterfallCanvas.height / dpr;
      
      // Primero dibujar notas blancas del historial
      noteHistory.forEach(noteData => {
        if (noteData.isBlack) return;
        drawNote(noteData, currentTime, canvasHeight, dpr, true);
      });
      
      // Luego notas blancas activas
      for (let noteName in activeNotes) {
        const noteData = activeNotes[noteName];
        if (noteData.isBlack) continue;
        drawNote(noteData, currentTime, canvasHeight, dpr, false);
      }
      
      // Despu√©s notas negras del historial
      noteHistory.forEach(noteData => {
        if (!noteData.isBlack) return;
        drawNote(noteData, currentTime, canvasHeight, dpr, true);
      });
      
      // Finalmente notas negras activas
      for (let noteName in activeNotes) {
        const noteData = activeNotes[noteName];
        if (!noteData.isBlack) continue;
        drawNote(noteData, currentTime, canvasHeight, dpr, false);
      }
      
      // Limpiar notas del historial que ya se desvanecieron
      noteHistory = noteHistory.filter(note => {
        const timeSinceRelease = currentTime - note.releaseTime;
        return timeSinceRelease < fadeOutDuration;
      });
      
      waterfallCtx.shadowBlur = 0;
    }
    
    function drawNote(noteData, currentTime, canvasHeight, dpr, isHistory) {
      const xPos = noteData.xPos;
      const keyWidth = noteData.keyWidth;
      
      let height, yPosition, opacity;
      
      if (isHistory) {
        // Nota liberada - altura fija con fade out
        const duration = noteData.duration / 1000;
        height = Math.min(duration * pixelsPerSecond, canvasHeight);
        
        const timeSinceRelease = currentTime - noteData.releaseTime;
        const fadeProgress = timeSinceRelease / fadeOutDuration;
        opacity = Math.max(0, 1 - fadeProgress);
        
        // Contin√∫a subiendo mientras se desvanece
       const scrollAmount = (timeSinceRelease / 1000) * pixelsPerSecond;
        yPosition = canvasHeight - height - scrollAmount;
        
      } else {
        // Nota activa - creciendo
        const elapsedTime = (currentTime - noteData.startTime) / 1000;
        height = Math.min(elapsedTime * pixelsPerSecond, canvasHeight);
        yPosition = canvasHeight - height;
        opacity = 1;
      }
      
      if (yPosition + height < 0) return; // Fuera de la pantalla
      
      // Gradiente con opacidad
      const gradient = waterfallCtx.createLinearGradient(
        xPos * dpr, 
        (yPosition + height) * dpr, 
        xPos * dpr, 
        yPosition * dpr
      );
      
      const currentPalette = COLORS[currentColorKey];

      if (noteData.isBlack) {
        gradient.addColorStop(0, `rgba(${currentPalette.black}, ${0.9 * opacity})`);
        gradient.addColorStop(1, `rgba(${currentPalette.black}, ${0.3 * opacity})`);
        waterfallCtx.shadowColor = `rgba(${currentPalette.black}, ${0.7 * opacity})`;
      } else {
        gradient.addColorStop(0, `rgba(${currentPalette.white}, ${0.8 * opacity})`);
        gradient.addColorStop(1, `rgba(${currentPalette.white}, ${0.2 * opacity})`);
        waterfallCtx.shadowColor = `rgba(${currentPalette.white}, ${0.6 * opacity})`;
      }
      
      waterfallCtx.fillStyle = gradient;
      waterfallCtx.shadowBlur = 15 * dpr * opacity;
      
      waterfallCtx.fillRect(
        (xPos - keyWidth / 2) * dpr,
        yPosition * dpr,
        keyWidth * dpr,
        height * dpr
      );
    }
    
    // === ANIMACI√ìN CONTINUA ===
    function startWaterfallAnimation() {
      function animate() {
        drawWaterfall();
        animationId = requestAnimationFrame(animate);
      }
      animate();
    }
    
    // === TOCAR NOTA (NOTE ON) ===
    function noteOn(noteName, source = 'click') {
      // Solo crear si no existe ya
      if (activeNotes[noteName]) return;
      
      // Activar sonido
      sampler.triggerAttack(noteName);
      
      const keyElement = document.getElementById(noteName);
      if (keyElement) {
        keyElement.classList.add('active');
      }

      // --- NUEVO: A√±adir etiqueta a la carcasa superior ---
      const noteLabel = document.createElement('div');
      noteLabel.className = 'casing-note-label'; // Usaremos una nueva clase
      noteLabel.id = 'label-' + noteName; // ID √∫nico para encontrarlo y borrarlo
      noteLabel.textContent = getNoteNameSimple(noteName);
      
      // Usamos la posici√≥n X pre-calculada de la tecla
      const xPos = keyPositions[noteName]; 
      noteLabel.style.left = `${xPos}px`;
      
      pianoTopCasing.appendChild(noteLabel);
          

      const isBlack = noteName.includes('#');
      const keyWidth = isBlack ? blackKeyWidth - 2 : whiteKeyWidth - 2;
      
      activeNotes[noteName] = {
        startTime: Date.now(),
        xPos: xPos,
        isBlack: isBlack,
        keyWidth: keyWidth
      };
      
      updateNoteDisplay();
    }
    
    // === SOLTAR NOTA (NOTE OFF) ===
    function noteOff(noteName, source = 'click') {
      if (!activeNotes[noteName]) return;
      
      // Detener sonido
      sampler.triggerRelease(noteName);
      
      const keyElement = document.getElementById(noteName);
          if (keyElement) {
            keyElement.classList.remove('active');
          }

          // --- NUEVO: Eliminar etiqueta de la carcasa ---
          const existingLabel = document.getElementById('label-' + noteName);
          if (existingLabel) {
            existingLabel.remove();
          }
              
      // Mover a historial con duraci√≥n fija
      const noteData = activeNotes[noteName];
      noteData.releaseTime = Date.now();
      noteData.duration = noteData.releaseTime - noteData.startTime;
      
      noteHistory.push(noteData);
      delete activeNotes[noteName];
      
      updateNoteDisplay();
    }
    
    // === MIDI INPUT ===
    function initMidiInput() {
      if (navigator.requestMIDIAccess) {
        navigator.requestMIDIAccess()
          .then(onMIDISuccess, onMIDIFailure);
      }
    }
    
    function onMIDISuccess(access) {
      midiAccess = access;
      
      access.onstatechange = (event) => {
        if (event.port.type === 'input') {
          if (event.port.state === 'connected') {
            event.port.onmidimessage = onMIDIMessage;
            midiDeviceName.textContent = event.port.name;
            midiStatus.classList.add('connected');
            console.log(`üéπ MIDI conectado: ${event.port.name}`);
          } else {
            midiStatus.classList.remove('connected');
          }
        }
      };
      
      const inputs = access.inputs.values();
      for (const input of inputs) {
        if (input.state === 'connected') {
          input.onmidimessage = onMIDIMessage;
          midiDeviceName.textContent = input.name;
          midiStatus.classList.add('connected');
        }
      }
    }
    
    function onMIDIFailure() {
      console.warn('‚ö†Ô∏è No se pudo acceder a MIDI');
    }
    
    function onMIDIMessage(event) {
      const command = event.data[0];
      const note = event.data[1];
      const velocity = event.data.length > 2 ? event.data[2] : 0;
      
      const pitchName = midiNoteToPitchName(note);
      
      if (command === 144 && velocity > 0) {
        // NOTE ON
        noteOn(pitchName, 'MIDI');
        highlightMidiKey(pitchName);
      } else if (command === 128 || (command === 144 && velocity === 0)) {
        // NOTE OFF
        noteOff(pitchName, 'MIDI');
        unhighlightMidiKey(pitchName);
      }
    }
    
    function midiNoteToPitchName(midiNote) {
      const noteNames = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
      const octave = Math.floor(midiNote / 12) - 1;
      const noteName = noteNames[midiNote % 12];
      return noteName + octave;
    }
    
    function highlightMidiKey(noteName) {
      const el = document.getElementById(noteName);
      if (el) el.classList.add('active');
    }
    
    function unhighlightMidiKey(noteName) {
      const el = document.getElementById(noteName);
      if (el) el.classList.remove('active');
    }
    


    // Mapeo de n√∫meros MIDI a nombres de notas
function getNoteNameSimple(noteName) {
  return noteName.replace(/[0-9]/g, ''); // Quita el n√∫mero de octava
}

// Calcular intervalo entre dos notas
function getInterval(note1, note2) {
  const intervals = ['Unison', 'Minor 2nd', 'Major 2nd', 'Minor 3rd', 
 'Major 3rd', 'Perfect 4th', 'Tritone', 'Perfect 5th',
 'Minor 6th', 'Major 6th', 'Minor 7th', 'Major 7th', 'Octave'];
  
  const midi1 = noteNameToMidi(note1);
  const midi2 = noteNameToMidi(note2);
  const semitones = Math.abs(midi2 - midi1) % 12;
  
  return intervals[semitones] || 'Interval';
}

// Convertir nombre de nota a MIDI
function noteNameToMidi(noteName) {
  const noteMap = { 'C': 0, 'Db': 1, 'D': 2, 'Eb': 3, 'E': 4, 'F': 5, 
                    'Gb': 6, 'G': 7, 'Ab': 8, 'A': 9, 'Bb': 10, 'B': 11 };
  const match = noteName.match(/^([A-G]b?)(\d+)$/);
  if (!match) return 0;
  const [, note, octave] = match;
  return (parseInt(octave) + 1) * 12 + noteMap[note];
}

// Detectar acorde
function getChordName(notes) {
  if (notes.length < 3) return null;

  // 1. Obtener n√∫meros MIDI y ordenarlos para encontrar el bajo
  const midis = notes.map(noteNameToMidi).sort((a, b) => a - b);
  
  // 2. Obtener la nota m√°s grave (el bajo)
  const bassNoteMidi = midis[0];
  const bassNoteName = NOTE_NAMES[bassNoteMidi % 12];
  
  // 3. Obtener "clases de nota" √∫nicas (n√∫meros 0-11)
  // Esto maneja el "espaciamiento" (voicings) en diferentes octavas
  const pitchClasses = [...new Set(midis.map(m => m % 12))];

  // 4. Probar cada una de las 12 notas como posible t√≥nica (root)
  for (let i = 0; i < 12; i++) {
    const potentialRoot = i;
    
    // 5. Calcular los intervalos desde esta t√≥nica potencial
    const intervals = pitchClasses
      .map(pc => (pc - potentialRoot + 12) % 12) // (pc - root) mod 12
      .sort((a, b) => a - b);
    
    // 6. Crear una "firma" (signature) de los intervalos (ej: "0,4,7")
    const signature = intervals.join(',');
    
    // 7. Buscar esta firma en nuestro mapa de acordes
    const chordInfo = CHORD_MAP[signature];
    
    if (chordInfo) {
      // ¬°Encontramos un acorde!
      const rootNoteName = NOTE_NAMES[potentialRoot];
      
      // 8. Comprobar si es una inversi√≥n
      if (rootNoteName === bassNoteName) {
        // Posici√≥n fundamental (ej: C, E, G -> "C")
        return rootNoteName + chordInfo.short;
      } else {
        // Inversi√≥n (ej: E, G, C -> "C/E")
        return rootNoteName + chordInfo.short + '/' + bassNoteName;
      }
    }
  }

  // No se encontr√≥ ning√∫n acorde conocido
  return null;
}

// Actualizar el display
function updateNoteDisplay() {
  const noteText = document.getElementById('note-text');
  const activeNoteNames = Object.keys(activeNotes);
  
  if (activeNoteNames.length === 0) {
    noteText.textContent = '-';
  } else if (activeNoteNames.length === 1) {
    noteText.textContent = getNoteNameSimple(activeNoteNames[0]);
  } else if (activeNoteNames.length === 2) {
    const interval = getInterval(activeNoteNames[0], activeNoteNames[1]);
    noteText.textContent = interval;
  } else {
    const chord = getChordName(activeNoteNames);
    noteText.textContent = chord;
  }

  if (activeNoteNames.length > 0) {
    drawNotesOnStaff(activeNoteNames);
     } else {
    clearStaff();
    drawStaffLines();
    drawClef(true); 
    }
}



// === L√ìGICA DE DIBUJO DEL PENTAGRAMA ===

  function createSvgElement(name, attributes) {
    const el = document.createElementNS(SVG_NAMESPACE, name);
    for (let key in attributes) {
      el.setAttribute(key, attributes[key]);
    }
    return el;
  }

  // Limpia el pentagrama
  function clearStaff() {
    staffSvg.innerHTML = '';
  }

  // Dibuja las 5 l√≠neas del pentagrama
  function drawStaffLines() {
    for (let i = 0; i < 5; i++) {
      const y = STAFF_Y_TOP + (i * STAFF_LINE_GAP);
      const line = createSvgElement('line', {
        x1: 10, y1: y, x2: 190, y2: y,
        class: 'staff-line'
      });
      staffSvg.appendChild(line);
    }
  }

  // Dibuja la clave (Sol o Fa)
  function drawClef(isTreble) {
    if (isTreble) {
      // Clave de Sol ùÑû (G-Clef)
      const clef = createSvgElement('text', {
        x: 15, y: STAFF_Y_TOP + STAFF_LINE_GAP * 3 + 4, // Centrada en la l√≠nea G4
        class: 'clef'
      });
      clef.textContent = 'ùÑû';
      staffSvg.appendChild(clef);
    } else {
      // Clave de Fa ùÑ¢ (F-Clef)
      const clef = createSvgElement('text', {
        x: 15, y: STAFF_Y_TOP + STAFF_LINE_GAP + 14, // Centrada en la l√≠nea F3
        class: 'clef bass-clef'
      });
      clef.textContent = 'ùÑ¢';
      staffSvg.appendChild(clef);
    }
  }

  // Dibuja una sola nota en el pentagrama
  function drawSingleNote(midi, xPos, isTreble) {
    const octave = Math.floor(midi / 12) - 1;
    const noteIndex = midi % 12;
    const noteName = NOTE_NAMES[noteIndex];
    const noteLetter = noteName[0];
    const hasAccidental = noteName.includes('b');
    
let yBase, refMidi, refSteps;

if (isTreble) {
  // Treble: B4 est√° en la l√≠nea del medio (3era l√≠nea)
  yBase = STAFF_Y_TOP + (STAFF_LINE_GAP * 2); // L√≠nea del medio
  refMidi = 71; // B4
  refSteps = (4 * 7) + NOTE_STAFF_OFFSET['B'];
} else {
  // Bass: D3 est√° en la l√≠nea del medio (3era l√≠nea)
  yBase = STAFF_Y_TOP + (STAFF_LINE_GAP * 2);
  refMidi = 50; // D3
  refSteps = (3 * 7) + NOTE_STAFF_OFFSET['D'];
}

const note_steps = (octave * 7) + NOTE_STAFF_OFFSET[noteLetter];
const steps_from_ref = note_steps - refSteps;

// Calcular Y: cada "paso" musical baja medio espacio (GAP/2)
const y = yBase - (steps_from_ref * (STAFF_LINE_GAP / 2));
    
    // 3. Dibujar alteraci√≥n (sostenido/bemol) si es necesario
    if (hasAccidental) {
      const accidental = createSvgElement('text', {
        x: xPos - 28, // Un poco a la izquierda de la nota
        y: y + 5, // Alinear verticalmente
        class: 'note-accidental'
      });
      accidental.textContent = '‚ô≠';
      staffSvg.appendChild(accidental);
    }
    
    // 4. Dibujar la cabeza de la nota
    const noteHead = createSvgElement('ellipse', {
      cx: xPos, cy: y, rx: 7, ry: 5, // √ìvalo
      class: 'note-head'
    });
    staffSvg.appendChild(noteHead);
    
    // 5. Dibujar l√≠neas adicionales (ledger lines)
    // Si est√° por encima de F5 (y=20) o por debajo de E4 (y=60) en Clave de Sol
    const trebleTopLineY = STAFF_Y_TOP; // F5
    const trebleBottomLineY = STAFF_Y_TOP + (STAFF_LINE_GAP * 4); // E4
    
    // L√≠neas adicionales abajo (C4, A3, etc.)
    for (let yLedger = trebleBottomLineY + STAFF_LINE_GAP; yLedger <= y; yLedger += STAFF_LINE_GAP) {
      drawLedgerLine(xPos, yLedger);
    }
    // L√≠neas adicionales arriba (A5, C6, etc.)
    for (let yLedger = trebleTopLineY - STAFF_LINE_GAP; yLedger >= y; yLedger -= STAFF_LINE_GAP) {
      drawLedgerLine(xPos, yLedger);
    }
  }

  function drawLedgerLine(x, y) {
    const line = createSvgElement('line', {
      x1: x - 12, y1: y, x2: x + 12, y2: y, // Corta
      class: 'ledger-line'
    });
    staffSvg.appendChild(line);
  }

  // Funci√≥n principal que orquesta el dibujo
  function drawNotesOnStaff(notes) {
    clearStaff();
    drawStaffLines();

    const midis = notes.map(noteNameToMidi).sort((a, b) => a - b);
    if (midis.length === 0) return;

    // Decidir la clave: Si la nota M√ÅS BAJA es C4 (60) o m√°s, usa Clave de Sol.
    // Si es B3 (59) o menos, usa Clave de Fa.
    const lowestMidi = midis[0];
    const useTrebleClef = lowestMidi >= 60; 
    
    drawClef(useTrebleClef);
    
let xPos = 90; // Posici√≥n X inicial para la primera nota

midis.forEach((midi, index) => {
  // Calcular si esta nota necesita desfase (es una 2da respecto a la anterior)
  let needsOffset = false;
  
  if (index > 0) {
    const prevMidi = midis[index - 1];
    const interval = Math.abs(midi - prevMidi);
    
    // Si es una 2da (1 o 2 semitonos), esta nota se desfasa
    if (interval === 1 || interval === 2) {
      needsOffset = true;
    }
  }
  
  // Dibujar la nota en xPos base o con offset
  const noteXPos = needsOffset ? xPos - 12 : xPos;
  drawSingleNote(midi, noteXPos, useTrebleClef);
});
  }
    
    function showKeyNamesOnPiano() {
      const whiteKeys = document.querySelectorAll('.key.white');
      whiteKeys.forEach(key => {
        const nameElement = document.createElement('div');
        nameElement.className = 'key-name';
        nameElement.textContent = key.dataset.note;
        key.appendChild(nameElement);
      });
    }
    
    function hideKeyNamesOnPiano() {
      const keyNames = document.querySelectorAll('.key-name');
      keyNames.forEach(el => el.remove());
    }
    
    // === EVENT LISTENERS ===
    function addEventListeners() {
      // Mouse down/up en teclas
      pianoKeys.addEventListener('mousedown', async (e) => {
        await Tone.start();
        if (e.target.classList.contains('key')) {
          const noteName = e.target.dataset.note;
          noteOn(noteName, 'mouse');
        }
      });
      
      pianoKeys.addEventListener('mouseup', (e) => {
        if (e.target.classList.contains('key')) {
          const noteName = e.target.dataset.note;
          noteOff(noteName, 'mouse');
        }
      });
      
      // Soltar mouse fuera del piano
      document.addEventListener('mouseup', () => {
        // Liberar todas las notas activas del mouse
        for (let noteName in activeNotes) {
          noteOff(noteName, 'mouse-release');
        }
      });


     colorChangeBtn.addEventListener('click', () => {
      let newColorKey = 'blue'; // Almacena la *pr√≥xima* clave de color

      // Determina el siguiente color
      if (currentColorKey === 'blue') {
        newColorKey = 'orange';
      } else if (currentColorKey === 'orange') {
        newColorKey = 'red';
      } else {
        newColorKey = 'blue';
      }

      // 1. Actualiza la clase del body para cambiar el CSS
      document.body.classList.remove('theme-blue', 'theme-orange', 'theme-red');
      document.body.classList.add('theme-' + newColorKey);

      // 2. Actualiza la variable de JS (para el waterfall)
      currentColorKey = newColorKey;

      // 3. Actualiza el texto del bot√≥n
      const colorName = COLORS[currentColorKey].name;
      colorChangeBtn.querySelector('span').textContent = colorName;
    });
      

      
      // Redimensionar
      window.addEventListener('resize', () => {
        updateKeyDimensions();
        resizeWaterfallCanvas();
      });
      

      const keyMap = {
          'a': 'C4', 'w': 'Db4', 's': 'D4', 'e': 'Eb4', 'd': 'E4',
          'f': 'F4', 't': 'Gb4', 'g': 'G4', 'y': 'Ab4', 'h': 'A4',
          'u': 'Bb4', 'j': 'B4', 'k': 'C5', 'o': 'Db5', 'l': 'D5'
        };
      
      const keysPressed = {};
      
      document.addEventListener('keydown', async (e) => {
        if (keysPressed[e.key]) return; // Evitar repetici√≥n
        
        await Tone.start();
        if (keyMap[e.key]) {
          keysPressed[e.key] = true;
          noteOn(keyMap[e.key], 'keyboard');
        }
      });
      
      document.addEventListener('keyup', (e) => {
        if (keyMap[e.key]) {
          keysPressed[e.key] = false;
          noteOff(keyMap[e.key], 'keyboard');
        }
      });
    }
  </script>
</body>
</html>
