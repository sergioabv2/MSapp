
<html lang="es"> 
<head> 
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Reproductor MusicXML</title>
   <link href="https://cdn.jsdelivr.net/npm/remixicon@4.5.0/fonts/remixicon.css" rel="stylesheet"/>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #fafafa;
      color: #1a1a1a;
      padding-bottom: 140px;
    }
    
    /* Top Bar - Minimalista */
    #top-bar {
      background: #fff;
      border-bottom: 1px solid #e0e0e0;
      padding: 10px 20px;
      position: sticky;
      top: 0;
      z-index: 1000;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    }
    

    
    #song-title {
      font-size: 14px;
      font-weight: 600;
      color: #1a1a1a;
    }
    
    #song-composer {
      font-size: 12px;
      color: #999;
    }
 
    
    .btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 6px;
      border-radius: 4px;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .btn:hover:not(:disabled) {
      background: #f5f5f5;
    }
    
    .btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    
    .btn svg {
      width: 20px;
      height: 20px;
      fill: #1a1a1a;
    }

    .btn i {
      font-size: 20px;
      fill: #1a1a1a;
    }
    
    /* Progress Bar */
   /* AÑADE ESTE NUEVO BLOQUE DE CSS */




/* Posiciona el slider en la parte inferior de la barra superior */
#progress-bar {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  -webkit-appearance: none;
  appearance: none;
  height: 3px; /* Grosor de la barra */
  background: transparent;
  outline: none;
  cursor: pointer;
  margin: 0;
  padding: 0;
  /* Variable CSS personalizada para el progreso */
  --progress: 0%; /* Valor inicial */
}

/* Estilo para el "thumb" (el círculo que se arrastra) */
#progress-bar::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 12px; /* Tamaño del thumb */
  height: 12px;
  background: #3498db; /* Color del thumb */
  border-radius: 50%;

  box-shadow: 0 0 4px rgba(0,0,0,0.4);
  margin-top: -4px; /* Centra el thumb verticalmente en la barra */
}

#progress-bar::-moz-range-thumb {
  width: 15px;
  height: 15px;
  background: #3498db;
  border-radius: 50%;
  border: 2px solid white;
  box-shadow: 0 0 4px rgba(0,0,0,0.4);
}

/* Estilo para el "track" (la barra completa) */
/* Para navegadores WebKit: usa un gradiente para simular el progreso */
#progress-bar::-webkit-slider-runnable-track {
  width: 100%;
  height: 3px;
  background: linear-gradient(to right, #3498db 0%, #3498db var(--progress), #e0e0e0 var(--progress), #e0e0e0 100%);
  border-radius: 5px; /* Opcional: para que los bordes del track sean suaves */
}

/* Para Firefox: usa la pseudo-clase estándar */
#progress-bar::-moz-range-track {
  width: 100%;
  height: 3px;
  background: #e0e0e0; /* Color de la barra no reproducida (fondo blanco) */
  border-radius: 5px; /* Opcional */
}

#progress-bar::-moz-range-progress {
  background: #3498db; /* Color azul para la parte reproducida */
  height: 3px;
  border-radius: 5px; /* Opcional */
}
  
    
   
    
    /* Piano - 88 Keys Minimalista */
    #piano-container {
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100%;
      background: #fff;
      padding: 12px 0;
      overflow-x: auto;
      overflow-y: hidden;
      box-shadow: 0 -1px 3px rgba(0,0,0,0.08);
      border-top: 1px solid #e0e0e0;
      transition: transform 0.3s ease;
    }
    
    #piano-container.hidden {
      transform: translateY(100%);
    }
    
    #piano-keys {
      display: flex;
      justify-content: center;
      min-width: 100%;
      padding: 0 10px;
    }
    
    .key {
      border: 1px solid #ddd;
      position: relative;
      transition: all 0.05s;
    }
    
    .key.white {
      width: 16px;
      height: 90px;
      background: #fff;
      border-right: 1px solid #e0e0e0;
    }
    
    .key.black {
      width: 10px;
      height: 58px;
      background: #1a1a1a;
      margin-left: -5px;
      margin-right: -5px;
      z-index: 2;
    }
    
    .key.active-treble {
  background: #3498db !important; /* Azul para la mano derecha (treble) */
  box-shadow: 0 0 8px rgba(52, 152, 219, 0.6) !important;
}

.key.active-bass {
  background: #de9e37 !important; /* Verde para la mano izquierda (bass) */
  box-shadow: 0 0 8px rgba(222, 158, 55, 0.6) !important;
}
    
    #status {
      text-align: center;
      padding: 40px 20px;
      color: #999;
      font-size: 13px;
    }
    
   

#osmd-container {
  width: 95%; 
  max-width: 900px; 
  margin: 20px auto;
  border: 1px solid #ddd;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
  border-radius: 3px;
  box-sizing: border-box;
  overflow: hidden; /* Asegura que el contenido SVG respete los bordes redondeados */
}




@media (min-width: 830px) {
  #osmd-container {
    width: 85%;
  }
}


/* Ajustes para Desktop */
@media (min-width: 1100px) {
  #osmd-container {
    width: 70%;
  }
}
  

.speed-group {
    display: flex;
    align-items: center;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    background-color: #fff;
    box-shadow: 0 1px 2px rgba(0,0,0,0.04);
}

.speed-ctrl-btn {
    font-size: 20px;
    font-weight: 500;
    padding: 4px 12px;
    line-height: 1;
    border-radius: 0; /* Quitamos bordes individuales */
    background-color: transparent;
}
.speed-ctrl-btn:hover:not(:disabled) {
    background-color: #f5f5f5;
}

.speed-display {

    text-align: center;
    min-width: 50px;
    border-left: 1px solid #e0e0e0;
    border-right: 1px solid #e0e0e0;
}

.speed-bpm {
    font-size: 14px;
    font-weight: 600;
    display: block;
    color: #1a1a1a;
}

.speed-value {
    font-size: 11px;
    color: #999;
    display: block;
    margin-top: 2px;
}
#annotation-canvas {
height: 100%;
width: 100vw;
}

/* === Reestructuración Top Bar === */
.controls-group {
  display: flex;
  align-items: center;
  gap: 16px; /* Espacio entre elementos dentro de un grupo */
}

/* === NUEVO: Contador de Tiempo === */
#time-display {
  font-size: 13px;
  color: #555;
  font-family: 'SF Mono', 'Menlo', 'monospace'; /* Letra monoespaciada para números */
  background-color: #f5f5f5;
  padding: 8px 12px;
  border-radius: 6px;
  border: 1px solid #e0e0e0;
}

/* === NUEVO: Controles de Zoom Rediseñados (estilo de la imagen) === */
#zoom-controls {
  display: flex;
  align-items: center;
  background-color: #f9f9f9;
  border-radius: 8px;
  border: 1px solid #e0e0e0;
  overflow: hidden; 
  box-shadow: 0 1px 2px rgba(0,0,0,0.03);
}

#zoom-controls .zoom-display {
  padding: 6px 14px;
  font-size: 13px;
  font-weight: 500;
  color: #333;
}

#zoom-controls .zoom-buttons {
  display: flex;
}

#zoom-controls .zoom-btn {
  background-color: #fff;
  border: none;
  border-left: 1px solid #e0e0e0; /* Línea divisora */
  padding: 6px 12px;
  font-size: 16px;
  line-height: 1;
  border-radius: 0;
  cursor: pointer;
  transition: background-color 0.2s;
}

#zoom-controls .zoom-btn:hover {
  background-color: #f0f0f0;
}

/* === NUEVO: Espacio para botón Cerrar === */
#close-btn-placeholder {
  width: 40px; /* Ancho para el espacio reservado */
  height: 40px;
}

/* === NUEVO: Botones Flotantes de Dibujo === */
#floating-draw-controls {
  position: sticky;
  bottom: 105px;
  float: right;
  margin-right: 10px;
  z-index: 50;
  width: 90px;
  display: flex;
  flex-direction: row; /* Apila los botones verticalmente */
  gap: 5px;
  background-color: rgba(255, 255, 255, 0.85); /* Fondo semitransparente */
  padding: 8px;
  border-radius: 10px;
  border: 1px solid #e0e0e0;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  backdrop-filter: blur(8px); /* Efecto "glassmorphism" para navegadores compatibles */
}

    /* === NUEVO: Controles de Velocidad Flotantes === */
#floating-speed-controls {
  position: sticky;
  width: 145px;
  bottom: 105px;
  display: none;
  left: 10px; /* Lo posicionamos a la izquierda para balancear la UI */
  z-index: 50;
  background-color: rgba(255, 255, 255, 0.85);
  padding: 8px;
  border-radius: 10px;
  border: 1px solid #e0e0e0;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  backdrop-filter: blur(8px);
}

/* Ajustes a los botones flotantes */
#floating-draw-controls .btn:hover {
  background-color: #e9e9e9;
}



#measure-select {
  -webkit-appearance: none; /* Quita el estilo por defecto en Safari/Chrome */
  -moz-appearance: none; 
  appearance: none;
  background-color: white;
 border-radius: 6px;
  border: 1px solid #e0e0e0;
  font-size: 13px;
  font-weight: 500;
  height: 30px;
  color: #1a1a1a;
  padding: 2px 8px;
  cursor: pointer;
}

#measure-select:hover {
  background-color: rgba(0,0,0,0.05);
}




/* === NUEVO: Barra de Herramientas Secundaria === */
#secondary-top-bar {

display: flex;
  background-color: #f9f9f9;
  border-bottom: 1px solid #e0e0e0;
 padding: 0px 15px;
 top: 60px;
   position: sticky ;
   z-index: 999;
     align-items: center; 
  justify-content: space-between;
  gap: 16px;
  overflow: hidden; /* Clave para la animación de despliegue */
  max-height: 0; /* Estado inicial: colapsada */
  transition: max-height 0.3s ease-out, padding 0.3s ease-out; /* Animación suave */
}

/* Estado visible de la barra secundaria */
#secondary-top-bar.is-visible {

  max-height: 35px; /* Altura suficiente para los botones */
  padding: 4px 15px; /* Restaura el padding vertical */
}

.tool-group {
  display: flex;
  align-items: center;
  gap: 16px; /* Espacio entre los elementos de cada grupo */
}


 /* Mobile adjustments - ESCALADO PARA MÓVILES */
    @media (max-width: 768px) {
   
      
      /* Aplicamos zoom automático en móviles */
      .mobile-zoom {
        transform: scale(0.85);
        transform-origin: top center;
      }
      
      .key.white {
        width: 13px;
        height: 75px;
      }
      
      .key.black {
        width: 8px;
        height: 48px;
        margin-left: -4px;
        margin-right: -4px;
      }
      
   
    }
    
    @media (max-width: 500px) {
      #top-bar {
        padding: 8px 12px;
      }

      #floating-speed-controls{
        display: flex !important;
      }

      .mobile-zoom {
        transform: scale(0.75);
        transform-origin: top center;
      }

      #tools-toggle-btn,
  #secondary-top-bar {
    display: none; 
  }
  }

   @media (max-width: 440px) {
       #time-display{
        display: none;
      }
   }


/* --- CSS CORRECTO PARA EL COLOR PICKER HORIZONTAL --- */

/* Contenedor del selector de color completo (círculo + opciones) */
#color-picker-container {
  display: flex;
  align-items: center;
  background-color: #f0f0f0;
  border-radius: 18px; /* Bordes redondeados para el contenedor */
  padding: 4px;
  transition: all 0.3s ease-in-out;
  /* Importante: quitamos position: relative que ya no es necesario */
}

/* El círculo que muestra el color actual */
#color-preview-circle {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid #666;
  background-color: rgba(255, 223, 89, 0.4);
  cursor: pointer;
  flex-shrink: 0; /* Evita que el círculo se encoja */
}

/* Contenedor de las opciones de color (el que modificamos) */
#color-options {
  display: flex;
  align-items: center;
  gap: 8px;
  
  /* ESTADO OCULTO INICIAL (sin display:none) */
  max-width: 0;
  opacity: 0;
  overflow: hidden;
  transition: max-width 0.3s ease-in-out, opacity 0.2s linear, margin-left 0.3s ease-in-out;
  margin-left: 0;
  /* Eliminamos position: absolute y todo lo relacionado a eso */
}

/* ESTADO ABIERTO: Cuando el contenedor tiene la clase 'is-open' */
#color-picker-container.is-open #color-options {
  max-width: 200px; /* Ancho suficiente para mostrar todo */
  opacity: 1;
  margin-left: 8px; /* Espacio entre el círculo y las opciones */
}

/* Muestras de color y el input (sin cambios, pero se incluyen por completitud) */
.color-swatch {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  cursor: pointer;
  border: 1px solid #ddd;
  transition: transform 0.2s ease;
  flex-shrink: 0;
}

.color-swatch:hover {
  transform: scale(1.15);
  border: 2px solid #3498db;
}

#custom-color-input {
  width: 28px;
  height: 28px;
  border: none;
  padding: 0;
  background: none;
  cursor: pointer;
  border-radius: 50%;
  flex-shrink: 0;
}

/* === NUEVO: Estilos para el Modal MIDI === */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000; /* Asegura que esté por encima de todo */
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

/* Estado visible del modal */
.modal-overlay.is-visible {
  opacity: 1;
  pointer-events: auto;
}

.modal-content {
  background: #fff;
  padding: 25px 30px;
  border-radius: 12px;
  box-shadow: 0 5px 20px rgba(0,0,0,0.2);
  text-align: center;
  max-width: 320px;
  transform: scale(0.9);
  transition: transform 0.3s ease;
}

.modal-overlay.is-visible .modal-content {
  transform: scale(1);
}

#modal-message {
  font-size: 15px;
  color: #333;
  line-height: 1.5;
  margin-bottom: 20px;
}

#modal-close-btn {
  background-color: #3498db;
  color: white;
  padding: 10px 20px;
  border-radius: 8px;
  font-weight: 500;
  transition: background-color 0.2s;
}

#modal-close-btn:hover {
  background-color: #2980b9;
}
  </style>
</head>
<body>

  <div id="top-bar">
    <div class="controls-group">
      <button id="play-btn" class="btn" disabled>
        <svg id="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
        <svg id="pause-icon" viewBox="0 0 24 24" style="display:none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
      </button>

      <div id="time-display">
        <span id="current-time">0:00</span> / <span id="total-time">0:00</span>
      </div>
    </div>

    <div class="controls-group">
      <button id="midi-learn-btn" class="btn" title="Modo Aprendizaje MIDI">
  <i class="ri-plug-line"></i>
</button>
        <button id="tools-toggle-btn" class="btn" title="Herramientas de Dibujo">
        <i class="ri-edit-2-line"></i>
      </button>

          <button id="piano-btn" class="btn" >
       <img src="https://lh3.googleusercontent.com/d/1vMHUODAn781r96RNhefO3HWZrqtMM_0u=s96-c" style="height: 18.5px; width: 17.5px">
      </button>

      <div id="zoom-controls">
         <div class="speed-display">
        <span class="zoom-display" id="speed-bpm">120 BPM</span>
  <span class="speed-value" id="speed-label">1.00x</span>
   </div>
        <div class="zoom-buttons">
            <button class="zoom-btn" id="speed-down-btn">−</button>
            <button class="zoom-btn" id="speed-up-btn">+</button>
        </div>
      </div>
      <div id="close-btn-placeholder"></div>
    </div>

    <input type="range" id="progress-bar" value="0" min="0" max="100" step="0.1">
  </div>

   <div id="secondary-top-bar">
    <div class="tool-group">
     <div id="color-picker-container" class="btn" title="Seleccionar Color">
  <div id="color-preview-circle"></div>
  
  <div id="color-options">
    <div class="color-swatch" style="background-color: rgba(255, 223, 89, 0.4);" data-color="rgba(255, 223, 89, 0.4)"></div>
    <div class="color-swatch" style="background-color: rgba(255, 0, 255, 0.4);" data-color="rgba(255, 0, 255, 0.4)"></div>
    <div class="color-swatch" style="background-color: rgba(46, 204, 113, 0.4);" data-color="rgba(46, 204, 113, 0.4)"></div>
    <input type="color" id="custom-color-input" value="#ffdf59" title="Color personalizado">
  </div>
</div>
    <button id="draw-btn" class="btn" title="Activar Lápiz">
     <i class="ri-shape-line"></i>
    </button>
    <button id="text-btn" class="btn" title="Añadir Texto">
      <i class="ri-text-snippet"></i>
    </button>
      <button id="eraser-btn" class="btn" title="Borrador">
       <i class="ri-eraser-line"></i>
      </button>
    <button id="clear-btn" class="btn" title="Borrar Anotaciones">
      <i class="ri-delete-bin-7-line"></i>
    </button>
   
    </div>
     <div class="tool-group">
          <button id="cursor-btn" class="btn" >
   <i class="ri-layout-left-2-line"></i>
    </button>
     <select id="measure-select" class="btn" title="Iniciar desde el compás...">
    </select>
         <div class="speed-group">
            <button id="zoom-out" class="btn speed-ctrl-btn">−</button>
            <div class="speed-display">
              <span class="speed-bpm" id="zoom-label">Zoom: 100%</span>
            </div>
            <button id="zoom-in" class="btn speed-ctrl-btn">+</button>
        </div>
         <button id="fullscreen-btn" class="btn" >
   <i class="ri-fullscreen-line"></i>
    </button>
    </div>
     
  </div>

  <!-- Controles de zoom para móviles -->
 

  <div id="sheet-music-wrapper" style="position: relative;">
    <div id="osmd-container"></div>
    <canvas id="annotation-canvas" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
    
</div>
  <div id="status">Cargando...</div>

  <div id="floating-speed-controls">
    <div class="speed-group">
        <button id="zoom-out2" class="btn speed-ctrl-btn">−</button>
        <div class="speed-display">
          <span class="speed-bpm" id="zoom-label2">Zoom: 100%</span>
        </div>
        <button id="zoom-in2" class="btn speed-ctrl-btn">+</button>
    </div>
  </div> 

  <div id="piano-container">
   
    <div id="piano-keys"></div>
  </div>


  <div id="midi-modal" class="modal-overlay" style="display: none;">
  <div class="modal-content">
    <p id="modal-message">Este es un mensaje de prueba.</p>
    <button id="modal-close-btn" class="btn">Entendido</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@latest/build/opensheetmusicdisplay.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>

  <script>
    const playBtn = document.getElementById('play-btn');
    const playIcon = document.getElementById('play-icon');
    const pauseIcon = document.getElementById('pause-icon');
    const pianoBtn = document.getElementById('piano-btn');
    const osmdContainer = document.getElementById('osmd-container');
    const statusDiv = document.getElementById('status');
    const pianoContainer = document.getElementById('piano-container');
    const pianoKeys = document.getElementById('piano-keys');
    const progressBar = document.getElementById('progress-bar');
    const progressBarContainer = document.getElementById('progress-bar-container');
    const speedLabel = document.getElementById('speed-label');
    const speedBpmLabel = document.getElementById('speed-bpm');
   const speedUpBtn = document.getElementById('speed-up-btn');
const speedDownBtn = document.getElementById('speed-down-btn');
    const zoomInBtn = document.getElementById('zoom-in');
    const zoomOutBtn = document.getElementById('zoom-out');
    const zoomLabel = document.getElementById('zoom-label');
     const zoomInBtn2 = document.getElementById('zoom-in2');
    const zoomOutBtn2 = document.getElementById('zoom-out2');
    const zoomLabel2 = document.getElementById('zoom-label2');
    const currentTimeSpan = document.getElementById('current-time');
const totalTimeSpan = document.getElementById('total-time');
const measureSelect = document.getElementById('measure-select');
const toolsToggleBtn = document.getElementById('tools-toggle-btn');
const secondaryTopBar = document.getElementById('secondary-top-bar');
const colorPickerContainer = document.getElementById('color-picker-container');
const colorPreviewCircle = document.getElementById('color-preview-circle');
const colorOptions = document.getElementById('color-options');
const customColorInput = document.getElementById('custom-color-input');
const eraserBtn = document.getElementById('eraser-btn');
const cursorBtn = document.getElementById('cursor-btn');
const fullscreenBtn = document.getElementById('fullscreen-btn');
const midiModal = document.getElementById('midi-modal');
const modalMessage = document.getElementById('modal-message');
const modalCloseBtn = document.getElementById('modal-close-btn');

    let osmd = null;
    let sampler = null;
    let parsedNotes = [];
    let measureStartTimes = [];
    let globalTempo = 120;
    let playbackRate = 1.0;
    let currentSpeed = 1.0;
    let totalDuration = 0;
    let isPlaying = false;
    let audioPart = null;
    let visualPart = null;
    let progressInterval = null;
    let activeHighlightTimeouts = [];
    let currentZoom = 1.0;
    let isMobile = window.innerWidth <= 768;

    // Script: al inicio, junto a las otras constantes
const midiLearnBtn = document.getElementById('midi-learn-btn');
let isMidiLearnMode = false;
let midiAccess = null;
let expectedNotes = new Set(); // Almacenará las notas que esperamos que el usuario toque
let currentLearningIndex = 0; // Para saber en qué nota de la partitura vamos


const annotationCanvas = document.getElementById('annotation-canvas');
const annotationCtx = annotationCanvas.getContext('2d');
const drawBtn = document.getElementById('draw-btn');
const textBtn = document.getElementById('text-btn');
const clearBtn = document.getElementById('clear-btn'); 
let currentDrawingColor = 'rgba(255, 223, 89, 0.4)'; // Color inicial
let isErasingMode = false;
const closeColorPicker = () => {
  colorPickerContainer.classList.remove('is-open');
};

let isDrawingMode = false;
let isDrawing = false;
let annotations = []; 
let isTextMode = false;
let textAnnotations = [];
let startX, startY;



   document.addEventListener('DOMContentLoaded', async () => {
  setStatus('Inicializando...');
  initOSMD();
  createPiano88Keys();
  addEventListeners();
  initSampler();
  
  setStatus('Cargando sonidos de piano...');
  await Tone.loaded();
  setStatus('Cargando partitura...');

  // --- NUEVA LÓGICA PARA CARGAR DESDE LA URL ---
  
  // 1. Lee los parámetros de la URL actual del navegador.
  const urlParams = new URLSearchParams(window.location.search);
  const fileId = urlParams.get('file'); // Busca un parámetro llamado 'file'.

  if (fileId) {

    const dynamicUrl = `https://storage.googleapis.com/mozartacademy-files/xml/${encodeURIComponent(fileId)}`;
    
    console.log(`Cargando archivo desde URL: ${dynamicUrl}`);
    await loadMusicXMLFromUrl(dynamicUrl);

  } else {
    // 3. Si no se especificó ningún archivo en la URL, muestra un mensaje.
    setStatus('Error: No se ha especificado ningún archivo para cargar. Añade "?file=tu-archivo.musicxml" a la URL.');
    playBtn.disabled = true; // Deshabilita el botón de play
  }
});

    function initOSMD() {
      try {
        osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay(osmdContainer, {
          backend: 'svg',
          drawTitle: true,
          drawSubtitle: true,   // MUESTRA EL SUBTÍTULO
          drawComposer: true, 
          followCursor: true,
          drawPartNames: false,
          autoResize: true,
          drawingParameters: "width",
          drawMeasureNumbers: false,
          cursorsOptions: [{ 
            type: 3, 
            color: "rgba(52,152,219,0.5)", 
            alpha: 0.5, 
            follow: true 
          }]
        });
        
        // Configuración para pantallas grandes (hasta 4 compases por línea)
        setupEngravingRulesForScreenSize();
        
      } catch (e) { 
        setStatus('Error al inicializar'); 
      }
    }

    // Función para configurar reglas según el tamaño de pantalla
    function setupEngravingRulesForScreenSize() {
      if (!osmd || !osmd.EngravingRules) return;
      
      const width = window.innerWidth;
      
      if (width <= 480) {
        // Pantallas muy pequeñas - máxima compresión
        osmd.EngravingRules.SystemMaxMeasuresCount = 4;
        osmd.EngravingRules.MinimumDistanceBetweenNotes = 0.8;
        osmd.EngravingRules.MinimumDistanceBetweenStaffLines = 2.0;
        osmd.EngravingRules.StaffDistance = 2.8;
        osmd.EngravingRules.StaffLineWidth = 0.06;
        osmd.EngravingRules.NoteHeadWidth = 0.8;
        osmd.zoom = 0.5;
        currentZoom = 0.5;
      } else if (width <= 768) {
        // Tablets y móviles grandes
        osmd.EngravingRules.SystemMaxMeasuresCount = 4;
        osmd.EngravingRules.MinimumDistanceBetweenNotes = 1.0;
        osmd.EngravingRules.MinimumDistanceBetweenStaffLines = 2.2;
        osmd.EngravingRules.StaffDistance = 3.0;
        osmd.EngravingRules.StaffLineWidth = 0.07;
        osmd.EngravingRules.NoteHeadWidth = 0.9;
        osmd.zoom = 0.7;
        currentZoom = 0.7;
      } else {
        // Pantallas de escritorio
        osmd.EngravingRules.SystemMaxMeasuresCount = 4;
        osmd.EngravingRules.MinimumDistanceBetweenNotes = 1.2;
        osmd.EngravingRules.MinimumDistanceBetweenStaffLines = 2.5;
        osmd.EngravingRules.StaffDistance = 3.5;
        osmd.EngravingRules.StaffLineWidth = 0.08;
        osmd.EngravingRules.NoteHeadWidth = 1.0;
        osmd.zoom = 0.8;
        currentZoom = 0.8;
      }
      
      updateZoomDisplay();
    }

    function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    // Añade un cero a la izquierda si los segundos son menores a 10
    const formattedSeconds = remainingSeconds < 10 ? '0' + remainingSeconds : remainingSeconds;
    return `${minutes}:${formattedSeconds}`;
}

    function initSampler() {
      sampler = new Tone.Sampler({
        urls: { 
          "C4": "C4.mp3", 
          "D#4": "Ds4.mp3", 
          "F#4": "Fs4.mp3", 
          "A4": "A4.mp3" 
        },
        release: 1,
        baseUrl: "https://tonejs.github.io/audio/salamander/"
      }).toDestination();
    }

    function createPiano88Keys() {
      pianoKeys.innerHTML = '';
      const pattern = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
      const blackKeys = { 'C': 'C#', 'D': 'D#', 'F': 'F#', 'G': 'G#', 'A': 'A#' };
      
      // Piano de 88 teclas: A0 a C8
      for (let octave = 0; octave <= 8; octave++) {
        const startNote = octave === 0 ? 9 : 0;
        
        for (let i = startNote; i <= 6; i++) {
          if (octave === 0 && i < 9) continue;
          if (octave === 8 && i > 0) break;
          
          const note = pattern[i % 7];
          const whiteKey = document.createElement('div');
          whiteKey.className = 'key white';
          whiteKey.id = `${note}${octave}`;
          pianoKeys.appendChild(whiteKey);
          
          if (blackKeys[note] && !(octave === 8 && note === 'C')) {
            const blackKey = document.createElement('div');
            blackKey.className = 'key black';
            blackKey.id = `${blackKeys[note]}${octave}`;
            pianoKeys.appendChild(blackKey);
          }
        }
      }
    }

    async function loadMusicXMLFromUrl(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Error de red');
        const text = await response.text();
        await osmd.load(text);
        osmdContainer.innerHTML = ''; 

        setupEngravingRulesForScreenSize();
        
        await osmd.render();
        populateMeasureSelector();
        
        parseMusicXML(text);
        scheduleNotesOnTransport();

        playBtn.disabled = false;
        setStatus('');
      } catch (err) {
        setStatus(`Error: ${err.message}`);
      }
    }
    
// REEMPLAZA TU FUNCIÓN parseMusicXML COMPLETA POR ESTA VERSIÓN FINAL

function parseMusicXML(xmlText) {
    parsedNotes = [];
    measureStartTimes = [0];
    const parser = new DOMParser();
    const xml = parser.parseFromString(xmlText, "application/xml");

    const divisions = parseInt(xml.querySelector("divisions")?.textContent.trim() || "24", 10);
    const soundTempo = xml.querySelector("direction sound[tempo], sound[tempo]");
    globalTempo = soundTempo ? parseFloat(soundTempo.getAttribute("tempo")) : 120;
    updateBpmDisplay();
    Tone.Transport.bpm.value = globalTempo;

    const openTies = new Map(); // Mapa para manejar notas ligadas (pitch -> noteObject)
    
    // 1. Itera sobre todas las partes (usualmente 2 en piano)
    xml.querySelectorAll('part').forEach((part, partIndex) => {
        let currentBeat = 0;

        // 2. Determina la mano de esta parte una sola vez, basándose en la clave
        const clefSign = part.querySelector('measure[number="1"] clef sign')?.textContent;
        const defaultHand = (clefSign === 'F') ? 'bass' : 'treble';

        const measures = part.querySelectorAll('measure');
        measures.forEach((measure, measureIndex) => {
            if (partIndex === 0 && measureIndex > 0) {
                 // Calcula el tiempo de inicio de cada compás (solo para la primera parte)
                measureStartTimes.push(currentBeat * (60.0 / globalTempo));
            }
            
            const nodes = measure.querySelectorAll('note, backup, forward');
            nodes.forEach(node => {
                const durationVal = parseFloat(node.querySelector('duration')?.textContent.trim() || '0');
                const durationInBeats = durationVal / divisions;

                if (node.tagName === 'note') {
                    const isChord = !!node.querySelector('chord');
                    
                    // Si NO es parte de un acorde, el tiempo avanza. Si es un acorde, usa el tiempo de la nota anterior.
                    if (!isChord) {
                        currentBeat += durationInBeats;
                    }
                    
                    if (!node.querySelector('rest') && node.querySelector('pitch')) {
                        const step = node.querySelector('step')?.textContent?.trim();
                        const octave = node.querySelector('octave')?.textContent?.trim();
                        const alt = parseInt(node.querySelector('alter')?.textContent?.trim() || '0', 10);
                        const accidental = alt === 1 ? '#' : alt === -1 ? 'b' : '';
                        const pitch = `${step}${accidental}${octave}`;
                        
                        // Determina la mano: usa el <staff> de la nota si existe, si no, usa la clave de la parte
                        const staffNumber = parseInt(node.querySelector('staff')?.textContent);
                        const hand = !isNaN(staffNumber) ? (staffNumber === 1 ? 'treble' : 'bass') : defaultHand;

                        const isTieStart = !!node.querySelector('tie[type="start"]');
                        const isTieStop = !!node.querySelector('tie[type="stop"]');

                        if (isTieStop && openTies.has(pitch)) {
                            // ES EL FINAL DE UNA LIGADURA: extiende la duración de la nota original
                            const existingNote = openTies.get(pitch);
                            existingNote.durSec += durationInBeats * (60.0 / globalTempo);
                            if (!isTieStart) {
                                openTies.delete(pitch); // Cierra la ligadura si no empieza una nueva
                            }
                        } else {
                            // ES UNA NOTA NUEVA (o el inicio de una ligadura)
                            const noteStartTime = (currentBeat - durationInBeats) * (60.0 / globalTempo);
                            
                            const newNote = {
                                pitch: pitch,
                                startSec: noteStartTime,
                                durSec: durationInBeats * (60.0 / globalTempo),
                                hand: hand,
                            };
                            parsedNotes.push(newNote);

                            if (isTieStart) {
                                openTies.set(pitch, newNote); // Abre una nueva ligadura
                            }
                        }
                    }
                } else if (node.tagName === 'backup') {
                    currentBeat -= durationInBeats;
                } else if (node.tagName === 'forward') {
                    currentBeat += durationInBeats;
                }
            });
        });
    });

    // Ordenamiento final y cálculo de duración
    parsedNotes.sort((a, b) => a.startSec - b.startSec);
    const lastNote = parsedNotes[parsedNotes.length - 1];
    totalDuration = lastNote ? lastNote.startSec + lastNote.durSec : 0;
    totalTimeSpan.textContent = formatTime(totalDuration);
}

 // REEMPLAZA LA FUNCIÓN scheduleNotesOnTransport COMPLETA CON ESTA
function scheduleNotesOnTransport() {
  if (audioPart) audioPart.dispose();
  if (visualPart) visualPart.dispose();
  Tone.Transport.cancel();
  osmd.cursor.reset();
  osmd.cursor.hide();

  // Agrupa notas por tiempo de inicio para manejar acordes correctamente
  const notesByTime = new Map();
  parsedNotes.forEach(note => {
    const time = note.startSec / playbackRate;
    if (!notesByTime.has(time)) {
      notesByTime.set(time, []);
    }
    notesByTime.get(time).push(note);
  });

  // --- NUEVA LÓGICA PARA EL AUDIO ---
  const audioEvents = [];
  notesByTime.forEach((notes, time) => {
    audioEvents.push({
      time: time,
      pitches: notes.map(n => n.pitch), // Agrupa las alturas en un arreglo
      duration: notes[0].durSec / playbackRate, // Usa la duración de la primera nota
    });
  });
  
  // El Tone.Part ahora recibe un arreglo de notas para los acordes
  audioPart = new Tone.Part((time, value) => {
    sampler.triggerAttackRelease(value.pitches, value.duration, time);
  }, audioEvents).start(0);


  // --- LÓGICA VISUAL (PERMANECE IGUAL PERO USA notesByTime) ---
  const visualEvents = [];
  notesByTime.forEach((notes, time) => {
    visualEvents.push({ time, notes: notes.map(n => ({...n, duration: n.durSec / playbackRate})) });
  });

  visualPart = new Tone.Part((time, value) => {
    Tone.Draw.schedule(() => {
      // Avanza el cursor una vez por cada grupo de notas (acorde)
      if (value.notes.length > 0) {
          osmd.cursor.next();
      }
      value.notes.forEach(note => highlightKey(note.pitch, note.duration, note.hand));
    }, time);
  }, visualEvents).start(0);
  
  // Ajusta la duración total
  const newTotalDuration = totalDuration / playbackRate;
  Tone.Transport.scheduleOnce(() => stopPlayback(), newTotalDuration + 0.5);
}
    
function playFromMeasure(measureIndex) {
  // ¡NUEVO! Limpia los highlights antes de empezar desde un nuevo punto.
  clearAllHighlights();

  if (Tone.Transport.state === 'started') stopPlayback();
  
  const startTime = measureStartTimes[measureIndex] || 0;
  
  // Resetear cursor visual
  osmd.cursor.reset();
  
  // Avanzar el cursor hasta la posición correcta
  let currentTime = -1;
  parsedNotes.forEach(note => {
      if (note.startSec < startTime && note.startSec !== currentTime) {
          osmd.cursor.next();
          currentTime = note.startSec;
      }
  });
  
  // Iniciar reproducción
  Tone.Transport.start(Tone.now() + 0.1, startTime / playbackRate);
  updatePlayButton(true);
  osmd.cursor.show();
  startProgressUpdate();
}

   function stopPlayback() {
  Tone.Transport.stop();
  osmd.cursor.reset();
  osmd.cursor.hide();
  updatePlayButton(false);
  stopProgressUpdate();
  
  // ¡NUEVO! Usa la función de limpieza total para apagar todas las teclas.
  clearAllHighlights();

  progressBar.value = 0;
  progressBar.style.setProperty('--progress', '0%');
  currentTimeSpan.textContent = '0:00'; 
}

function startProgressUpdate() {
    stopProgressUpdate();
    progressInterval = setInterval(() => {
        // Obtenemos el tiempo actual de Tone.js
        const currentTime = Tone.Transport.seconds;
      
        // Corregimos la duración total para que coincida con la velocidad de reproducción
        const effectiveTotalDuration = totalDuration / playbackRate;
        const progress = (currentTime / effectiveTotalDuration) * 100;

        progressBar.value = Math.min(progress, 100);
        progressBar.style.setProperty('--progress', `${progress}%`);

        // --- LÍNEA NUEVA ---
        // Actualiza el texto con el tiempo actual formateado
        currentTimeSpan.textContent = formatTime(currentTime);

    }, 100); // Se actualiza 10 veces por segundo
}

    function stopProgressUpdate() {
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
    }

    function addEventListeners() {
     playBtn.addEventListener('click', async () => {
  await Tone.start();
  if (Tone.Transport.state === 'started') {
    // --- LÓGICA DE PAUSA ---
    Tone.Transport.pause();
    updatePlayButton(false);
    stopProgressUpdate();
    
    // ¡NUEVO! Cancela los timeouts pero NO borra los colores.
    // Esto hace que las teclas se queden encendidas.
    activeHighlightTimeouts.forEach(clearTimeout);
    activeHighlightTimeouts = [];

  } else {
    // --- LÓGICA DE REANUDAR/PLAY ---
    // ¡NUEVO! Limpia cualquier tecla que haya quedado encendida de la pausa.
    clearAllHighlights(); 
    
    Tone.Transport.start(Tone.now() + 0.1);
    updatePlayButton(true);
    osmd.cursor.show();
    startProgressUpdate();
  }
});

      // CONTROL DE VELOCIDAD CORREGIDO
  const speedStep = 0.05; // Cuánto cambiará la velocidad con cada clic

function updateSpeed(newRate) {
    // Detener la reproducción si está activa
    if (Tone.Transport.state === 'started') {
        stopPlayback();
    } 
    
    // Limitar la velocidad entre 0.25x y 2.0x
    playbackRate = Math.max(0.25, Math.min(2.0, newRate));
    
    // Actualizar la interfaz
    const currentBPM = Math.round(globalTempo * playbackRate);
    speedLabel.textContent = `${playbackRate.toFixed(2)}x`;
    speedBpmLabel.textContent = `${currentBPM} BPM`;
    
    // Volver a programar las notas con la nueva velocidad
    scheduleNotesOnTransport();
}

speedUpBtn.addEventListener('click', () => {
    updateSpeed(playbackRate + speedStep);
});

speedDownBtn.addEventListener('click', () => {
    updateSpeed(playbackRate - speedStep);
});
 
      pianoBtn.addEventListener('click', () => {
        pianoContainer.classList.toggle('hidden');
      });
      
      // Controles de zoom
      zoomInBtn.addEventListener('click', () => {
        currentZoom = Math.min(2.0, currentZoom + 0.1);
        applyZoom();
      });
      
      zoomOutBtn.addEventListener('click', () => {
        currentZoom = Math.max(0.5, currentZoom - 0.1);
        applyZoom();
      });

        // Controles de zoom
      zoomInBtn2.addEventListener('click', () => {
        currentZoom = Math.min(2.0, currentZoom + 0.1);
        applyZoom();
      });
      
      zoomOutBtn2.addEventListener('click', () => {
        currentZoom = Math.max(0.5, currentZoom - 0.1);
        applyZoom();
      });

      midiLearnBtn.addEventListener('click', toggleMidiLearnMode);
      
      // Redimensionar ventana
      window.addEventListener('resize', () => {
        const newIsMobile = window.innerWidth <= 768;
        if (newIsMobile !== isMobile) {
          isMobile = newIsMobile;
          if (osmd) {
            setupEngravingRulesForScreenSize();
            osmd.render();
          }
        }
      });
      
 cursorBtn.addEventListener('click', toggleCursorType);
  fullscreenBtn.addEventListener('click', toggleFullScreen);

  // Opcional pero recomendado: Actualiza el ícono si el usuario sale con la tecla ESC
  document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) {
      fullscreenBtn.querySelector('i').className = 'ri-fullscreen-line';
    }
  });

progressBar.addEventListener('input', () => {
  // 1. Calcula a qué tiempo quiere saltar el usuario (en segundos)
  const seekTime = (progressBar.value / 100) * totalDuration;

  const progressValue = (progressBar.value / 100) * 100; // El valor ya es 0-100
progressBar.style.setProperty('--progress', `${progressValue}%`);

  // 2. Encuentra a qué compás corresponde ese tiempo
  let targetMeasureIndex = 0;
  for (let i = 0; i < measureStartTimes.length; i++) {
    if (measureStartTimes[i] <= seekTime) {
      targetMeasureIndex = i;
    } else {
      break;
    }
  }

  // 3. Llama a tu función para reproducir desde ese compás
  // Esto mantiene el cursor visual y el audio perfectamente sincronizados.
  playFromMeasure(targetMeasureIndex);
});

    measureSelect.addEventListener('change', () => {
        // Obtenemos el índice del compás seleccionado (convertido a número)
        const selectedMeasureIndex = parseInt(measureSelect.value, 10);
        
        // Llamamos a la función que ya tenías para reproducir desde un compás
        playFromMeasure(selectedMeasureIndex);
    });

      toolsToggleBtn.addEventListener('click', () => {
        secondaryTopBar.classList.toggle('is-visible');
    });

     modalCloseBtn.addEventListener('click', hideModal);


drawBtn.addEventListener('click', () => {
  isDrawingMode = !isDrawingMode;
  isTextMode = false;
  isErasingMode = false; // <-- AÑADE ESTO

  if (isDrawingMode) {
    drawBtn.style.background = '#e0e0e0';
    textBtn.style.background = 'none';
    eraserBtn.style.background = 'none'; // <-- AÑADE ESTO
    annotationCanvas.style.pointerEvents = 'auto';
    annotationCanvas.style.cursor = 'crosshair';
  } else {
    drawBtn.style.background = 'none';
    annotationCanvas.style.pointerEvents = 'none';
    annotationCanvas.style.cursor = 'default';
  }
});

colorPickerContainer.addEventListener('click', (e) => {
  // Detiene la propagación para que el clic no sea capturado por el listener del 'document'
  e.stopPropagation(); 
  colorPickerContainer.classList.toggle('is-open');
});

document.querySelectorAll('.color-swatch').forEach(swatch => {
  swatch.addEventListener('click', (e) => {
    e.stopPropagation(); // Detiene la propagación
    currentDrawingColor = swatch.dataset.color;
    colorPreviewCircle.style.backgroundColor = currentDrawingColor;
    closeColorPicker(); // Cierra el selector
  });
});

customColorInput.addEventListener('input', (e) => {
  const hex = e.target.value;
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  currentDrawingColor = `rgba(${r}, ${g}, ${b}, 0.4)`;
  colorPreviewCircle.style.backgroundColor = currentDrawingColor;
  // No cerramos al instante para que el usuario vea el color que eligió
});
customColorInput.addEventListener('change', () => {
    // Cerramos cuando el usuario finaliza la selección de color personalizado
    closeColorPicker();
});
// Lógica del Borrador
eraserBtn.addEventListener('click', () => {
    isErasingMode = !isErasingMode;
    isDrawingMode = false;
    isTextMode = false;

    if (isErasingMode) {
        eraserBtn.style.background = '#e0e0e0';
        drawBtn.style.background = 'none';
        textBtn.style.background = 'none';
        annotationCanvas.style.pointerEvents = 'auto';
        annotationCanvas.style.cursor = 'pointer'; // O un cursor de borrador
    } else {
        eraserBtn.style.background = 'none';
        annotationCanvas.style.pointerEvents = 'none';
        annotationCanvas.style.cursor = 'default';
    }
});

clearBtn.addEventListener('click', clearAnnotations);
annotationCanvas.addEventListener('mousedown', startDrawing);
annotationCanvas.addEventListener('mousemove', draw);
annotationCanvas.addEventListener('mouseup', stopDrawing);
annotationCanvas.addEventListener('mouseout', stopDrawing); 

textBtn.addEventListener('click', toggleTextMode);
annotationCanvas.addEventListener('click', (e) => {
    if (isTextMode) {
        handleCanvasClickForText(e);
    } else if (isErasingMode) {
        handleCanvasClickForEraser(e);
    }
});

    }

// Puedes agregar esta función justo antes de addEventListeners()
function toggleTextMode() {
  isTextMode = !isTextMode;
  isDrawingMode = false;
  isErasingMode = false; // <-- AÑADE ESTO

  if (isTextMode) {
    textBtn.style.background = '#e0e0e0';
    drawBtn.style.background = 'none';
    eraserBtn.style.background = 'none'; // <-- AÑADE ESTO
    annotationCanvas.style.pointerEvents = 'auto';
    annotationCanvas.style.cursor = 'text';
  } else {
    textBtn.style.background = 'none';
    annotationCanvas.style.pointerEvents = 'none';
    annotationCanvas.style.cursor = 'default';
  }
}


function handleCanvasClickForEraser(e) {
    const rect = annotationCanvas.getBoundingClientRect();
    const clickX = (e.clientX - rect.left) / rect.width;
    const clickY = (e.clientY - rect.top) / rect.height;
    let somethingWasDeleted = false;

    // Itera en reversa para evitar problemas de índice al borrar
    for (let i = annotations.length - 1; i >= 0; i--) {
        const annotation = annotations[i];
        if (
            clickX >= annotation.x &&
            clickX <= annotation.x + annotation.width &&
            clickY >= annotation.y &&
            clickY <= annotation.y + annotation.height
        ) {
            annotations.splice(i, 1); // Borra el elemento
            somethingWasDeleted = true;
            break; // Borra solo un elemento por clic
        }
    }

    if (!somethingWasDeleted) {
        // Si no se borró un dibujo, busca un texto
        for (let i = textAnnotations.length - 1; i >= 0; i--) {
            const text = textAnnotations[i];
            // Aproxima un área de clic para el texto
            const textWidthApprox = (text.text.length * 8) / rect.width; // Estimación simple
            const textHeightApprox = 20 / rect.height;

            if (
                clickX >= text.x &&
                clickX <= text.x + textWidthApprox &&
                clickY >= text.y &&
                clickY <= text.y + textHeightApprox
            ) {
                textAnnotations.splice(i, 1);
                somethingWasDeleted = true;
                break;
            }
        }
    }

    if (somethingWasDeleted) {
        redrawAllAnnotations();
    }
}

function populateMeasureSelector() {
    const measureCount = osmd.sheet.SourceMeasures.length;
    measureSelect.innerHTML = ''; // Limpiamos opciones previas

    for (let i = 0; i < measureCount; i++) {
        const option = document.createElement('option');
        option.value = i; // El valor será el índice del compás (0, 1, 2...)
        option.textContent = `Compás ${i + 1}`; // El texto para el usuario (1, 2, 3...)
        measureSelect.appendChild(option);
    }
}


function toggleCursorType() {
  if (!osmd || !osmd.cursor) return;

  // CORRECCIÓN: Se usa .cursorOptions en lugar de .Options
  const newType = osmd.cursor.cursorOptions.type === 3 ? 1 : 3;
  osmd.cursor.cursorOptions.type = newType;

  // Cambia el color del botón para dar feedback visual
  if (newType === 1) {
    cursorBtn.style.color = '#3498db'; 
    osmd.cursor.cursorOptions.alpha =0.8;
    osmd.cursor.cursorOptions.color = "rgba(52, 152, 219, 0.8)";
  } else {
    cursorBtn.style.color = '#1a1a1a'; 
     osmd.cursor.cursorOptions.alpha = 0.45;
    osmd.cursor.cursorOptions.color = "rgba(52, 152, 219, 0.45)";
  }
}

function clearAllHighlights() {
  // 1. Cancela todos los timeouts pendientes para que no se ejecuten más tarde
  activeHighlightTimeouts.forEach(clearTimeout);
  activeHighlightTimeouts = [];

  // 2. Busca todas las teclas activas en el DOM y les quita la clase de color
  document.querySelectorAll('.active-treble, .active-bass').forEach(key => {
    key.classList.remove('active-treble', 'active-bass');
  });
}

function toggleFullScreen() {
  const icon = fullscreenBtn.querySelector('i');
  if (!document.fullscreenElement) {
    // Entrar en pantalla completa
    document.documentElement.requestFullscreen();
    icon.className = 'ri-fullscreen-exit-line'; // Cambia al ícono de "salir"
  } else {
    // Salir de pantalla completa
    if (document.exitFullscreen) {
      document.exitFullscreen();
      icon.className = 'ri-fullscreen-line'; // Cambia al ícono de "entrar"
    }
  }
}

    function applyZoom() {
      if (osmd) {
        osmd.zoom = currentZoom;
        osmd.render();
        updateZoomDisplay();

      }
    }

    function updateZoomDisplay() {
      zoomLabel.textContent = `${Math.round(currentZoom * 100)}%`;
      zoomLabel2.textContent = `${Math.round(currentZoom * 100)}%`;
    }

    function updatePlayButton(isPlaying) {
      playIcon.style.display = isPlaying ? 'none' : 'block';
      pauseIcon.style.display = isPlaying ? 'block' : 'none';
    }

    function updateBpmDisplay() {
      const currentBPM = Math.round(globalTempo * currentSpeed);
      speedLabel.textContent = `${currentSpeed.toFixed(2)}x`;
      speedBpmLabel.textContent = `${currentBPM} BPM`;
    }

// Reemplaza tu función highlightKey con esta:
function highlightKey(noteName, durSec, hand, persist = false) {
    const noteId = noteName.replace('b', '#');
    const el = document.getElementById(noteId);
    if (!el) return;

    const highlightClass = hand === 'treble' ? 'active-treble' : 'active-bass';
    el.classList.add(highlightClass);

    // Si NO es persistente, se apaga después de un tiempo
    if (!persist) {
        const highlightDuration = Math.max(80, durSec * 1000 / currentSpeed);
        const timeoutId = setTimeout(() => {
            el.classList.remove(highlightClass);
            activeHighlightTimeouts = activeHighlightTimeouts.filter(id => id !== timeoutId);
        }, highlightDuration);
        activeHighlightTimeouts.push(timeoutId);
    }
}

// Script: Añade esta nueva función principal de aprendizaje
function advanceLearningStep() {
    clearAllHighlights();
    expectedNotes.clear();

    if (currentLearningIndex >= parsedNotes.length) {
        alert("¡Felicidades, has completado la pieza!");
        toggleMidiLearnMode();
        return;
    }

    const nextNoteTime = parsedNotes[currentLearningIndex].startSec;
    const notesInStep = [];
    
    while (currentLearningIndex < parsedNotes.length && parsedNotes[currentLearningIndex].startSec === nextNoteTime) {
        notesInStep.push(parsedNotes[currentLearningIndex]);
        currentLearningIndex++;
    }

    if (notesInStep.length > 0) {
        osmd.cursor.next();
        const pitchesToPlay = [];

        // Ahora, esta función SOLO prepara lo visual.
        notesInStep.forEach(note => {
            expectedNotes.add(note.pitch);
            highlightKey(note.pitch, note.durSec, note.hand, true); 
        });

        // La línea que reproducía el sonido (sampler.triggerAttackRelease) se ha eliminado de aquí.
        
        console.log("Esperando que toques:", Array.from(expectedNotes));
    }
}

    function setStatus(text) { 
      statusDiv.textContent = text;
      statusDiv.style.display = text ? 'block' : 'none';
    }




// Se activa al presionar el clic
function startDrawing(e) {
    if (!isDrawingMode) return;
    isDrawing = true;
    
    // Guardamos las coordenadas de inicio NORMALIZADAS (0 a 1)
    const rect = annotationCanvas.getBoundingClientRect();
    startX = (e.clientX - rect.left) / rect.width;
    startY = (e.clientY - rect.top) / rect.height;
}

// Se activa mientras se mueve el ratón con el clic presionado
// Reemplaza el contenido de la función draw(e) con esto:
function draw(e) {
  if (!isDrawing) return;

  redrawAllAnnotations();
 
  const canvasRect = annotationCanvas.getBoundingClientRect();
  const currentX = (e.clientX - canvasRect.left) / canvasRect.width;
  const currentY = (e.clientY - canvasRect.top) / canvasRect.height;

  const width = (currentX - startX) * annotationCanvas.width;
  const height = (currentY - startY) * annotationCanvas.height;

  // ✨ LÍNEA CORREGIDA ✨
  annotationCtx.fillStyle = currentDrawingColor; 
  annotationCtx.fillRect(startX * annotationCanvas.width, startY * annotationCanvas.height, width, height);
}

// Se activa al soltar el clic
// ENCUENTRA LA FUNCIÓN stopDrawing(e) Y MODIFÍCALA ASÍ:
function stopDrawing(e) {
  if (!isDrawing) return;
  isDrawing = false;

  const rect = annotationCanvas.getBoundingClientRect();
  const endX = (e.clientX - rect.left) / rect.width;
  const endY = (e.clientY - rect.top) / rect.height;

  const finalX = Math.min(startX, endX);
  const finalY = Math.min(startY, endY);
  const finalWidth = Math.abs(startX - endX);
  const finalHeight = Math.abs(startY - endY);

  if (finalWidth > 0.01 && finalHeight > 0.01) {
    annotations.push({
      x: finalX,
      y: finalY,
      width: finalWidth,
      height: finalHeight,
      // ---- LÍNEA MODIFICADA ----
      color: currentDrawingColor 
    });
  }

  redrawAllAnnotations();
}


function redrawAllAnnotations() {
    // Asegura que el canvas tenga el tamaño correcto del contenedor de la partitura
    const rect = osmdContainer.getBoundingClientRect();
    if (annotationCanvas.width !== rect.width || annotationCanvas.height !== rect.height) {
        annotationCanvas.width = rect.width;
        annotationCanvas.height = rect.height;
    }
    
    // Limpia todo
    annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);

    // Dibuja los rectángulos guardados
    annotations.forEach(rect => {
        annotationCtx.fillStyle = rect.color;
        annotationCtx.fillRect(
            rect.x * annotationCanvas.width, 
            rect.y * annotationCanvas.height, 
            rect.width * annotationCanvas.width, 
            rect.height * annotationCanvas.height
        );
    });

    // Dibuja los textos guardados
    textAnnotations.forEach(text => {
        annotationCtx.fillStyle = text.color;
        annotationCtx.font = text.font;
        annotationCtx.textBaseline = 'top'; // Asegura que el texto se dibuje desde la esquina superior
        annotationCtx.fillText(
            text.text,
            text.x * annotationCanvas.width,
            text.y * annotationCanvas.height
        );
    });
}

// Se llama al hacer clic en el canvas cuando el modo texto está activo
function handleCanvasClickForText(e) {
    if (!isTextMode) return;

    // Busca si ya existe un cuadro de texto en la pantalla.
    const existingInput = document.body.querySelector('input[type="text"][style*="position: absolute"]');

    if (existingInput) {
        // Si existe, el clic solo lo finalizará (lo "desenfoca").
        existingInput.blur(); 
        return; // Detiene la función aquí para no crear uno nuevo.
    }
    
    // Si no existe ningún cuadro de texto, crea uno nuevo.
    isDrawing = false; 
    createTextInput(e);
}

// Crea y posiciona un <input> temporal sobre el canvas
function createTextInput(e) {
    const wrapper = document.getElementById('sheet-music-wrapper');
    const rect = annotationCanvas.getBoundingClientRect();
    
    // Calcula la posición del clic relativa al contenedor de la partitura
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Crea el elemento de input
    const input = document.createElement('input');
    input.type = 'text';
    input.style.position = 'absolute';
    input.style.left = `${x}px`; // Usa las coordenadas relativas al canvas
    input.style.top = `${y}px`;
    input.style.background = 'white';
    input.style.border = '1px solid #ccc';
    input.style.font = 'bold 18px sans-serif';
    input.style.padding = '2px';
    input.setAttribute('maxlength', '50');

    // Función para guardar el texto y eliminar el input
    const finalizeText = () => {
        if (input.value.trim()) {
            // Guardamos las coordenadas normalizadas (0 a 1)
            const normalizedX = x / rect.width;
            const normalizedY = y / rect.height;

            textAnnotations.push({
                text: input.value,
                x: normalizedX,
                y: normalizedY,
                color: 'rgba(231, 76, 60, 1.0)', // Color rojo para el texto
                font: 'bold 18px sans-serif'
            });
            redrawAllAnnotations();
        }
        // Asegúrate de que el input exista antes de intentar eliminarlo
        if (wrapper.contains(input)) {
            wrapper.removeChild(input);
        }
    };

    input.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') {
            ev.preventDefault();
            input.blur();
        }
    });
    input.addEventListener('blur', finalizeText);

    // Agrega el input al contenedor de la partitura y lo enfoca
    wrapper.appendChild(input);
    input.focus();
}

// Reemplaza la función clearAnnotations() con esto:
function clearAnnotations() {
    annotations = []; // Vaciamos el arreglo de rectángulos
    textAnnotations = []; // Vaciamos el arreglo de textos
    redrawAllAnnotations(); // Limpiamos y redibujamos el canvas vacío
}


// Script: añade esta nueva función
function toggleMidiLearnMode() {
    // Si el usuario hace clic pero no hay MIDI, muestra el mensaje y no hagas nada más.
    if (isMidiLearnMode === false && (!midiAccess || midiAccess.inputs.size === 0)) {
        showModal("🎹 No se detectó ningún teclado MIDI. Por favor, conecta uno e inténtalo de nuevo.");
        initMidiInput(); // Intenta reconectar por si acaso
        return; // Detiene la función aquí
    }

    isMidiLearnMode = !isMidiLearnMode;
    stopPlayback(); 

    if (isMidiLearnMode) {
        // ... el resto de la función se mantiene igual ...
        midiLearnBtn.style.background = '#e0e0e0';
        playBtn.disabled = true;
        currentLearningIndex = 0;
        osmd.cursor.show();

        cursorBtn.style.color = '#3498db';
        Object.assign(osmd.cursor.cursorOptions, {
            type: 1,
            alpha: 0.8,
            color: "rgba(52, 152, 219, 0.8)"
        });
        
        // La llamada a initMidiInput() ya no es necesaria aquí porque se hace al cargar la página
        
        advanceLearningStep(); 
    } else {
        // ... el resto de la función se mantiene igual ...
        midiLearnBtn.style.background = 'none';
        playBtn.disabled = false;
        clearAllHighlights(); 
        osmd.cursor.reset();
        osmd.cursor.hide();
        
        cursorBtn.style.color = '#1a1a1a';
        Object.assign(osmd.cursor.cursorOptions, {
            type: 3,
            alpha: 0.45,
            color: "rgba(52, 152, 219, 0.45)"
        });
    }
}


// Script: añade esta nueva función
function initMidiInput() {
    if (navigator.requestMIDIAccess) {
        navigator.requestMIDIAccess()
            .then(onMIDISuccess, onMIDIFailure);
    } else {
        alert("Tu navegador no soporta Web MIDI API. Prueba con Chrome o Edge.");
    }
}

function onMIDISuccess(access) {
    midiAccess = access;

    // ▼▼▼ NUEVO: Escuchamos cambios de estado (conexión/desconexión) ▼▼▼
    midiAccess.onstatechange = (event) => {
        const port = event.port;
        const deviceName = port.name || 'Dispositivo MIDI';

        if (port.state === 'connected' && port.type === 'input') {
            showModal(`✅ ¡${deviceName} conectado!`, 3000); // Se cierra solo a los 3 seg
            port.onmidimessage = onMIDIMessage; // Asigna el listener al nuevo dispositivo
        } else if (port.state === 'disconnected' && port.type === 'input') {
            showModal(`🔌 ¡${deviceName} desconectado!`, 3000);
        }
    };

    // Configuración inicial de los dispositivos ya conectados
    const inputs = midiAccess.inputs.values();
    let deviceFound = false;
    for (const input of inputs) {
        input.onmidimessage = onMIDIMessage;
        deviceFound = true;
    }

    if (!deviceFound) {
        showModal("Haz clic en 'Modo Aprendizaje' cuando tu teclado MIDI esté conectado.");
    } else {
         console.log('Teclado MIDI ya conectado y listo.');
    }
}

function onMIDIFailure() {
    showModal("⚠️ No se pudo acceder a tus dispositivos MIDI. Asegúrate de dar permiso en el navegador.");
    isMidiLearnMode = false;
    midiLearnBtn.style.background = 'none';
    playBtn.disabled = false;
}

// Script: añade esta nueva función
function onMIDIMessage(event) {
    if (!isMidiLearnMode || expectedNotes.size === 0) return;

    const command = event.data[0];
    const note = event.data[1];
    const velocity = event.data.length > 2 ? event.data[2] : 0;

    if (command === 144 && velocity > 0) {
        const pitchName = midiNoteToPitchName(note);

        if (expectedNotes.has(pitchName)) {
            // ▼▼▼ CAMBIO PRINCIPAL: El sonido se reproduce AQUÍ ▼▼▼
            // Como recompensa por tocar la nota correcta.
            sampler.triggerAttackRelease(pitchName, '8n');

            expectedNotes.delete(pitchName);
            console.log(`¡Correcto! Nota ${pitchName}. Faltan ${expectedNotes.size}.`);
            
            if (expectedNotes.size === 0) {
                setTimeout(() => {
                    advanceLearningStep();
                }, 300); 
            }
        }
    }
}

// Script: añade estas dos funciones de ayuda

function prepareNextExpectedNotes() {
    expectedNotes.clear();
    if (currentLearningIndex >= parsedNotes.length) {
        console.log("¡Felicidades, terminaste la pieza!");
        toggleMidiLearnMode(); // Desactiva el modo al final
        return;
    }

    // Obtenemos el tiempo de la siguiente nota
    const nextNoteTime = parsedNotes[currentLearningIndex].startSec;
    
    // Buscamos todas las notas que suenan en ESE MISMO MOMENTO (acordes)
    while (currentLearningIndex < parsedNotes.length && parsedNotes[currentLearningIndex].startSec === nextNoteTime) {
        expectedNotes.add(parsedNotes[currentLearningIndex].pitch);
        currentLearningIndex++;
    }
    
    // Opcional: Muestra en la consola qué notas se esperan
    console.log("Esperando notas:", Array.from(expectedNotes));
}

function midiNoteToPitchName(midiNote) {
    const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const octave = Math.floor(midiNote / 12) - 1;
    const noteName = noteNames[midiNote % 12];
    return noteName + octave;
}

// Script: añade estas nuevas funciones de ayuda
function showModal(message, duration = 0) {
    modalMessage.textContent = message;
    midiModal.style.display = 'flex';
    // Usamos un pequeño timeout para que la transición CSS se active
    setTimeout(() => {
        midiModal.classList.add('is-visible');
    }, 10);

    // Si se especifica una duración, el modal se cierra solo
    if (duration > 0) {
        setTimeout(() => {
            hideModal();
        }, duration);
    }
}

function hideModal() {
    midiModal.classList.remove('is-visible');
    // Esperamos a que la transición termine para ocultarlo con display:none
    setTimeout(() => {
        midiModal.style.display = 'none';
    }, 300);
}

  </script>
</body>
</html>   
