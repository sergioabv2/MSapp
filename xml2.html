
<html lang="es"> 
<head> 
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Reproductor MusicXML</title>
   <link href="https://cdn.jsdelivr.net/npm/remixicon@4.5.0/fonts/remixicon.css" rel="stylesheet"/>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #fafafa;
      color: #1a1a1a;
      padding-bottom: 140px;
    }
    
    /* Top Bar - Minimalista */
    #top-bar {
      background: #fff;
      border-bottom: 1px solid #e0e0e0;
      padding: 10px 20px;
      position: sticky;
      top: 0;
      z-index: 1000;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    }
    

    
    #song-title {
      font-size: 14px;
      font-weight: 600;
      color: #1a1a1a;
    }
    
    #song-composer {
      font-size: 12px;
      color: #999;
    }
 
    
    .btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 6px;
      border-radius: 4px;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .btn:hover:not(:disabled) {
      background: #f5f5f5;
    }
    
    .btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    
    .btn svg {
      width: 20px;
      height: 20px;
      fill: #1a1a1a;
    }

    .btn i {
      font-size: 20px;
      fill: #1a1a1a;
    }
    
    /* Progress Bar */
   /* AÑADE ESTE NUEVO BLOQUE DE CSS */




/* Posiciona el slider en la parte inferior de la barra superior */
#progress-bar {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  -webkit-appearance: none;
  appearance: none;
  height: 3px; /* Grosor de la barra */
  background: transparent;
  outline: none;
  cursor: pointer;
  margin: 0;
  padding: 0;
  /* Variable CSS personalizada para el progreso */
  --progress: 0%; /* Valor inicial */
}

/* Estilo para el "thumb" (el círculo que se arrastra) */
#progress-bar::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 12px; /* Tamaño del thumb */
  height: 12px;
  background: #3498db; /* Color del thumb */
  border-radius: 50%;

  box-shadow: 0 0 4px rgba(0,0,0,0.4);
  margin-top: -4px; /* Centra el thumb verticalmente en la barra */
}

#progress-bar::-moz-range-thumb {
  width: 15px;
  height: 15px;
  background: #3498db;
  border-radius: 50%;
  border: 2px solid white;
  box-shadow: 0 0 4px rgba(0,0,0,0.4);
}

/* Estilo para el "track" (la barra completa) */
/* Para navegadores WebKit: usa un gradiente para simular el progreso */
#progress-bar::-webkit-slider-runnable-track {
  width: 100%;
  height: 3px;
  background: linear-gradient(to right, #3498db 0%, #3498db var(--progress), #e0e0e0 var(--progress), #e0e0e0 100%);
  border-radius: 5px; /* Opcional: para que los bordes del track sean suaves */
}

/* Para Firefox: usa la pseudo-clase estándar */
#progress-bar::-moz-range-track {
  width: 100%;
  height: 3px;
  background: #e0e0e0; /* Color de la barra no reproducida (fondo blanco) */
  border-radius: 5px; /* Opcional */
}

#progress-bar::-moz-range-progress {
  background: #3498db; /* Color azul para la parte reproducida */
  height: 3px;
  border-radius: 5px; /* Opcional */
}
  
    
   
#piano-container {
  position: fixed;
  left: 0;
  bottom: 0;
  width: 100%;
  background: #2a2a2a;
  padding: 12px 0;
  overflow: hidden;
  box-shadow: 0 -1px 3px rgba(0,0,0,0.08);
  border-top: 1px solid #e0e0e0;
  height: 200px;
  z-index: 100;
}

/* Estado 1: Solo waterfall (cubre toda la pantalla) */
#piano-container.waterfall-only {
  height: calc(100vh - 60px);
  top: 60px;
  bottom: auto;
  padding: 0 0 12px 0;
}


#piano-container.waterfall-only .hit-line-piano {
  bottom: 102px;
}

#piano-container.waterfall-only #waterfall-canvas {
  height: calc(100% - 102px) !important; 
  width: 100%;
}

/* Estado 2: Solo piano (sin waterfall) */
#piano-container.piano-only {
  height: 102px;
}

#piano-container.piano-only #waterfall-canvas,
#piano-container.piano-only .hit-line-piano {
  display: none;
}
    
  
    
 #piano-keys {
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  justify-content: center;
  padding: 0 10px;
  z-index: 2;
  height: 102px;
}
    
    .key {
      border: 1px solid #ddd;
      position: relative;
      transition: all 0.05s;
    }
    
    .key.white {
      width: 16px;
      height: 90px;
      background: #fff;
      border-right: 1px solid #e0e0e0;
    }
    
    .key.black {
      width: 10px;
      height: 58px;
      background: #1a1a1a;
      margin-left: -5px;
      margin-right: -5px;
      z-index: 2;
    }
    
    .key.active-treble {
  background: #3498db !important; /* Azul para la mano derecha (treble) */
  box-shadow: 0 0 8px rgba(52, 152, 219, 0.6) !important;
}

.key.active-bass {
  background: #de9e37 !important; /* Verde para la mano izquierda (bass) */
  box-shadow: 0 0 8px rgba(222, 158, 55, 0.6) !important;
}
    

@keyframes keyPulse {
  0% { 
    filter: brightness(1.5);
    transform: translateY(0);
  }
  50% {
    filter: brightness(2);
    transform: translateY(2px);
  }
  100% { 
    filter: brightness(1);
    transform: translateY(0);
  }
}

.key.active-treble,
.key.active-bass {
  animation: keyPulse 0.15s ease-out;
}

#waterfall-canvas {
  position: absolute;
  top: 0;
  left: 50%;  /* ← CAMBIADO de 0 a 50% */
  transform: translateX(-50%);  /* ← AÑADIDO para centrar */
  width: 100%;
  height: calc(100% - 102px);
  pointer-events: none;
  z-index: 1;
  transition: height 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
}

.hit-line-piano {
  position: absolute;
  bottom: 102px;
  left: 0;
  right: 0;
  height: 2px;
  background: rgba(255, 0, 0, 1);
  box-shadow: 0 0 8px rgba(255, 0, 0, 0.6);
  z-index: 3;
  pointer-events: none;
}

.note-flash-piano {
  position: absolute;
  bottom: 102px;
  width: 20px;
  height: 12px;
  pointer-events: none;
  z-index: 4;
  opacity: 0;
  background: white;
  transform-origin: center bottom;
}

.note-flash-piano.flash-active {
  animation: flashEffectPiano 0.4s ease-out;
}

@keyframes flashEffectPiano {
  0% {
    opacity: 0.7;
    transform: translateX(-50%) translateY(0) scaleY(1);
    filter: blur(2px);
    box-shadow: 0 3px 10px 3px rgba(255, 255, 255, 0.6);
  }
  50% {
    opacity: 0.4;
    transform: translateX(-50%) translateY(-8px) scaleY(1.3);
    filter: blur(4px);
    box-shadow: 0 6px 12px 5px rgba(255, 255, 255, 0.3);
  }
  100% {
    opacity: 0;
    transform: translateX(-50%) translateY(-15px) scaleY(1.6);
    filter: blur(6px);
    box-shadow: 0 8px 15px 6px rgba(255, 255, 255, 0);
  }
}




    #status {
      text-align: center;
      padding: 40px 20px;
      color: #999;
      font-size: 13px;
    }
    
   

#osmd-container {
  width: 95%; 
  max-width: 900px; 
  margin: 20px auto;
  border: 1px solid #ddd;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
  border-radius: 3px;
  box-sizing: border-box;
  overflow: hidden; /* Asegura que el contenido SVG respete los bordes redondeados */
}




@media (min-width: 830px) {
  #osmd-container {
    width: 85%;
  }
}


/* Ajustes para Desktop */
@media (min-width: 1100px) {
  #osmd-container {
    width: 70%;
  }
}
  

.speed-group {
    display: flex;
    align-items: center;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    background-color: #fff;
    box-shadow: 0 1px 2px rgba(0,0,0,0.04);
}

.speed-ctrl-btn {
    font-size: 20px;
    font-weight: 500;
    padding: 4px 12px;
    line-height: 1;
    border-radius: 0; /* Quitamos bordes individuales */
    background-color: transparent;
}
.speed-ctrl-btn:hover:not(:disabled) {
    background-color: #f5f5f5;
}

.speed-display {

    text-align: center;
    min-width: 50px;
    border-left: 1px solid #e0e0e0;
    border-right: 1px solid #e0e0e0;
}

.speed-bpm {
    font-size: 14px;
    font-weight: 600;
    display: block;
    color: #1a1a1a;
}

.speed-value {
    font-size: 11px;
    color: #999;
    display: block;
    margin-top: 2px;
}
#annotation-canvas {
height: 100%;
width: 100vw;
}

/* === Reestructuración Top Bar === */
.controls-group {
  display: flex;
  align-items: center;
  gap: 16px; /* Espacio entre elementos dentro de un grupo */
}

/* === NUEVO: Contador de Tiempo === */
#time-display {
  font-size: 13px;
  color: #555;
  font-family: 'SF Mono', 'Menlo', 'monospace'; /* Letra monoespaciada para números */
  background-color: #f5f5f5;
  padding: 8px 12px;
  border-radius: 6px;
  border: 1px solid #e0e0e0;
}

/* === NUEVO: Controles de Zoom Rediseñados (estilo de la imagen) === */
#zoom-controls {
  display: flex;
  align-items: center;
  background-color: #f9f9f9;
  border-radius: 8px;
  border: 1px solid #e0e0e0;
  overflow: hidden; 
  box-shadow: 0 1px 2px rgba(0,0,0,0.03);
}

#zoom-controls .zoom-display {
  padding: 6px 14px;
  font-size: 13px;
  font-weight: 500;
  color: #333;
}

#zoom-controls .zoom-buttons {
  display: flex;
}

#zoom-controls .zoom-btn {
  background-color: #fff;
  border: none;
  border-left: 1px solid #e0e0e0; /* Línea divisora */
  padding: 6px 12px;
  font-size: 16px;
  line-height: 1;
  border-radius: 0;
  cursor: pointer;
  transition: background-color 0.2s;
}

#zoom-controls .zoom-btn:hover {
  background-color: #f0f0f0;
}

/* === NUEVO: Espacio para botón Cerrar === */
#close-btn-placeholder {
  width: 30px; /* Ancho para el espacio reservado */
  height: 39px;
}

/* === NUEVO: Botones Flotantes de Dibujo === */
#floating-draw-controls {
  position: sticky;
  bottom: 105px;
  float: right;
  margin-right: 10px;
  z-index: 50;
  width: 90px;
  display: flex;
  flex-direction: row; /* Apila los botones verticalmente */
  gap: 5px;
  background-color: rgba(255, 255, 255, 0.85); /* Fondo semitransparente */
  padding: 8px;
  border-radius: 10px;
  border: 1px solid #e0e0e0;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  backdrop-filter: blur(8px); /* Efecto "glassmorphism" para navegadores compatibles */
}

    /* === NUEVO: Controles de Velocidad Flotantes === */
#floating-speed-controls {
  position: sticky;
  width: 145px;
  bottom: 105px;
  display: none;
  left: 10px; /* Lo posicionamos a la izquierda para balancear la UI */
  z-index: 50;
  background-color: rgba(255, 255, 255, 0.85);
  padding: 8px;
  border-radius: 10px;
  border: 1px solid #e0e0e0;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  backdrop-filter: blur(8px);
}

/* Ajustes a los botones flotantes */
#floating-draw-controls .btn:hover {
  background-color: #e9e9e9;
}



#measure-select {
  -webkit-appearance: none; /* Quita el estilo por defecto en Safari/Chrome */
  -moz-appearance: none; 
  appearance: none;
  background-color: white;
 border-radius: 6px;
  border: 1px solid #e0e0e0;
  font-size: 13px;
  font-weight: 500;
  height: 30px;
  color: #1a1a1a;
  padding: 2px 8px;
  cursor: pointer;
}

#measure-select:hover {
  background-color: rgba(0,0,0,0.05);
}




/* === NUEVO: Barra de Herramientas Secundaria === */
#secondary-top-bar {

display: flex;
  background-color: #f9f9f9;
  border-bottom: 1px solid #e0e0e0;
 padding: 0px 15px;
 top: 60px;
   position: sticky ;
   z-index: 999;
     align-items: center; 
  justify-content: space-between;
  gap: 16px;
  overflow: hidden; /* Clave para la animación de despliegue */
  max-height: 0; /* Estado inicial: colapsada */
  transition: max-height 0.3s ease-out, padding 0.3s ease-out; /* Animación suave */
}

/* Estado visible de la barra secundaria */
#secondary-top-bar.is-visible {

  max-height: 35px; /* Altura suficiente para los botones */
  padding: 4px 15px; /* Restaura el padding vertical */
}


#secondary-top-bar2 {

display: flex;
  background-color: #f9f9f9;
  border-bottom: 1px solid #e0e0e0;
 padding: 0px 15px;
 top: 60px;
   position: sticky ;
   z-index: 999;
     align-items: center; 
  justify-content: space-between;
  gap: 16px;
  overflow: hidden; /* Clave para la animación de despliegue */
  max-height: 0; /* Estado inicial: colapsada */
  transition: max-height 0.3s ease-out, padding 0.3s ease-out; /* Animación suave */
}

/* Estado visible de la barra secundaria */
#secondary-top-bar2.is-visible {

  max-height: 35px; /* Altura suficiente para los botones */
  padding: 4px 15px; /* Restaura el padding vertical */
}

.tool-group {
  display: flex;
  align-items: center;
  gap: 16px; /* Espacio entre los elementos de cada grupo */
}


 /* Mobile adjustments - ESCALADO PARA MÓVILES */
    @media (max-width: 768px) {
   
      
      /* Aplicamos zoom automático en móviles */
      .mobile-zoom {
        transform: scale(0.85);
        transform-origin: top center;
      }
      
      .key.white {
        width: 13px;
        height: 75px;
      }
      
      .key.black {
        width: 8px;
        height: 48px;
        margin-left: -4px;
        margin-right: -4px;
      }
      
   
    }
    
    @media (max-width: 500px) {
      #top-bar {
        padding: 8px 12px;
      }

      #floating-speed-controls{
        display: flex !important;
      }

      .mobile-zoom {
        transform: scale(0.75);
        transform-origin: top center;
      }

      #tools-toggle-btn,
  #secondary-top-bar,
   #secondary-top-bar2{
    display: none; 
  }
  }

   @media (max-width: 440px) {
       #time-display{
        display: none;
      }
   }


/* --- CSS CORRECTO PARA EL COLOR PICKER HORIZONTAL --- */

/* Contenedor del selector de color completo (círculo + opciones) */
#color-picker-container {
  display: flex;
  align-items: center;
  background-color: #f0f0f0;
  border-radius: 18px; /* Bordes redondeados para el contenedor */
  padding: 4px;
  transition: all 0.3s ease-in-out;
  /* Importante: quitamos position: relative que ya no es necesario */
}

/* El círculo que muestra el color actual */
#color-preview-circle {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid #666;
  background-color: rgba(255, 223, 89, 0.4);
  cursor: pointer;
  flex-shrink: 0; /* Evita que el círculo se encoja */
}

/* Contenedor de las opciones de color (el que modificamos) */
#color-options {
  display: flex;
  align-items: center;
  gap: 8px;
  
  /* ESTADO OCULTO INICIAL (sin display:none) */
  max-width: 0;
  opacity: 0;
  overflow: hidden;
  transition: max-width 0.3s ease-in-out, opacity 0.2s linear, margin-left 0.3s ease-in-out;
  margin-left: 0;
  /* Eliminamos position: absolute y todo lo relacionado a eso */
}

/* ESTADO ABIERTO: Cuando el contenedor tiene la clase 'is-open' */
#color-picker-container.is-open #color-options {
  max-width: 200px; /* Ancho suficiente para mostrar todo */
  opacity: 1;
  margin-left: 8px; /* Espacio entre el círculo y las opciones */
}

/* Muestras de color y el input (sin cambios, pero se incluyen por completitud) */
.color-swatch {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  cursor: pointer;
  border: 1px solid #ddd;
  transition: transform 0.2s ease;
  flex-shrink: 0;
}

.color-swatch:hover {
  transform: scale(1.15);
  border: 2px solid #3498db;
}

#custom-color-input {
  width: 28px;
  height: 28px;
  border: none;
  padding: 0;
  background: none;
  cursor: pointer;
  border-radius: 50%;
  flex-shrink: 0;
}

/* === NUEVO: Estilos para el Modal MIDI === */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000; /* Asegura que esté por encima de todo */
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
}

/* Estado visible del modal */
.modal-overlay.is-visible {
  opacity: 1;
  pointer-events: auto;
}

.modal-content {
  background: #fff;
  padding: 25px 30px;
  border-radius: 12px;
  box-shadow: 0 5px 20px rgba(0,0,0,0.2);
  text-align: center;
  max-width: 320px;
  transform: scale(0.9);
  transition: transform 0.3s ease;
}

.modal-overlay.is-visible .modal-content {
  transform: scale(1);
}

#modal-message {
  font-size: 15px;
  color: #333;
  line-height: 1.5;
  margin-bottom: 20px;
}

.closeBtn {
  background-color: #3498db;
  color: white;
  padding: 10px 20px;
  border-radius: 8px;
  font-weight: 500;
  transition: background-color 0.2s;
}

.closeBtn:hover {
  background-color: #2980b9;
}

#midi-status-legend {
  position: fixed;
  /* Lo ponemos encima de los controles de velocidad móviles */
  bottom: 165px; 
  left: 10px;
  z-index: 550;
  background-color: rgba(26, 26, 26, 0.85); /* Fondo oscuro */
  color: #fafafa;
  padding: 8px 12px;
  border-radius: 10px;
  border: 1px solid #444;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  backdrop-filter: blur(8px);
  font-size: 13px;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 8px;
  
  /* Oculto por defecto */
  opacity: 0;
  transform: translateY(10px);
  transition: opacity 0.3s ease, transform 0.3s ease;
  pointer-events: none; /* No interfiere con clics */
}

#midi-status-legend.is-visible {
  opacity: 1;
  transform: translateY(0);
}

#midi-status-legend i {
  font-size: 16px;
  color: #3498db; /* Ícono azul */
}

/* En desktop, no hay controles de velocidad, 
   así que podemos bajar la leyenda */
@media (min-width: 501px) {
  #midi-status-legend {
    bottom: 120px; /* Justo sobre el piano */
  }
}


#right-hand-only-btn.active,
#left-hand-only-btn.active {
  background-color: #e0e0e0 !important;
  color: #3498db !important;
  border-color: #3498db !important;
}

.key.midi-active {
  background-color: #e0e0e0 !important; /* Un gris claro sutil */
  box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.2) !important;
}

/* Para teclas blancas */
.key.white.midi-active {
  background-color: #e8e8e8 !important;
}

/* Para teclas negras */
.key.black.midi-active {
  background-color: #555555 !important;
  box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.4) !important;
}


.key-name {
  position: absolute;
  bottom: 5px;
  width: 100%;
  text-align: center;
  font-size: 10px;
  font-weight: bold;
  color: #333;
  pointer-events: none;
  z-index: 10;
  font-family: Arial, sans-serif;
}

/* Para teclas negras, ajustar posición */
.key.black .key-name {
  color: white;
  bottom: 3px;
  font-size: 8px;
}

/* Estilo para el botón activo */
#show-key-names-btn.active {
  background-color: #e0e0e0 !important;
  border-color: #3498db !important;
}

/* Mejorar contraste en teclas blancas con nombres */
.key.white.has-name {
  background: linear-gradient(to bottom, #fff 0%, #f5f5f5 100%);
}


.confetti {
  position: fixed;
  width: 10px;
  height: 10px;
  opacity: 0;
  /* Animación base que modificaremos con JS */
  animation: confetti-fall 5s ease-out forwards;
  z-index: 9999; /* Asegura que esté por encima de todo */
}

@keyframes confetti-fall {
  0% {
    transform: translateY(-10vh) rotate(0deg);
    opacity: 1;
  }
  100% {
    transform: translateY(110vh) rotate(720deg);
    opacity: 0;
  }
}

/* --- AÑADE ESTE BLOQUE DE CSS --- */

.practice-progress-display {
  font-size: 13px;
  color: #555;
  font-family: 'SF Mono', 'Menlo', 'monospace';
  background-color: #f5f5f5;
  padding: 8px 12px;
  border-radius: 6px;
  border: 1px solid #e0e0e0;
}

.practice-progress-display #progress-label {
  color: #999; /* Un color más sutil para la etiqueta */
}

.practice-progress-display #progress-value {
  font-weight: 600;
  color: #333; /* Color más fuerte para el valor */
  margin-left: 4px;
}

#ai-practice-btn.active {
  background-color: #e0e0e0 !important;
  border-color: #3498db !important;
}

.modal-content br {
  display: block;
  margin: 8px 0;
}

  </style>
</head>
<body>

  <div id="top-bar">
    <div class="controls-group">
      <button id="play-btn" class="btn" disabled>
        <svg id="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
        <svg id="pause-icon" viewBox="0 0 24 24" style="display:none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
      </button>

      <div id="time-display">
        <span id="current-time">0:00</span> / <span id="total-time">0:00</span>
      </div>
        <button id="midi-learn-btn" class="btn" title="Modo Aprendizaje MIDI">
  <i class="ri-graduation-cap-line"></i>
</button>
    </div>

    <div class="controls-group">
    
        <button id="tools-toggle-btn" class="btn" title="Herramientas de Dibujo">
        <i class="ri-settings-3-line"></i>
      </button>

          <button id="piano-btn" class="btn" >
       <img src="https://lh3.googleusercontent.com/d/1vMHUODAn781r96RNhefO3HWZrqtMM_0u=s96-c" style="height: 18.5px; width: 17.5px">
      </button>

     
      <div id="close-btn-placeholder"></div>
    </div>

    <input type="range" id="progress-bar" value="0" min="0" max="100" step="0.1">
  </div>

   <div id="secondary-top-bar">
    <div class="tool-group">
 <div id="zoom-controls">
      <img src="https://lh3.googleusercontent.com/d/1-xAqP72ng90dUlB4gGT32Tc6vycXZ6ob=s96-c" style="height: 18.5px; width: 17.5px; margin-left: 7px; margin-right: 5px;">
         <div class="speed-display">
        <span class="zoom-display" id="speed-bpm">120 BPM</span>
   </div>
        <div class="zoom-buttons">
            <button class="zoom-btn" id="speed-down-btn">−</button>
            <button class="zoom-btn" id="speed-up-btn">+</button>
        </div>
      </div>
    </div>
  
     <div class="tool-group">
        <button id="show-key-names-btn" class="btn" title="Mostrar nombres de teclas">
    <i class="ri-font-size"></i> 
  </button>
          <button id="cursor-btn" class="btn" >
   <i class="ri-layout-left-2-line"></i>
    </button>
  
         <div class="speed-group">
            <button id="zoom-out" class="btn speed-ctrl-btn">−</button>
            <div class="speed-display">
              <span class="speed-bpm" id="zoom-label">Zoom: 100%</span>
            </div>
            <button id="zoom-in" class="btn speed-ctrl-btn">+</button>
        </div>
         <button id="fullscreen-btn" class="btn" >
   <i class="ri-fullscreen-line"></i>
    </button>
    </div>
  </div>




   <div id="secondary-top-bar2" >
    <div class="tool-group">
  <button id="left-hand-only-btn" class="btn" title="Solo mano izquierda">
    <i class="ri-hand" style="transform: scaleX(-1); display: inline-block;"></i> I
  </button>
    <button id="right-hand-only-btn" class="btn" title="Solo mano derecha">
    <i class="ri-hand"></i> D
  </button>
    <button id="ai-practice-btn" class="btn" title="Práctica inteligente">
    <i class="ri-dvd-ai-line" style="margin-right: 7px;"></i> Práctica <br>Guiada
  </button>
    </div>
  
     <div class="tool-group">
        <div id="practice-progress" class="practice-progress-display">
          <span id="progress-label">Progreso:</span>
          <span id="progress-value">0%</span>
      </div>
         <select id="measure-select" class="btn" title="Ir al compás...">
    </select>
    </div>
  </div>

  <!-- Controles de zoom para móviles -->
 

  <div id="sheet-music-wrapper" style="position: relative;">
    <div id="osmd-container"></div>
    <canvas id="annotation-canvas" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
    
</div>
  <div id="status">Cargando...</div>

 
<div id="midi-status-legend"></div>

  <div id="piano-container">
    <canvas id="waterfall-canvas"></canvas>
  <div class="hit-line-piano"></div>
    <div id="piano-keys"></div>
  </div>


  <div id="midi-modal" class="modal-overlay" style="display: none;">
  <div class="modal-content">
    <p id="modal-message">Este es un mensaje de prueba.</p>
    <button id="modal-close-btn" class="btn closeBtn">Entendido</button>
  </div>
</div>

<div id="success-modal" class="modal-overlay" style="display: none;">
  <div class="modal-content">
    <p id="success-modal-message">¡Felicidades, has completado la pieza!</p>
    <button id="success-modal-close-btn" class="btn closeBtn">Continuar</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@latest/build/opensheetmusicdisplay.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>

  <script>
    const playBtn = document.getElementById('play-btn');
    const playIcon = document.getElementById('play-icon');
    const pauseIcon = document.getElementById('pause-icon');
    const pianoBtn = document.getElementById('piano-btn');
    const osmdContainer = document.getElementById('osmd-container');
    const statusDiv = document.getElementById('status');
    const pianoContainer = document.getElementById('piano-container');
    const pianoKeys = document.getElementById('piano-keys');
    const progressBar = document.getElementById('progress-bar');
    const progressBarContainer = document.getElementById('progress-bar-container');
    const speedBpmLabel = document.getElementById('speed-bpm');
   const speedUpBtn = document.getElementById('speed-up-btn');
const speedDownBtn = document.getElementById('speed-down-btn');
    const zoomInBtn = document.getElementById('zoom-in');
    const zoomOutBtn = document.getElementById('zoom-out');
    const zoomLabel = document.getElementById('zoom-label');
    const currentTimeSpan = document.getElementById('current-time');
const totalTimeSpan = document.getElementById('total-time');
const measureSelect = document.getElementById('measure-select');
const toolsToggleBtn = document.getElementById('tools-toggle-btn');
const secondaryTopBar = document.getElementById('secondary-top-bar');
const secondaryTopBar2 = document.getElementById('secondary-top-bar2');

const cursorBtn = document.getElementById('cursor-btn');
const fullscreenBtn = document.getElementById('fullscreen-btn');
const midiModal = document.getElementById('midi-modal');
const modalMessage = document.getElementById('modal-message');
const modalCloseBtn = document.getElementById('modal-close-btn');
const midiStatusLegend = document.getElementById('midi-status-legend');
const rightHandOnlyBtn = document.getElementById('right-hand-only-btn');
const leftHandOnlyBtn = document.getElementById('left-hand-only-btn');
let handFilterMode = 'both';
const showKeyNamesBtn = document.getElementById('show-key-names-btn');
let showKeyNames = false;
const successModal = document.getElementById('success-modal');
const successModalMessage = document.getElementById('success-modal-message');
const successModalCloseBtn = document.getElementById('success-modal-close-btn');
const practiceProgressDisplay = document.getElementById('practice-progress');
const progressValueSpan = document.getElementById('progress-value');
const aiPracticeBtn = document.getElementById('ai-practice-btn');

    let osmd = null;
    let sampler = null;
    let parsedNotes = [];
    let measureStartTimes = [];
    let globalTempo = 120;
    let playbackRate = 1.0;
    let currentSpeed = 1.0;
    let totalDuration = 0;
    let isPlaying = false;
    let audioPart = null;
    let visualPart = null;
    let progressInterval = null;
    let activeHighlightTimeouts = [];
    let currentZoom = 1.0;
    let isMobile = window.innerWidth <= 768;
    let pianoViewMode = 'full'; 


    let isIntelligentPracticeMode = false;
let currentPracticePhase = 'inactive'; // 'inactive', 'right-hand', 'left-hand', 'both-hands', 'consolidation'
let currentPracticeMeasureSet = 0; // Conjunto de 4 compases actual (0, 1, 2...)
let practiceAttemptNotes = []; // Notas tocadas en el intento actual
let practiceStartTime = null;
let practiceErrors = 0;
let practiceCorrectNotes = 0;
let accuracyThreshold = 70; 


let waterfallCanvas, waterfallCtx;
let waterfallAnimationId;
let pixelsPerSecond = 100;
let whiteKeyWidth = 16; // Ya no es const
let blackKeyWidth = 10; // Ya no es const
let waterfallScrollOffset = 0;

    // Script: al inicio, junto a las otras constantes
const midiLearnBtn = document.getElementById('midi-learn-btn');
let isMidiLearnMode = false;
let midiAccess = null;
let expectedNotes = new Set(); // Almacenará las notas que esperamos que el usuario toque
let currentLearningIndex = 0; // Para saber en qué nota de la partitura vamos





function initWaterfallCanvas() {
  waterfallCanvas = document.getElementById('waterfall-canvas');
  if (!waterfallCanvas) return;
  
  waterfallCtx = waterfallCanvas.getContext('2d');  
  resizeWaterfallCanvas();
  updateKeyDimensions()
  window.addEventListener('resize', resizeWaterfallCanvas);
}



function resizeWaterfallCanvas() {
  if (!waterfallCanvas) return;
  
  // Actualizar los tamaños de las teclas desde el DOM
  updateKeyDimensions();
  
  const container = pianoContainer;
  const dpr = window.devicePixelRatio || 1;
  
  waterfallCanvas.width = window.innerWidth * dpr;
  waterfallCanvas.height = (container.clientHeight - 102) * dpr;
  
  waterfallCanvas.style.width = `${window.innerWidth}px`;
  waterfallCanvas.style.height = `${container.clientHeight - 102}px`;
  
  // NUEVO: Ajustar pixelsPerSecond según la altura disponible
  const availableHeight = container.clientHeight - 102;
  
  if (pianoContainer.classList.contains('waterfall-only')) {
    // En modo waterfall-only, aumentar la velocidad para mostrar más notas
    pixelsPerSecond = availableHeight / 6; // Muestra aproximadamente 6 segundos de música
  } else {
    // En modo normal, velocidad estándar
    pixelsPerSecond = 100;
  }
  
  console.log(`Altura disponible: ${availableHeight}px, pixelsPerSecond: ${pixelsPerSecond}`);
}


function updateKeyDimensions() {
  // Leer el tamaño real de las teclas del DOM
  const whiteKey = document.querySelector('.key.white');
  const blackKey = document.querySelector('.key.black');
  
  if (whiteKey) {
    whiteKeyWidth = whiteKey.offsetWidth;
  }
  if (blackKey) {
    blackKeyWidth = blackKey.offsetWidth;
  }
  
  console.log(`Tamaños actualizados: white=${whiteKeyWidth}px, black=${blackKeyWidth}px`);
}

function getKeyXPosition(midiNote) {
  const firstMidiNote = 21; // A0
  const notePattern = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1]; // A A# B C C# D D# E F F# G G#
  
  let whiteKeyIndex = 0;
  for (let i = firstMidiNote; i < midiNote; i++) {
    const patternIndex = (i - firstMidiNote) % 12;
    if (notePattern[patternIndex] === 0) {
      whiteKeyIndex++;
    }
  }
  
  const patternIndex = (midiNote - firstMidiNote) % 12;
  const isBlack = notePattern[patternIndex] === 1;
  
  if (isBlack) {
    // Para teclas negras, posición centrada entre teclas blancas
    return (whiteKeyIndex * whiteKeyWidth) - (blackKeyWidth / 2);
  } else {
    return whiteKeyIndex * whiteKeyWidth;
  }
}

function pitchToMidiNumber(pitch) {
  const noteMap = {
    'C': 0, 'C#': 1, 'Db': 1,
    'D': 2, 'D#': 3, 'Eb': 3,
    'E': 4, 'Fb': 4,
    'F': 5, 'E#': 5, 'F#': 6, 'Gb': 6,
    'G': 7, 'G#': 8, 'Ab': 8,
    'A': 9, 'A#': 10, 'Bb': 10,
    'B': 11, 'Cb': 11,
    // Dobles sostenidos
    'C##': 2, 'D##': 4, 'E##': 6, 'F##': 8, 'G##': 10, 'A##': 0, 'B##': 1,
    // Dobles bemoles
    'Dbb': 0, 'Ebb': 2, 'Fbb': 3, 'Gbb': 5, 'Abb': 7, 'Bbb': 9, 'Cbb': 10
  };
  
  // Regex mejorado para capturar dobles alteraciones y bemoles
  const match = pitch.match(/^([A-G])(bb|##|b|#)?(\d+)$/);
  if (!match) {
    console.warn(`No se pudo convertir pitch a MIDI: ${pitch}`);
    return -1;
  }
  
  const [, noteLetter, alteration, octave] = match;
  const noteWithAlt = noteLetter + (alteration || '');
  
  if (!(noteWithAlt in noteMap)) {
    console.warn(`Nota no reconocida en noteMap: ${noteWithAlt}`);
    return -1;
  }
  
  let chromaticValue = noteMap[noteWithAlt];
  let finalOctave = parseInt(octave);
  
  // Ajustes de octava para casos especiales
  if (noteWithAlt === 'Cb' || noteWithAlt === 'Cbb') {
    finalOctave -= 1;
  } else if (noteWithAlt === 'B#' || noteWithAlt === 'B##') {
    finalOctave += 1;
  } else if (noteWithAlt === 'A##') {
    finalOctave += 1; // A## = B del siguiente octava
  }
  
  return (finalOctave + 1) * 12 + chromaticValue;
}

function drawWaterfall() {
  if (!waterfallCtx || !waterfallCanvas) return;
  
  const dpr = window.devicePixelRatio || 1;
  waterfallCtx.clearRect(0, 0, waterfallCanvas.width, waterfallCanvas.height);
  waterfallCtx.fillStyle = '#2a2a2a';
  waterfallCtx.fillRect(0, 0, waterfallCanvas.width, waterfallCanvas.height);
  
  const canvasHeight = waterfallCanvas.height / dpr;
  const totalWhiteKeys = 52;
  const pianoTotalWidth = totalWhiteKeys * whiteKeyWidth;
  const offset = whiteKeyWidth === 16 ? -16 : -12; // -16 para full, -12 para reducido
const pianoStartX = (waterfallCanvas.width / dpr - pianoTotalWidth) / 2 + offset;
  
  // Patrón corregido empezando desde A
  const notePattern = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1]; // A A# B C C# D D# E F F# G G#
  
  // Primero dibujar todas las notas blancas
  parsedNotes.forEach(note => {
    if (note.isRest) return;
    
    const midiNote = pitchToMidiNumber(note.pitch);
    if (midiNote < 21 || midiNote > 108) return;
    
    const patternIndex = (midiNote - 21) % 12;
    const isBlack = notePattern[patternIndex] === 1;
    
    // Solo procesar notas blancas en este primer paso
    if (isBlack) return;
    
    const noteStartY = canvasHeight - ((note.startSec - waterfallScrollOffset) * pixelsPerSecond);
    const noteEndY = noteStartY - (note.durSec * pixelsPerSecond);
    
    if (noteEndY < canvasHeight && noteStartY > 0) {
      const keyX = pianoStartX + getKeyXPosition(midiNote);
      const height = Math.max(1, noteStartY - noteEndY);
      
      waterfallCtx.shadowBlur = 40 * dpr;
      
      if (note.hand === 'treble') {
        waterfallCtx.shadowColor = '#60a5fa';
        waterfallCtx.fillStyle = '#60a5fa';
      } else {
        waterfallCtx.shadowColor = '#de9e37';
        waterfallCtx.fillStyle = '#de9e37';
      }
      
      waterfallCtx.fillRect(
        keyX * dpr,
        noteEndY * dpr,
        (whiteKeyWidth - 2) * dpr,
        height * dpr
      );
    }
  });
  
  // Luego dibujar todas las notas negras (sobre las blancas)
  parsedNotes.forEach(note => {
    if (note.isRest) return;
    
    const midiNote = pitchToMidiNumber(note.pitch);
    if (midiNote < 21 || midiNote > 108) return;
    
    const patternIndex = (midiNote - 21) % 12;
    const isBlack = notePattern[patternIndex] === 1;
    
    // Solo procesar notas negras en este segundo paso
    if (!isBlack) return;
    
    const noteStartY = canvasHeight - ((note.startSec - waterfallScrollOffset) * pixelsPerSecond);
    const noteEndY = noteStartY - (note.durSec * pixelsPerSecond);
    
    if (noteEndY < canvasHeight && noteStartY > 0) {
      const keyX = pianoStartX + getKeyXPosition(midiNote);
      const height = Math.max(1, noteStartY - noteEndY);
      
      waterfallCtx.shadowBlur = 30 * dpr;
      
      if (note.hand === 'treble') {
        waterfallCtx.shadowColor = '#3b82f6';
        waterfallCtx.fillStyle = '#3b82f6';
      } else {
        waterfallCtx.shadowColor = '#b45309';
        waterfallCtx.fillStyle = '#b45309';
      }
      
      waterfallCtx.fillRect(
        keyX * dpr,
        noteEndY * dpr,
        (blackKeyWidth - 1) * dpr,
        height * dpr
      );
    }
  });
  
  waterfallCtx.shadowBlur = 0;
}

function animateWaterfall() {
    
    // SI ESTÁ EN CUALQUIER MODO DE APRENDIZAJE (normal O inteligente)
    if (isMidiLearnMode) {
        
        // Mover el waterfall al tiempo de la nota anterior (para "esperarla")
        if (currentLearningIndex > 0 && parsedNotes[currentLearningIndex - 1]) {
            waterfallScrollOffset = parsedNotes[currentLearningIndex - 1].startSec;
        } else {
            // Si estamos al principio (índice 0), el offset es 0
            waterfallScrollOffset = 0;
        }

    } else if (Tone.Transport.state === 'started') {
        // Modo de reproducción normal
        waterfallScrollOffset = Tone.Transport.seconds;
    }
    
    drawWaterfall();
    waterfallAnimationId = requestAnimationFrame(animateWaterfall);
}

function createNoteFlashPiano(noteName, hand) {
  const midiNote = pitchToMidiNumber(noteName);
  if (midiNote < 21 || midiNote > 108) return;
  
  const flash = document.createElement('div');
  flash.className = 'note-flash-piano flash-active';
  
  const totalWhiteKeys = 52;
  const pianoTotalWidth = totalWhiteKeys * whiteKeyWidth;
  
  // Usar el mismo offset que en drawWaterfall
  const offset = whiteKeyWidth === 16 ? -16 : -12;
  const pianoStartX = (window.innerWidth - pianoTotalWidth) / 2 + offset;
  
  const keyX = getKeyXPosition(midiNote);
  const notePattern = [0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1];
  const isBlack = notePattern[(midiNote - 21) % 12] === 1;
  const keyWidth = isBlack ? blackKeyWidth : whiteKeyWidth;
  const flashX = pianoStartX + keyX + (keyWidth / 2);
  
  flash.style.left = flashX + 'px';
  
  pianoContainer.appendChild(flash);
  
  setTimeout(() => {
    flash.remove();
  }, 400);
}


   document.addEventListener('DOMContentLoaded', async () => {
  setStatus('Inicializando...');
  initOSMD();
  createPiano88Keys();
  updateKeyDimensions();
  addEventListeners();
  initSampler();
  initMidiInput();
  initWaterfallCanvas(); 
  animateWaterfall(); 
  
  setStatus('Cargando sonidos de piano...');
  await Tone.loaded();
  setStatus('Cargando partitura...');


  const urlParams = new URLSearchParams(window.location.search);
  const fileId = urlParams.get('file'); 
  if (fileId) {

    const dynamicUrl = `https://storage.googleapis.com/mozartacademy-files/xml/${encodeURIComponent(fileId)}`;
    await loadMusicXMLFromUrl(dynamicUrl);

  } else {
    setStatus('Error: No se ha especificado ningún archivo para cargar. Añade "?file=tu-archivo.musicxml" a la URL.');
    playBtn.disabled = true; 
  }



});

    function initOSMD() {
      try {
        osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay(osmdContainer, {
          backend: 'svg',
          drawTitle: true,
          drawSubtitle: true,   
          drawComposer: true, 
          followCursor: true,
          drawPartNames: false,
          autoResize: true,
          drawingParameters: "width",
          drawMeasureNumbers: false,
          cursorsOptions: [{ 
            type: 1, 
            color: "rgba(52,152,219,0.8)", 
            alpha: 0.8, 
            follow: true 
          }]
        });
        
        // Configuración para pantallas grandes (hasta 4 compases por línea)
        setupEngravingRulesForScreenSize();
        
      } catch (e) { 
        setStatus('Error al inicializar'); 
      }
    }

    function setupEngravingRulesForScreenSize() {
      if (!osmd || !osmd.EngravingRules) return;
      
      const width = window.innerWidth;
      
      if (width <= 480) {
        // Pantallas muy pequeñas - máxima compresión
        osmd.EngravingRules.SystemMaxMeasuresCount = 4;
        osmd.EngravingRules.MinimumDistanceBetweenNotes = 0.8;
        osmd.EngravingRules.MinimumDistanceBetweenStaffLines = 2.0;
        osmd.EngravingRules.StaffDistance = 2.8;
        osmd.EngravingRules.StaffLineWidth = 0.06;
        osmd.EngravingRules.NoteHeadWidth = 0.8;
        osmd.zoom = 0.5;
        currentZoom = 0.5;
      } else if (width <= 768) {
        // Tablets y móviles grandes
        osmd.EngravingRules.SystemMaxMeasuresCount = 4;
        osmd.EngravingRules.MinimumDistanceBetweenNotes = 1.0;
        osmd.EngravingRules.MinimumDistanceBetweenStaffLines = 2.2;
        osmd.EngravingRules.StaffDistance = 3.0;
        osmd.EngravingRules.StaffLineWidth = 0.07;
        osmd.EngravingRules.NoteHeadWidth = 0.9;
        osmd.zoom = 0.7;
        currentZoom = 0.7;
      } else {
        // Pantallas de escritorio
        osmd.EngravingRules.SystemMaxMeasuresCount = 4;
        osmd.EngravingRules.MinimumDistanceBetweenNotes = 1.2;
        osmd.EngravingRules.MinimumDistanceBetweenStaffLines = 2.5;
        osmd.EngravingRules.StaffDistance = 3.5;
        osmd.EngravingRules.StaffLineWidth = 0.08;
        osmd.EngravingRules.NoteHeadWidth = 1.0;
        osmd.zoom = 0.8;
        currentZoom = 0.8;
      }
      
      updateZoomDisplay();
    }

function updateMidiStatusLegend(deviceName = null) {
  if (deviceName) {
    midiStatusLegend.innerHTML = `<i class="ri-plug-line"></i> ${deviceName} Conectado`;
    midiStatusLegend.classList.add('is-visible');
  } else {
    midiStatusLegend.classList.remove('is-visible');
  }
}

    function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    // Añade un cero a la izquierda si los segundos son menores a 10
    const formattedSeconds = remainingSeconds < 10 ? '0' + remainingSeconds : remainingSeconds;
    return `${minutes}:${formattedSeconds}`;
}

    /*
    function initSampler() {
      sampler = new Tone.Sampler({
        urls: { 
          "C4": "C4.mp3", 
          "D#4": "Ds4.mp3", 
          "F#4": "Fs4.mp3", 
          "A4": "A4.mp3" 
        },
        release: 1,
        baseUrl: "https://tonejs.github.io/audio/salamander/"
      }).toDestination();
    } 
    */

    function initSampler() {
      sampler = new Tone.Sampler({
        urls: { 
          "C1": "C1.mp3",
          "D#1": "Ds1.mp3",
          "F#1": "Fs1.mp3",
          "A1": "A1.mp3",
          "C2": "C2.mp3",
          "D#2": "Ds2.mp3",
          "F#2": "Fs2.mp3",
          "A2": "A2.mp3",
          "C3": "C3.mp3",
          "D#3": "Ds3.mp3",
          "F#3": "Fs3.mp3",
          "A3": "A3.mp3",
          "C4": "C4.mp3",
          "D#4": "Ds4.mp3",
          "F#4": "Fs4.mp3",
          "A4": "A4.mp3",
          "C5": "C5.mp3",
          "D#5": "Ds5.mp3",
          "F#5": "Fs5.mp3",
          "A5": "A5.mp3",
          "C6": "C6.mp3",
          "D#6": "Ds6.mp3",
          "F#6": "Fs6.mp3",
          "A6": "A6.mp3",
          "C7": "C7.mp3",
        },
        attack: 0.01,    // Ataque casi instantáneo (como piano real)
        decay: 0.2,      // Caída rápida inicial 
        sustain: 0.3,    // Nivel de sostenido (30% del volumen máximo)
        release: 3.5, 
        baseUrl: "https://tonejs.github.io/audio/salamander/"
      }).toDestination();
    }

    function createPiano88Keys() {
      pianoKeys.innerHTML = '';
      const pattern = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
      const blackKeys = { 'C': 'C#', 'D': 'D#', 'F': 'F#', 'G': 'G#', 'A': 'A#' };
      
      // Piano de 88 teclas: A0 a C8
      for (let octave = 0; octave <= 8; octave++) {
        const startNote = octave === 0 ? 9 : 0;
        
        for (let i = startNote; i <= 6; i++) {
          if (octave === 0 && i < 9) continue;
          if (octave === 8 && i > 0) break;
          
          const note = pattern[i % 7];
          const whiteKey = document.createElement('div');
          whiteKey.className = 'key white';
          whiteKey.id = `${note}${octave}`;
          pianoKeys.appendChild(whiteKey);
          
          if (blackKeys[note] && !(octave === 8 && note === 'C')) {
            const blackKey = document.createElement('div');
            blackKey.className = 'key black';
            blackKey.id = `${blackKeys[note]}${octave}`;
            pianoKeys.appendChild(blackKey);
          }
        }
      }
    }

    async function loadMusicXMLFromUrl(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Error de red');
        const text = await response.text();
        await osmd.load(text);
        osmdContainer.innerHTML = ''; 

        setupEngravingRulesForScreenSize();
        
        await osmd.render();
        populateMeasureSelector();
        
        parseMusicXML(text);
        scheduleNotesOnTransport();

        playBtn.disabled = false;
        setStatus('');
      } catch (err) {
        setStatus(`Error: ${err.message}`);
      }
    }


function parseMusicXML(xmlText) {
    parsedNotes = [];
    measureStartTimes = [0];
    const parser = new DOMParser();
    const xml = parser.parseFromString(xmlText, "application/xml");

    const divisions = parseInt(xml.querySelector("divisions")?.textContent.trim() || "24", 10);
    const soundTempo = xml.querySelector("direction sound[tempo], sound[tempo]");
    globalTempo = soundTempo ? parseFloat(soundTempo.getAttribute("tempo")) : 120;
    updateBpmDisplay();
    Tone.Transport.bpm.value = globalTempo;

    const openTies = new Map(); // pitch+staff+voice -> noteObject
    
    xml.querySelectorAll('part').forEach((part, partIndex) => {
        let currentBeat = 0;

        const clefSign = part.querySelector('measure[number="1"] clef sign')?.textContent;
        const defaultHand = (clefSign === 'F') ? 'bass' : 'treble';

        const measures = part.querySelectorAll('measure');
        measures.forEach((measure, measureIndex) => {
            if (partIndex === 0 && measureIndex > 0) {
                measureStartTimes.push(currentBeat * (60.0 / globalTempo));
            }
            
            const nodes = measure.querySelectorAll('note, backup, forward');
            nodes.forEach(node => {
                const durationVal = parseFloat(node.querySelector('duration')?.textContent.trim() || '0');
                const durationInBeats = durationVal / divisions;

                if (node.tagName === 'note') {
                    const isChord = !!node.querySelector('chord');
                    
                    if (!isChord) {
                        currentBeat += durationInBeats;
                    }
                    
                    if (!node.querySelector('rest') && node.querySelector('pitch')) {
                        const step = node.querySelector('step')?.textContent?.trim();
                        const octave = node.querySelector('octave')?.textContent?.trim();
                        const alterElement = node.querySelector('alter');
                        const altValue = alterElement ? parseInt(alterElement.textContent.trim(), 10) : 0;

                        // Manejar todas las alteraciones posibles
                        let accidental = '';
                        if (altValue === 2) accidental = '##';
                        else if (altValue === 1) accidental = '#';
                        else if (altValue === -1) accidental = 'b';
                        else if (altValue === -2) accidental = 'bb';

                        const pitch = `${step}${accidental}${octave}`;
                        
                        const staffNumber = parseInt(node.querySelector('staff')?.textContent);
                        const hand = !isNaN(staffNumber) ? (staffNumber === 1 ? 'treble' : 'bass') : defaultHand;
                        
                        const voice = node.querySelector('voice')?.textContent || '1';

                        const isTieStart = !!node.querySelector('tie[type="start"]');
                        const isTieStop = !!node.querySelector('tie[type="stop"]');
                        
                        const tieKey = `${pitch}-${hand}-${voice}`;

                        if (isTieStop && openTies.has(tieKey)) {
                            // CONTINUACIÓN DE LIGADURA
                            const existingNote = openTies.get(tieKey);
                            
                            // Crear una nota visual separada (para el cursor)
                            const noteStartTime = (currentBeat - durationInBeats) * (60.0 / globalTempo);
                            const continuationNote = {
                                pitch: pitch,
                                startSec: noteStartTime,
                                durSec: durationInBeats * (60.0 / globalTempo),
                                hand: hand,
                                isTied: true,
                                isTiedContinuation: true, // NUEVA PROPIEDAD
                                isChord: isChord
                            };
                            parsedNotes.push(continuationNote);
                            
                            // Extender la duración de la nota original (para el audio)
                            existingNote.durSec += durationInBeats * (60.0 / globalTempo);
                            
                            if (!isTieStart) {
                                openTies.delete(tieKey);
                            }
                        } else {
                            // NOTA NUEVA
                            const noteStartTime = (currentBeat - durationInBeats) * (60.0 / globalTempo);
                            
                            const newNote = {
                                pitch: pitch,
                                startSec: noteStartTime,
                                durSec: durationInBeats * (60.0 / globalTempo),
                                hand: hand,
                                isTied: isTieStart,
                                isTiedContinuation: false, // NUEVA PROPIEDAD
                                isChord: isChord
                            };
                            parsedNotes.push(newNote);

                            if (isTieStart) {
                                openTies.set(tieKey, newNote);
                            }
                        }
                    }else if (node.querySelector('rest')) {

                        const noteStartTime = (currentBeat - durationInBeats) * (60.0 / globalTempo);
                        
                        const staffNumber = parseInt(node.querySelector('staff')?.textContent);
                        const hand = !isNaN(staffNumber) ? (staffNumber === 1 ? 'treble' : 'bass') : defaultHand;
                        
                        const restNote = {
                            pitch: null, // null indica que es un silencio
                            startSec: noteStartTime,
                            durSec: durationInBeats * (60.0 / globalTempo),
                            hand: hand,
                            isRest: true, // NUEVA PROPIEDAD
                            isTied: false,
                            isTiedContinuation: false,
                            isChord: isChord
                        };
                        parsedNotes.push(restNote);
                    }
                } else if (node.tagName === 'backup') {
                    currentBeat -= durationInBeats;
                } else if (node.tagName === 'forward') {
                    currentBeat += durationInBeats;
                }
            });
        });
    });

    if (openTies.size > 0) {
        console.warn('Advertencia: Se encontraron ligaduras sin cerrar:', Array.from(openTies.keys()));
    }

    parsedNotes.sort((a, b) => a.startSec - b.startSec);
    const lastNote = parsedNotes[parsedNotes.length - 1];
    totalDuration = lastNote ? lastNote.startSec + lastNote.durSec : 0;
    totalTimeSpan.textContent = formatTime(totalDuration);
}


function scheduleNotesOnTransport() {
  if (audioPart) audioPart.dispose();
  if (visualPart) visualPart.dispose();
  Tone.Transport.cancel();
  osmd.cursor.reset();
  osmd.cursor.hide();

  const TIME_TOLERANCE = 0.001;
  
  const notesByTime = new Map();
  parsedNotes.forEach(note => {
    const time = note.startSec / playbackRate;
    
    let foundTime = null;
    for (let existingTime of notesByTime.keys()) {
      if (Math.abs(existingTime - time) < TIME_TOLERANCE) {
        foundTime = existingTime;
        break;
      }
    }
    
    if (foundTime !== null) {
      notesByTime.get(foundTime).push(note);
    } else {
      notesByTime.set(time, [note]);
    }
  });

  // Audio: solo notas reales (sin silencios)
  const audioEvents = [];
  notesByTime.forEach((notes, time) => {
    const realNotes = notes.filter(n => !n.isRest && !n.isTiedContinuation); // NUEVO: Filtrar silencios
    
    if (realNotes.length > 0) {
      const uniquePitches = new Set();
      const uniqueNotes = realNotes.filter(note => {
        const normalizedPitch = normalizeNote(note.pitch);
        if (uniquePitches.has(normalizedPitch)) {
          return false;
        }
        uniquePitches.add(normalizedPitch);
        return true;
      });
      
      audioEvents.push({
        time: time,
        pitches: uniqueNotes.map(n => n.pitch),
        duration: uniqueNotes[0].durSec / playbackRate,
      });
    }
  });
  
  audioPart = new Tone.Part((time, value) => {
    sampler.triggerAttackRelease(value.pitches, value.duration, time);
  }, audioEvents).start(0);

  // Visual: todas las notas (incluyendo silencios para avanzar el cursor)
  const visualEvents = [];
  notesByTime.forEach((notes, time) => {
    const uniquePitches = new Set();
    const uniqueNotes = notes.filter(note => {
      if (note.isRest) return true; // NUEVO: Mantener silencios
      
      const normalizedPitch = normalizeNote(note.pitch);
      if (uniquePitches.has(normalizedPitch)) {
        return false;
      }
      uniquePitches.add(normalizedPitch);
      return true;
    });
    
    visualEvents.push({ 
      time, 
      notes: uniqueNotes.map(n => ({...n, duration: n.durSec / playbackRate}))
    });
  });

  visualPart = new Tone.Part((time, value) => {
    Tone.Draw.schedule(() => {
      if (value.notes.length > 0) {
        osmd.cursor.next();
      }
      // MODIFICADO: Solo hacer highlight de notas reales
      value.notes.forEach(note => {
        if (!note.isRest && !note.isTiedContinuation) {
          highlightKey(note.pitch, note.duration, note.hand);
        }
      });
    }, time);
  }, visualEvents).start(0);
  
  const newTotalDuration = totalDuration / playbackRate;
  Tone.Transport.scheduleOnce(() => stopPlayback(), newTotalDuration + 0.5);
}



function updatePracticeProgress() {
    if (parsedNotes.length === 0) {
        progressValueSpan.textContent = '0%';
        return;
    }
    const percentage = Math.floor((currentLearningIndex / parsedNotes.length) * 100);
    progressValueSpan.textContent = `${Math.min(percentage, 100)}%`;
}

function updateMeasureSelectDisplay() {
    // Si estamos al principio o fuera de los límites, resetea al compás 1.
    if (currentLearningIndex === 0 || currentLearningIndex > parsedNotes.length) {
        measureSelect.value = 0;
        return;
    }
    const currentNoteTime = parsedNotes[currentLearningIndex - 1].startSec;

    let currentMeasureIndex = 0;
    for (let i = measureStartTimes.length - 1; i >= 0; i--) {
        // Usamos una pequeña tolerancia (0.001s)
        if (currentNoteTime >= measureStartTimes[i] - 0.001) {
            currentMeasureIndex = i;
            break;
        }
    }

    // Actualiza el valor del dropdown
    measureSelect.value = currentMeasureIndex;
}

function jumpToMeasureInLearnMode(measureIndex) {
    if (!isMidiLearnMode) return;

    const startTime = measureStartTimes[measureIndex] || 0;
    let newIndex = 0;
    for (let i = 0; i < parsedNotes.length; i++) {
        // Usamos una pequeña tolerancia
        if (parsedNotes[i].startSec >= startTime - 0.001) { 
            newIndex = i;
            break;
        }
    }
    currentLearningIndex = newIndex;
    osmd.cursor.reset();
    let uniqueTimeSteps = new Set();
    for(let i = 0; i < currentLearningIndex; i++) {
        if (i === 0 || (parsedNotes[i].startSec > parsedNotes[i-1].startSec + 0.001)) {
           uniqueTimeSteps.add(parsedNotes[i].startSec);
        }
    }
    uniqueTimeSteps.forEach(() => {
        osmd.cursor.next();
    });
    prepareFirstLearningStep(); 
    measureSelect.value = measureIndex;
}


function playFromMeasure(measureIndex) {
  // ¡NUEVO! Limpia los highlights antes de empezar desde un nuevo punto.
  clearAllHighlights();

  if (Tone.Transport.state === 'started') stopPlayback();
  
  const startTime = measureStartTimes[measureIndex] || 0;
  
  // Resetear cursor visual
  osmd.cursor.reset();
  
  // Avanzar el cursor hasta la posición correcta
  let currentTime = -1;
  parsedNotes.forEach(note => {
      if (note.startSec < startTime && note.startSec !== currentTime) {
          osmd.cursor.next();
          currentTime = note.startSec;
      }
  });
  
  // Iniciar reproducción
  Tone.Transport.start(Tone.now() + 0.1, startTime / playbackRate);
  updatePlayButton(true);
  osmd.cursor.show();
  startProgressUpdate();
}

   function stopPlayback() {
  Tone.Transport.stop();
  osmd.cursor.reset();
  osmd.cursor.hide();
  updatePlayButton(false);
  stopProgressUpdate();
  
  // ¡NUEVO! Usa la función de limpieza total para apagar todas las teclas.
  clearAllHighlights();
  waterfallScrollOffset = 0;

  progressBar.value = 0;
  progressBar.style.setProperty('--progress', '0%');
  currentTimeSpan.textContent = '0:00'; 
}

function startProgressUpdate() {
    stopProgressUpdate();
    progressInterval = setInterval(() => {
        // Obtenemos el tiempo actual de Tone.js
        const currentTime = Tone.Transport.seconds;
      
        // Corregimos la duración total para que coincida con la velocidad de reproducción
        const effectiveTotalDuration = totalDuration / playbackRate;
        const progress = (currentTime / effectiveTotalDuration) * 100;

        progressBar.value = Math.min(progress, 100);
        progressBar.style.setProperty('--progress', `${progress}%`);

        // --- LÍNEA NUEVA ---
        // Actualiza el texto con el tiempo actual formateado
        currentTimeSpan.textContent = formatTime(currentTime);

    }, 100); // Se actualiza 10 veces por segundo
}

    function stopProgressUpdate() {
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
    }

    function addEventListeners() {
     playBtn.addEventListener('click', async () => {
  await Tone.start();
  if (Tone.Transport.state === 'started') {
    Tone.Transport.pause();
    updatePlayButton(false);
    stopProgressUpdate();
    activeHighlightTimeouts.forEach(clearTimeout);
    activeHighlightTimeouts = [];

  } else {
    clearAllHighlights(); 
    
    Tone.Transport.start(Tone.now() + 0.1);
    updatePlayButton(true);
    osmd.cursor.show();
    startProgressUpdate();
  }
});

      // CONTROL DE VELOCIDAD CORREGIDO
  const speedStep = 0.05; // Cuánto cambiará la velocidad con cada clic

function updateSpeed(newRate) {
    // Detener la reproducción si está activa
    if (Tone.Transport.state === 'started') {
        stopPlayback();
    } 
    
    // Limitar la velocidad entre 0.25x y 2.0x
    playbackRate = Math.max(0.25, Math.min(2.0, newRate));
    
    // Actualizar la interfaz
    const currentBPM = Math.round(globalTempo * playbackRate);
    speedBpmLabel.textContent = `${currentBPM} BPM`;
    
    // Volver a programar las notas con la nueva velocidad
    scheduleNotesOnTransport();
}

 rightHandOnlyBtn.addEventListener('click', toggleRightHandOnly);
  leftHandOnlyBtn.addEventListener('click', toggleLeftHandOnly);
  showKeyNamesBtn.addEventListener('click', toggleKeyNames);

speedUpBtn.addEventListener('click', () => {
    updateSpeed(playbackRate + speedStep);
});

speedDownBtn.addEventListener('click', () => {
    updateSpeed(playbackRate - speedStep);
});
 
      pianoBtn.addEventListener('click', () => {
        togglePianoView();
      });
      
      // Controles de zoom
      zoomInBtn.addEventListener('click', () => {
        currentZoom = Math.min(2.0, currentZoom + 0.1);
        applyZoom();
      });
      
      zoomOutBtn.addEventListener('click', () => {
        currentZoom = Math.max(0.5, currentZoom - 0.1);
        applyZoom();
      });

      successModalCloseBtn.addEventListener('click', hideSuccessModal);

 
      midiLearnBtn.addEventListener('click', toggleMidiLearnMode);
      
      // Redimensionar ventana
window.addEventListener('resize', () => {
  const newIsMobile = window.innerWidth <= 768;
  if (newIsMobile !== isMobile) {
    isMobile = newIsMobile;
    if (osmd) {
      setupEngravingRulesForScreenSize();
      osmd.render();
    }
  }
  // Redimensionar el canvas del waterfall con los nuevos tamaños de teclas
  if (waterfallCanvas) {
    resizeWaterfallCanvas();
  }
});
      
 cursorBtn.addEventListener('click', toggleCursorType);
  fullscreenBtn.addEventListener('click', toggleFullScreen);

  // Opcional pero recomendado: Actualiza el ícono si el usuario sale con la tecla ESC
  document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) {
      fullscreenBtn.querySelector('i').className = 'ri-fullscreen-line';
    }
  });

progressBar.addEventListener('input', () => {
  // 1. Calcula a qué tiempo quiere saltar el usuario (en segundos)
  const seekTime = (progressBar.value / 100) * totalDuration;

  const progressValue = (progressBar.value / 100) * 100; // El valor ya es 0-100
progressBar.style.setProperty('--progress', `${progressValue}%`);

  // 2. Encuentra a qué compás corresponde ese tiempo
  let targetMeasureIndex = 0;
  for (let i = 0; i < measureStartTimes.length; i++) {
    if (measureStartTimes[i] <= seekTime) {
      targetMeasureIndex = i;
    } else {
      break;
    }
  }

  // 3. Llama a tu función para reproducir desde ese compás
  // Esto mantiene el cursor visual y el audio perfectamente sincronizados.
  playFromMeasure(targetMeasureIndex);
});

    measureSelect.addEventListener('change', () => {
        const selectedMeasureIndex = parseInt(measureSelect.value, 10);
        jumpToMeasureInLearnMode(selectedMeasureIndex);
        //playFromMeasure(selectedMeasureIndex);
    });

      toolsToggleBtn.addEventListener('click', () => {
        secondaryTopBar.classList.toggle('is-visible');
    });

     modalCloseBtn.addEventListener('click', hideModal);

     aiPracticeBtn.addEventListener('click', toggleIntelligentPracticeMode);


    }


function toggleKeyNames() {
  showKeyNames = !showKeyNames;
  
  if (showKeyNames) {
    showKeyNamesBtn.style.background = '#e0e0e0';
    showKeyNamesOnPiano();
  } else {
    showKeyNamesBtn.style.background = 'none';
    hideKeyNamesOnPiano();
  }
  
  console.log(`Mostrar nombres de teclas: ${showKeyNames}`);
}

function togglePianoView() {
    // Ciclo: full -> waterfall-only -> piano-only -> full
    if (pianoViewMode === 'full') {
        pianoViewMode = 'waterfall-only';
        pianoContainer.classList.remove('piano-only');
        pianoContainer.classList.add('waterfall-only');
        document.getElementById('sheet-music-wrapper').style.display = 'none';
        pianoBtn.style.backgroundColor = '#e0e0e0';
    } else if (pianoViewMode === 'waterfall-only') {
        pianoViewMode = 'piano-only';
        pianoContainer.classList.remove('waterfall-only');
        pianoContainer.classList.add('piano-only');
        document.getElementById('sheet-music-wrapper').style.display = 'block';
        pianoBtn.style.backgroundColor = '#d0d0d0';
    } else {
        pianoViewMode = 'full';
        pianoContainer.classList.remove('piano-only');
        document.getElementById('sheet-music-wrapper').style.display = 'block';
        pianoBtn.style.backgroundColor = 'transparent';
    }
    
    // NUEVO: Recalcular el tamaño del canvas y pixelsPerSecond
    setTimeout(() => {
        resizeWaterfallCanvas();
    }, 100);
    
    console.log('Piano View Mode:', pianoViewMode);
}
// Función para mostrar nombres en las teclas blancas
function showKeyNamesOnPiano() {
  const whiteKeys = document.querySelectorAll('.key.white');
  
  whiteKeys.forEach(key => {
    const noteName = key.id.replace('#', '');
    const displayName = getAngloSaxonNoteName(noteName);
    
    // Crear elemento para el nombre
    const nameElement = document.createElement('div');
    nameElement.className = 'key-name';
    nameElement.textContent = displayName;
    nameElement.style.cssText = `
      position: absolute;
      bottom: 5px;
      width: 100%;
      text-align: center;
      font-size: 10px;
      font-weight: bold;
      color: #333;
      pointer-events: none;
      z-index: 10;
    `;
    
    key.appendChild(nameElement);
    key.classList.add('has-name');
  });
}

// Función para ocultar nombres de las teclas
function hideKeyNamesOnPiano() {
  const keyNames = document.querySelectorAll('.key-name');
  keyNames.forEach(nameElement => {
    nameElement.remove();
  });
  
  const keysWithNames = document.querySelectorAll('.key.has-name');
  keysWithNames.forEach(key => {
    key.classList.remove('has-name');
  });
}

// Función para convertir a sistema anglosajón
function getAngloSaxonNoteName(noteId) {
  // Mapa de conversión para notas con sostenidos
  const noteMap = {
    'C': 'C', 'C#': 'C#',
    'D': 'D', 'D#': 'D#', 
    'E': 'E',
    'F': 'F', 'F#': 'F#',
    'G': 'G', 'G#': 'G#',
    'A': 'A', 'A#': 'A#',
    'B': 'B'
  };
  
  // Extraer la nota y la octava (ej: "C4", "D#5")
  const noteMatch = noteId.match(/^([A-G]#?)(\d+)$/);
  if (noteMatch) {
    const note = noteMatch[1];
    const octave = noteMatch[2];
    return `${noteMap[note] || note}`;
  }
  
  return noteId; // Fallback
}

function populateMeasureSelector() {
    const measureCount = osmd.sheet.SourceMeasures.length;
    measureSelect.innerHTML = ''; // Limpiamos opciones previas

    for (let i = 0; i < measureCount; i++) {
        const option = document.createElement('option');
        option.value = i; // El valor será el índice del compás (0, 1, 2...)
        option.textContent = `Compás ${i + 1}`; // El texto para el usuario (1, 2, 3...)
        measureSelect.appendChild(option);
    }
}


function toggleCursorType() {
  if (!osmd || !osmd.cursor) return;

  // CORRECCIÓN: Se usa .cursorOptions en lugar de .Options
  const newType = osmd.cursor.cursorOptions.type === 1 ? 3 : 1;
  osmd.cursor.cursorOptions.type = newType;

  // Cambia el color del botón para dar feedback visual
  if (newType === 3) {
    cursorBtn.style.color = '#3498db'; 
     osmd.cursor.cursorOptions.alpha = 0.45;
    osmd.cursor.cursorOptions.color = "rgba(52, 152, 219, 0.45)";
  } else {
    cursorBtn.style.color = '#1a1a1a'; 
    osmd.cursor.cursorOptions.alpha =0.8;
    osmd.cursor.cursorOptions.color = "rgba(52, 152, 219, 0.8)";
  }
}

function clearAllHighlights() {
  // OPTIMIZACIÓN: Limpiar timeouts más rápido
  for (let i = activeHighlightTimeouts.length - 1; i >= 0; i--) {
    clearTimeout(activeHighlightTimeouts[i]);
  }
  activeHighlightTimeouts.length = 0;

  // OPTIMIZACIÓN: Usar querySelectorAll una sola vez
  const activeKeys = document.querySelectorAll('.active-treble, .active-bass');
  for (const key of activeKeys) {
    key.classList.remove('active-treble', 'active-bass');
  }
}

function toggleFullScreen() {
  const icon = fullscreenBtn.querySelector('i');
  if (!document.fullscreenElement) {
    // Entrar en pantalla completa
    document.documentElement.requestFullscreen();
    icon.className = 'ri-fullscreen-exit-line'; // Cambia al ícono de "salir"
  } else {
    // Salir de pantalla completa
    if (document.exitFullscreen) {
      document.exitFullscreen();
      icon.className = 'ri-fullscreen-line'; // Cambia al ícono de "entrar"
    }
  }
}

    function applyZoom() {
      if (osmd) {
        osmd.zoom = currentZoom;
        osmd.render();
        updateZoomDisplay();

      }
    }

    function updateZoomDisplay() {
      zoomLabel.textContent = `${Math.round(currentZoom * 100)}%`;
    }

    function updatePlayButton(isPlaying) {
      playIcon.style.display = isPlaying ? 'none' : 'block';
      pauseIcon.style.display = isPlaying ? 'block' : 'none';
    }

    function updateBpmDisplay() {
      const currentBPM = Math.round(globalTempo * currentSpeed);
      speedBpmLabel.textContent = `${currentBPM} BPM`;
    }


function highlightKey(noteName, durSec, hand, persist = false) {
    const noteId = normalizeNote(noteName);
    const el = document.getElementById(noteId);
    if (!el) return;

    const highlightClass = hand === 'treble' ? 'active-treble' : 'active-bass';
    el.classList.add(highlightClass);
    
    // NUEVO: Agregar efecto de flash
    createNoteFlashPiano(noteName, hand);

    if (!persist) {
        const highlightDuration = Math.max(80, durSec * 1000 / currentSpeed);
        const timeoutId = setTimeout(() => {
            el.classList.remove(highlightClass);
            activeHighlightTimeouts = activeHighlightTimeouts.filter(id => id !== timeoutId);
        }, highlightDuration);
        activeHighlightTimeouts.push(timeoutId);
    }
}


function highlightKeyInstant(noteName, hand) {
    const noteId = normalizeNote(noteName);
    const el = document.getElementById(noteId);
    if (!el) return;

    const highlightClass = hand === 'treble' ? 'active-treble' : 'active-bass';
    el.classList.add(highlightClass);
}

function normalizeNote(noteName) {
    const flatToSharp = {
        // Bemoles simples
        'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#',
        // Naturales enarmónicos
        'Cb': 'B', 'Fb': 'E', 'E#': 'F', 'B#': 'C',
        // Dobles bemoles
        'Dbb': 'C', 'Ebb': 'D', 'Fbb': 'D#', 'Gbb': 'F', 'Abb': 'G', 
        'Bbb': 'A', 'Cbb': 'A#',
        // Dobles sostenidos
        'C##': 'D', 'D##': 'E', 'E##': 'F#', 'F##': 'G', 
        'G##': 'A', 'A##': 'B', 'B##': 'C#'
    };
    
    // Regex mejorado para capturar dobles alteraciones
    const match = noteName.match(/^([A-G])(bb|##|b|#)?(\d+)$/);
    if (!match) {
        console.warn(`No se pudo normalizar la nota: ${noteName}`);
        return noteName;
    }
    
    const [, noteLetter, alteration, octave] = match;
    const noteWithAlt = noteLetter + (alteration || ''); // Ej: "C##", "Dbb", "E"
    let normalizedNote = flatToSharp[noteWithAlt] || noteWithAlt;
    let finalOctave = parseInt(octave);
    
    // Casos especiales de cambio de octava
    if (noteWithAlt === 'Cb') {
        normalizedNote = 'B';
        finalOctave -= 1;
    } else if (noteWithAlt === 'Cbb') {
        normalizedNote = 'A#';
        finalOctave -= 1;
    } else if (noteWithAlt === 'B#') {
        normalizedNote = 'C';
        finalOctave += 1;
    } else if (noteWithAlt === 'B##') {
        normalizedNote = 'C#';
        finalOctave += 1;
    }
    
    return normalizedNote + finalOctave;
}

function advanceLearningStep() {
  const activeKeys = document.querySelectorAll('.active-treble, .active-bass');
  activeKeys.forEach(key => key.classList.remove('active-treble', 'active-bass'));
  activeHighlightTimeouts.forEach(clearTimeout);
  activeHighlightTimeouts.length = 0;
  expectedNotes.clear();

  if (currentLearningIndex >= parsedNotes.length) {
    showSuccessModal("¡Felicidades, has completado la pieza!");
    showConfetti(200);
    toggleMidiLearnMode();
    return;
  }

  let notesInStep = [];
  let foundValidStep = false;
  const TIME_TOLERANCE = 0.001;

  // NUEVO: Saltar automáticamente sobre silencios
  while (currentLearningIndex < parsedNotes.length && !foundValidStep) {
    const nextNoteTime = parsedNotes[currentLearningIndex].startSec;
    notesInStep = [];
    
    // Recopilar todas las notas en este momento
    while (currentLearningIndex < parsedNotes.length && 
           Math.abs(parsedNotes[currentLearningIndex].startSec - nextNoteTime) < TIME_TOLERANCE) {
      notesInStep.push(parsedNotes[currentLearningIndex]);
      currentLearningIndex++;
    }

    // Filtrar por mano
    const filteredNotes = notesInStep.filter(note => 
      !note.isRest &&
      !note.isTiedContinuation &&
      (handFilterMode === 'both' || 
      (handFilterMode === 'right' && note.hand === 'treble') ||
      (handFilterMode === 'left' && note.hand === 'bass'))
    );

    if (filteredNotes.length > 0) {
      foundValidStep = true;
      notesInStep = filteredNotes;
      
      osmd.cursor.next();
      
      const uniquePitches = new Set();
      
      notesInStep.forEach(note => {
        const normalizedNote = normalizeNote(note.pitch);
        
        if (!uniquePitches.has(normalizedNote)) {
          uniquePitches.add(normalizedNote);
          expectedNotes.add(normalizedNote);
          highlightKeyInstant(note.pitch, note.hand);
        }
      });
      
      console.log(`Notas esperadas (${handFilterMode}):`, Array.from(expectedNotes));
    } else {
      // NUEVO: Si no hay notas que tocar (solo silencios), avanzar el cursor automáticamente
      console.log(`Silencio detectado en tiempo ${nextNoteTime}s, avanzando cursor...`);
      osmd.cursor.next();
      // Continuar el bucle para buscar la siguiente nota
    }
  }

  if (!foundValidStep && currentLearningIndex >= parsedNotes.length) {
    showSuccessModal("¡Felicidades, has completado la pieza!");
    showConfetti(200);
    toggleMidiLearnMode();
    return;
  }
  updateMeasureSelectDisplay();
  updatePracticeProgress();
}

    function setStatus(text) { 
      statusDiv.textContent = text;
      statusDiv.style.display = text ? 'block' : 'none';
    }


function showSuccessModal(message) {
  successModalMessage.textContent = message;
  successModal.style.display = 'flex';
  setTimeout(() => {
    successModal.classList.add('is-visible');
  }, 10);
}


function hideSuccessModal() {
  successModal.classList.remove('is-visible');
  setTimeout(() => {
    successModal.style.display = 'none';
  }, 300); 
}


function showConfetti(count = 100) {
  const colors = ['#6f42c1', '#48aee9', '#28a745', '#ffc107', '#dc3545'];
  for (let i = 0; i < count; i++) {
    const confetti = document.createElement('div');
    confetti.className = 'confetti';
    confetti.style.left = `${Math.random() * 100}vw`;
    confetti.style.top = `${-20 - Math.random() * 10}vh`; 
    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
    confetti.style.animationDelay = `${Math.random() * 0.5}s`;
    confetti.style.animationDuration = `${3 + Math.random() * 2}s`;
    
    document.body.appendChild(confetti);
    setTimeout(() => confetti.remove(), 5000);
  }
}

function toggleMidiLearnMode() {
    if (isMidiLearnMode === false && (!midiAccess || midiAccess.inputs.size === 0)) {
        showModal("🎹 No se detectó ningún teclado MIDI. Por favor, conecta uno e inténtalo de nuevo.");
        initMidiInput();
        return; 
    }

    isMidiLearnMode = !isMidiLearnMode;
    stopPlayback(); 

    if (isMidiLearnMode) {
        midiLearnBtn.style.background = '#e0e0e0';
        playBtn.disabled = true;
        progressBar.disabled = true;
        currentLearningIndex = 0;
        osmd.cursor.show();

        cursorBtn.style.color = '#3498db';
        Object.assign(osmd.cursor.cursorOptions, {
            type: 5,
            alpha: 0.7,
            color: "rgba(52, 152, 219, 0.7)"
        });
        
        handFilterMode = 'both';
        rightHandOnlyBtn.style.background = 'none';
        leftHandOnlyBtn.style.background = 'none';
        secondaryTopBar2.classList.add('is-visible');

        prepareFirstLearningStep(); 
        measureSelect.value = 0;
        
    } else {
    midiLearnBtn.style.background = 'none';
    playBtn.disabled = false;
    progressBar.disabled = false;
    clearAllHighlights(); 
    osmd.cursor.reset();
    osmd.cursor.hide();
    
    cursorBtn.style.color = '#1a1a1a';
    Object.assign(osmd.cursor.cursorOptions, {
        type: 1,
        alpha: 0.8,
        color: "rgba(52, 152, 219, 0.8)"
    });

    secondaryTopBar2.classList.remove('is-visible');
    handFilterMode = 'both';
    updateStaffOpacity('both'); // NUEVO: Restaurar opacidad normal
    rightHandOnlyBtn.style.background = 'none';
    leftHandOnlyBtn.style.background = 'none';
}
}


function prepareFirstLearningStep() {
  clearAllHighlights();
  expectedNotes.clear();

  if (currentLearningIndex >= parsedNotes.length) {
    showSuccessModal("¡Felicidades, has completado la pieza!");
    showConfetti(200);
    toggleMidiLearnMode();
    return;
  }

  let notesInStep = [];
  let foundValidStep = false;
  const TIME_TOLERANCE = 0.001;

  while (currentLearningIndex < parsedNotes.length && !foundValidStep) {
    const nextNoteTime = parsedNotes[currentLearningIndex].startSec;
    notesInStep.length = 0;
    
    while (currentLearningIndex < parsedNotes.length && 
           Math.abs(parsedNotes[currentLearningIndex].startSec - nextNoteTime) < TIME_TOLERANCE) {
      notesInStep.push(parsedNotes[currentLearningIndex]);
      currentLearningIndex++;
    }

    const filteredNotes = notesInStep.filter(note => 
      !note.isRest &&
      !note.isTiedContinuation &&
      (handFilterMode === 'both' || 
      (handFilterMode === 'right' && note.hand === 'treble') ||
      (handFilterMode === 'left' && note.hand === 'bass'))
    );

    if (filteredNotes.length > 0) {
      foundValidStep = true;
      
      // OPTIMIZACIÓN: Usar Set directamente
      const uniquePitches = new Set();
      
      for (const note of filteredNotes) {
        const normalizedNote = normalizeNote(note.pitch);
        
        if (!uniquePitches.has(normalizedNote)) {
          uniquePitches.add(normalizedNote);
          expectedNotes.add(normalizedNote);
          highlightKeyInstant(note.pitch, note.hand);
        }
      }
      
      console.log(`Notas esperadas (${handFilterMode}):`, Array.from(expectedNotes));
    }
  }

  if (!foundValidStep && currentLearningIndex >= parsedNotes.length) {
    alert("¡No hay notas para la mano seleccionada en esta pieza!");
    toggleMidiLearnMode();
  }
  updatePracticeProgress();
}


function updateStaffOpacity(mode) {
    if (!osmd || !osmd.graphic) {
        console.warn("OSMD no está listo.");
        return;
    }
    
    const svgContainer = osmdContainer.querySelector('svg');
    if (!svgContainer) return;
    
    // Buscar los contenedores PADRE que agrupan todos los compases de cada pentagrama
    // Típicamente son los <g> que contienen MÚLTIPLES grupos con 5+ paths
    const allGroups = Array.from(svgContainer.querySelectorAll('g'));
    
    const staffLineContainers = allGroups.filter(group => {
        // Contar cuántos sub-grupos con 5+ paths tiene
        const subGroups = group.querySelectorAll('g');
        let staffCount = 0;
        subGroups.forEach(sub => {
            const paths = sub.querySelectorAll(':scope > path');
            if (paths.length >= 5) staffCount++;
        });
        // Un contenedor de pentagrama completo tendrá múltiples compases (staffCount > 1)
        return staffCount > 1;
    });
    
    console.log(`Encontrados ${staffLineContainers.length} contenedores de pentagramas completos`);
    
    staffLineContainers.forEach((container, index) => {
        const isTreble = index % 2 === 0;
        
        switch (mode) {
            case 'right':
                container.style.opacity = isTreble ? '1' : '0.2';
                break;
            case 'left':
                container.style.opacity = isTreble ? '0.2' : '1';
                break;
            case 'both':
            default:
                container.style.opacity = '1';
                break;
        }
        container.style.transition = 'opacity 0.3s ease';
        
        console.log(`Contenedor ${index} (${isTreble ? 'Treble' : 'Bass'}): opacity ${container.style.opacity}`);
    });
}

function toggleRightHandOnly() {
  if (handFilterMode === 'right') {
    // Si ya está activo, desactivar
    handFilterMode = 'both';
    rightHandOnlyBtn.style.background = 'none';
    leftHandOnlyBtn.style.background = 'none';
    rightHandOnlyBtn.style.color = '#1a1a1a';
    leftHandOnlyBtn.style.color = '#1a1a1a';
  } else {
    // Activar solo mano derecha
    handFilterMode = 'right';
    rightHandOnlyBtn.style.background = '#e0e0e0';
    rightHandOnlyBtn.style.color = '#3498db';
    leftHandOnlyBtn.style.background = 'none';
    leftHandOnlyBtn.style.color = '#1a1a1a';
  }

  // NUEVO: Actualizar opacidad de los pentagramas
  updateStaffOpacity(handFilterMode);
  
  // MODIFICACIÓN: Si estamos en modo aprendizaje, saltar notas de la otra mano
  if (isMidiLearnMode) {
    skipToNextRelevantNote();
  }
  
  console.log(`Modo de mano: ${handFilterMode}`);
}

function toggleLeftHandOnly() {
  if (handFilterMode === 'left') {
    // Si ya está activo, desactivar
    handFilterMode = 'both';
    rightHandOnlyBtn.style.background = 'none';
    leftHandOnlyBtn.style.background = 'none';
    rightHandOnlyBtn.style.color = '#1a1a1a';
    leftHandOnlyBtn.style.color = '#1a1a1a';
  } else {
    // Activar solo mano izquierda
    handFilterMode = 'left';
    leftHandOnlyBtn.style.background = '#e0e0e0';
    leftHandOnlyBtn.style.color = '#3498db';
    rightHandOnlyBtn.style.background = 'none';
    rightHandOnlyBtn.style.color = '#1a1a1a';
  }

  // NUEVO: Actualizar opacidad de los pentagramas
  updateStaffOpacity(handFilterMode);
  
  // MODIFICACIÓN: Si estamos en modo aprendizaje, saltar notas de la otra mano
  if (isMidiLearnMode) {
    skipToNextRelevantNote();
  }
  
  console.log(`Modo de mano: ${handFilterMode}`);
}


function skipToNextRelevantNote() {
  if (!isMidiLearnMode) return;
  
  clearAllHighlights();
  expectedNotes.clear();
  
  const TIME_TOLERANCE = 0.001;
  let foundRelevantNote = false;
  
  // Retroceder al inicio del paso actual para recalcular
  let tempIndex = currentLearningIndex - 1;
  const currentTime = parsedNotes[tempIndex]?.startSec;
  
  // Retroceder hasta el inicio del acorde/paso actual
  while (tempIndex > 0 && Math.abs(parsedNotes[tempIndex - 1]?.startSec - currentTime) < TIME_TOLERANCE) {
    tempIndex--;
  }
  
  // Restaurar el índice al inicio del paso actual
  currentLearningIndex = tempIndex;
  
  // Buscar la siguiente nota relevante para la mano seleccionada
  while (currentLearningIndex < parsedNotes.length && !foundRelevantNote) {
    const nextNoteTime = parsedNotes[currentLearningIndex].startSec;
    const notesInStep = [];
    
    // Recopilar todas las notas en este momento
    const stepStartIndex = currentLearningIndex;
    while (currentLearningIndex < parsedNotes.length && 
           Math.abs(parsedNotes[currentLearningIndex].startSec - nextNoteTime) < TIME_TOLERANCE) {
      notesInStep.push(parsedNotes[currentLearningIndex]);
      currentLearningIndex++;
    }
    
    // Filtrar por mano seleccionada
    const filteredNotes = notesInStep.filter(note => 
      !note.isRest &&
      !note.isTiedContinuation &&
      (handFilterMode === 'both' || 
      (handFilterMode === 'right' && note.hand === 'treble') ||
      (handFilterMode === 'left' && note.hand === 'bass'))
    );
    
    if (filteredNotes.length > 0) {
      // Encontramos notas relevantes, preparar para tocarlas
      foundRelevantNote = true;
      
      // Avanzar el cursor a la posición correcta
      osmd.cursor.reset();
      let cursorTime = -1;
      for (let i = 0; i < stepStartIndex; i++) {
        if (parsedNotes[i].startSec !== cursorTime) {
          osmd.cursor.next();
          cursorTime = parsedNotes[i].startSec;
        }
      }
      
      // Highlight de las notas esperadas
      const uniquePitches = new Set();
      filteredNotes.forEach(note => {
        const normalizedNote = normalizeNote(note.pitch);
        if (!uniquePitches.has(normalizedNote)) {
          uniquePitches.add(normalizedNote);
          expectedNotes.add(normalizedNote);
          highlightKey(note.pitch, note.durSec, note.hand, true);
        }
      });
      
      console.log(`Saltando a notas relevantes (${handFilterMode}):`, Array.from(expectedNotes));
    } else {
      // No hay notas relevantes en este paso, avanzar cursor automáticamente
      osmd.cursor.next();
    }
  }
  
  if (!foundRelevantNote) {
    // No se encontraron más notas para la mano seleccionada
    showSuccessModal(`¡Has completado todas las notas de la mano ${handFilterMode === 'right' ? 'derecha' : 'izquierda'}!`);
    showConfetti(100);
  }
}

function reloadCurrentStepWithHandFilter() {
  if (!isMidiLearnMode) return;
  
  const TIME_TOLERANCE = 0.001;
  
  const currentStepNotes = [];
  const targetTime = parsedNotes[currentLearningIndex - 1]?.startSec;
  
  let tempIndex = currentLearningIndex - 1;
  while (tempIndex >= 0 && Math.abs(parsedNotes[tempIndex]?.startSec - targetTime) < TIME_TOLERANCE) {
    currentStepNotes.unshift(parsedNotes[tempIndex]);
    tempIndex--;
  }
  
  clearAllHighlights();
  expectedNotes.clear();
  
  const filteredNotes = currentStepNotes.filter(note => 
    handFilterMode === 'both' || 
    (handFilterMode === 'right' && note.hand === 'treble') ||
    (handFilterMode === 'left' && note.hand === 'bass')
  );
  
  if (filteredNotes.length > 0) {
    const uniquePitches = new Set();
    
    filteredNotes.forEach(note => {
      const normalizedNote = normalizeNote(note.pitch);
      
      if (!uniquePitches.has(normalizedNote)) {
        uniquePitches.add(normalizedNote);
        expectedNotes.add(normalizedNote);
        highlightKey(note.pitch, note.durSec, note.hand, true);
      }
    });
    
    console.log(`Notas esperadas (${handFilterMode}):`, Array.from(expectedNotes));
  } else {
    console.log(`Paso actual no tiene notas de ${handFilterMode}, avanzando...`);
    advanceLearningStep();
  }
}




function initMidiInput() {
    if (navigator.requestMIDIAccess) {
        navigator.requestMIDIAccess()
            .then(onMIDISuccess, onMIDIFailure);
    } 
}



function onMIDISuccess(access) {
    midiAccess = access;
    let connectedInputs = new Map();

    const handlePortChange = (port) => {
        if (port.type !== 'input') return; // Ignoramos puertos de salida

        if (port.state === 'connected') {
            console.log(`MIDI Conectado: ${port.name}`);
            port.onmidimessage = onMIDIMessage; // Asigna el listener
            connectedInputs.set(port.id, port);
        } else if (port.state === 'disconnected') {
            console.log(`MIDI Desconectado: ${port.name}`);
            connectedInputs.delete(port.id); // Elimina del rastreo
        }

        if (connectedInputs.size > 0) {
            const firstDeviceName = connectedInputs.values().next().value.name;
            updateMidiStatusLegend(firstDeviceName);
        } else {
            updateMidiStatusLegend(null);
        }
    };

    // Asigna el listener para futuros cambios (conectar/desconectar)
    midiAccess.onstatechange = (event) => handlePortChange(event.port);

    // Escaneo inicial de dispositivos YA conectados al cargar la página
    const inputs = midiAccess.inputs.values();
    for (const input of inputs) {
        handlePortChange(input); // Usa la misma lógica
    }
}


function onMIDIFailure() {
    showModal("⚠️ No se pudo acceder a tus dispositivos MIDI. Asegúrate de dar permiso en el navegador.");
    isMidiLearnMode = false;
    midiLearnBtn.style.background = 'none';
    playBtn.disabled = false;
}


function onMIDIMessage(event) {
    const command = event.data[0];
    const note = event.data[1];
    const velocity = event.data.length > 2 ? event.data[2] : 0;

    if (command === 144 && velocity > 0) {
        const pitchName = midiNoteToPitchName(note);
        highlightMidiKey(pitchName);
        

if (isIntelligentPracticeMode && isMidiLearnMode) {
    if (practiceStartTime === null) {
        practiceStartTime = Date.now();
    }
    
    const normalizedNote = normalizeNote(pitchName);
    
    // Verificar si la nota está en las esperadas del modo normal
    if (expectedNotes.has(normalizedNote)) {
        // Usar la lógica normal del modo aprendizaje
        sampler.triggerAttackRelease(pitchName, '8n');
        expectedNotes.delete(normalizedNote);
        createNoteFlashPiano(pitchName, 'treble');
        practiceCorrectNotes++;
        
        console.log(`✓ Correcta: ${normalizedNote}, Quedan: ${expectedNotes.size}`);
        
        // Cuando se completan todas las notas del paso actual
        if (expectedNotes.size === 0) {
            // Avanzar normalmente
            if (currentLearningIndex > 0) {
                advanceLearningStep();
            } else {
                prepareFirstLearningStep();
            }
            
            // Verificar si completó el rango de compases de esta fase
            checkPracticePhaseCompletion();
        }
        
        // Actualizar progreso en tiempo real
        updatePracticeAccuracy();
    } else {
        // Nota incorrecta
        practiceErrors++;
        console.log(`✗ Error: Nota ${normalizedNote} incorrecta. Total errores: ${practiceErrors}`);
        updatePracticeAccuracy();
    }
    
    return; // No ejecutar la lógica normal
}
        
        // LÓGICA NORMAL DE LEARNING MODE
        if (isMidiLearnMode && expectedNotes.size > 0) {
            const normalizedMidiNote = normalizeNote(pitchName);
            
            if (expectedNotes.has(normalizedMidiNote)) {
                sampler.triggerAttackRelease(pitchName, '8n');
                expectedNotes.delete(normalizedMidiNote);
                createNoteFlashPiano(pitchName, 'treble');
                
                if (expectedNotes.size === 0) {
                    if (currentLearningIndex > 0) {
                        advanceLearningStep();
                    } else {
                        prepareFirstLearningStep();
                    }
                }
            }
        }
    } else if (command === 128 || (command === 144 && velocity === 0)) {
        const pitchName = midiNoteToPitchName(note);
        unhighlightMidiKey(pitchName);
    }
}
/*
function onMIDIMessage(event) {
    const command = event.data[0];
    const note = event.data[1];
    const velocity = event.data.length > 2 ? event.data[2] : 0;

    if (command === 144 && velocity > 0) {
        // NOTE ON - Colorear la tecla
        const pitchName = midiNoteToPitchName(note);
        highlightMidiKey(pitchName);
        
        // Lógica existente del modo aprendizaje
        if (isMidiLearnMode && expectedNotes.size > 0) {
            // NORMALIZAR la nota MIDI para comparación
            const normalizedMidiNote = normalizeNote(pitchName);
            
            // Verificar si la nota normalizada está en expectedNotes
            if (expectedNotes.has(normalizedMidiNote)) {
                sampler.triggerAttackRelease(pitchName, '8n');
                expectedNotes.delete(normalizedMidiNote);
                createNoteFlashPiano(pitchName, 'treble');
                console.log(`¡Correcto! Nota ${pitchName} (normalizada: ${normalizedMidiNote}). Faltan ${expectedNotes.size}.`);
                
                if (expectedNotes.size === 0) {

                        if (currentLearningIndex > 0) {
                            advanceLearningStep();
                        } else {
                            prepareFirstLearningStep();
                        }
                }
            } else {
                console.log(`Nota ${pitchName} (normalizada: ${normalizedMidiNote}) no está en expectedNotes:`, Array.from(expectedNotes));
            }
        }
    } else if (command === 128 || (command === 144 && velocity === 0)) {
        // NOTE OFF - Quitar el color
        const pitchName = midiNoteToPitchName(note);
        unhighlightMidiKey(pitchName);
    }
}
*/

// Añade estas nuevas funciones para el coloreado MIDI
function highlightMidiKey(noteName) {
    const noteId = noteName.replace('b', '#');
    const el = document.getElementById(noteId);
    if (el) {
        el.classList.add('midi-active');
    }
}

function unhighlightMidiKey(noteName) {
    const noteId = noteName.replace('b', '#');
    const el = document.getElementById(noteId);
    if (el) {
        el.classList.remove('midi-active');
    }
}




//MODO INTELIGENTE
function toggleIntelligentPracticeMode() {
    if (!isMidiLearnMode) {
        showModal("⚠️ Debes activar el Modo Aprendizaje MIDI primero.");
        return;
    }
    
    if (!midiAccess || midiAccess.inputs.size === 0) {
        showModal("🎹 No se detectó ningún teclado MIDI conectado.");
        return;
    }
    
    isIntelligentPracticeMode = !isIntelligentPracticeMode;
    
    if (isIntelligentPracticeMode) {
        aiPracticeBtn.style.background = '#e0e0e0';
        aiPracticeBtn.style.borderColor = '#3498db';
        startIntelligentPractice();
    } else {
        aiPracticeBtn.style.background = 'none';
        aiPracticeBtn.style.borderColor = 'transparent';
        stopIntelligentPractice();
    }
}

function startIntelligentPractice() {
    currentPracticePhase = 'right-hand';
    currentPracticeMeasureSet = 0;
    practiceErrors = 0;
    practiceCorrectNotes = 0;
    
    // Saltar al primer compás
    jumpToMeasureInLearnMode(0);
    
    // Iniciar con mano derecha
    handFilterMode = 'right';
    updateHandButtons();
    updateStaffOpacity('right');
    
    showModal(`🎹 Práctica Inteligente Iniciada<br><br>
               Toca los compases 1-4 con la MANO DERECHA.<br><br>
               El sistema medirá tu precisión y velocidad.`);
    
    preparePracticePhase();
}

function stopIntelligentPractice() {
    isIntelligentPracticeMode = false;
    currentPracticePhase = 'inactive';
    handFilterMode = 'both';
    updateHandButtons();
    updateStaffOpacity('both');
    progressValueSpan.textContent = '0%';
}

function updatePracticeAccuracy() {
    const totalNotes = practiceCorrectNotes + practiceErrors;
    const currentAccuracy = totalNotes > 0 ? 
        ((practiceCorrectNotes / totalNotes) * 100).toFixed(0) : 100;
    progressValueSpan.textContent = `${currentAccuracy}%`;
}

function checkPracticePhaseCompletion() {
    // Determinar el rango de compases de la fase actual
    let startMeasure, endMeasure;
    
    if (currentPracticePhase === 'consolidation') {
        startMeasure = 0;
        endMeasure = Math.min((currentPracticeMeasureSet + 1) * 4, measureStartTimes.length - 1);
    } else {
        startMeasure = currentPracticeMeasureSet * 4;
        endMeasure = Math.min(startMeasure + 4, measureStartTimes.length - 1);
    }
    
    const endTime = measureStartTimes[endMeasure];
    
    // Verificar si llegamos al final del rango
    if (currentLearningIndex > 0 && parsedNotes[currentLearningIndex - 1]) {
        const currentTime = parsedNotes[currentLearningIndex - 1].startSec;
        
        // Si ya pasamos el tiempo final del rango, evaluar
        if (currentTime >= endTime - 0.01) {
            console.log('✅ Rango de compases completado, evaluando...');
            setTimeout(() => {
                evaluatePracticeAttempt();
            }, 500);
        }
    }
}

function preparePracticePhase() {
    practiceAttemptNotes = [];
    practiceStartTime = null;
    practiceErrors = 0;
    practiceCorrectNotes = 0;
    
    // Determinar el rango de compases a practicar
    let startMeasure, endMeasure;
    
    if (currentPracticePhase === 'consolidation') {
        startMeasure = 0;
        endMeasure = Math.min((currentPracticeMeasureSet + 1) * 4, measureStartTimes.length - 1);
    } else {
        startMeasure = currentPracticeMeasureSet * 4;
        endMeasure = Math.min(startMeasure + 4, measureStartTimes.length - 1);
    }
    
    // Saltar al compás de inicio usando la función existente
    jumpToMeasureInLearnMode(startMeasure);
    
    console.log(`Fase: ${currentPracticePhase}, Compases: ${startMeasure + 1}-${endMeasure}, 
                 Filtro de mano: ${handFilterMode}`);
}

function areEnharmonicEquivalents(note1, note2) {
    if (note1 === note2) return true;
    const midi1 = pitchToMidiNumber(note1);
    const midi2 = pitchToMidiNumber(note2);
    
    return midi1 === midi2;
}

function updateHandButtons() {
    if (handFilterMode === 'right') {
        rightHandOnlyBtn.style.background = '#e0e0e0';
        rightHandOnlyBtn.style.color = '#3498db';
        leftHandOnlyBtn.style.background = 'none';
        leftHandOnlyBtn.style.color = '#1a1a1a';
    } else if (handFilterMode === 'left') {
        leftHandOnlyBtn.style.background = '#e0e0e0';
        leftHandOnlyBtn.style.color = '#3498db';
        rightHandOnlyBtn.style.background = 'none';
        rightHandOnlyBtn.style.color = '#1a1a1a';
    } else {
        rightHandOnlyBtn.style.background = 'none';
        leftHandOnlyBtn.style.background = 'none';
        rightHandOnlyBtn.style.color = '#1a1a1a';
        leftHandOnlyBtn.style.color = '#1a1a1a';
    }
}

function evaluatePracticeAttempt() {
    // Contar las notas esperadas en el rango completado
    let startMeasure, endMeasure;
    
    if (currentPracticePhase === 'consolidation') {
        startMeasure = 0;
        endMeasure = Math.min((currentPracticeMeasureSet + 1) * 4, measureStartTimes.length - 1);
    } else {
        startMeasure = currentPracticeMeasureSet * 4;
        endMeasure = Math.min(startMeasure + 4, measureStartTimes.length - 1);
    }
    
    const startTime = measureStartTimes[startMeasure];
    const endTime = measureStartTimes[endMeasure];
    
    // Contar notas esperadas según el filtro de mano
    const totalExpectedNotes = parsedNotes.filter(note => {
        return note.startSec >= startTime && 
               note.startSec < endTime && 
               !note.isRest && 
               !note.isTiedContinuation &&
               ((currentPracticePhase === 'right-hand' && note.hand === 'treble') ||
                (currentPracticePhase === 'left-hand' && note.hand === 'bass') ||
                (currentPracticePhase === 'both-hands') ||
                (currentPracticePhase === 'consolidation'));
    }).length;
    
    if (totalExpectedNotes === 0) {
        console.warn("No hay notas esperadas para evaluar");
        advancePracticePhase();
        return;
    }
    
    const accuracy = ((practiceCorrectNotes / totalExpectedNotes) * 100).toFixed(0);
    const totalTime = (Date.now() - practiceStartTime) / 1000;
    const avgTimePerNote = (totalTime / totalExpectedNotes).toFixed(2);
    
    progressValueSpan.textContent = `${accuracy}%`;
    
    // Mostrar resultados
    let message = `📊 <strong>Resultados:</strong><br><br>
                   Precisión: <strong>${accuracy}%</strong><br>
                   Notas correctas: ${practiceCorrectNotes}/${totalExpectedNotes}<br>
                   Errores: ${practiceErrors}<br>
                   Tiempo total: ${totalTime.toFixed(1)}s<br>
                   Tiempo promedio: ${avgTimePerNote}s/nota<br><br>`;
    
    if (parseInt(accuracy) >= accuracyThreshold) {
        message += '✅ <strong>¡Excelente!</strong> Pasando a la siguiente fase...';
        showModal(message);
        setTimeout(() => {
            hideModal();
            setTimeout(() => {
                advancePracticePhase();
            }, 500);
        }, 3000);
    } else {
        message += `❌ Necesitas al menos <strong>${accuracyThreshold}%</strong> de precisión.<br>
                    Inténtalo de nuevo.`;
        showModal(message);
        setTimeout(() => {
            hideModal();
            setTimeout(() => {
                preparePracticePhase();
            }, 500);
        }, 3000);
    }
}

function advancePracticePhase() {
    const startMeasure = currentPracticeMeasureSet * 4;
    const endMeasure = Math.min(startMeasure + 4, measureStartTimes.length);
    const measureRange = `${startMeasure + 1}-${endMeasure}`;
    
    if (currentPracticePhase === 'right-hand') {
        currentPracticePhase = 'left-hand';
        handFilterMode = 'left';
        updateHandButtons();
        updateStaffOpacity('left');
        showModal(`🎹 <strong>Fase 2:</strong><br><br>Ahora practica los compases <strong>${measureRange}</strong><br>con la <strong>MANO IZQUIERDA</strong>.`);
        setTimeout(() => {
            hideModal();
            preparePracticePhase();
        }, 3000);
        
    } else if (currentPracticePhase === 'left-hand') {
        currentPracticePhase = 'both-hands';
        handFilterMode = 'both';
        updateHandButtons();
        updateStaffOpacity('both');
        showModal(`🎹 <strong>Fase 3:</strong><br><br>¡Perfecto! Ahora toca los compases <strong>${measureRange}</strong><br>con <strong>AMBAS MANOS</strong>.`);
        setTimeout(() => {
            hideModal();
            preparePracticePhase();
        }, 3000);
        
    } else if (currentPracticePhase === 'both-hands') {
        const nextSetStart = (currentPracticeMeasureSet + 1) * 4;
        
        if (nextSetStart < measureStartTimes.length - 1) {
            currentPracticeMeasureSet++;
            currentPracticePhase = 'right-hand';
            handFilterMode = 'right';
            updateHandButtons();
            updateStaffOpacity('right');
            
            const newRange = `${nextSetStart + 1}-${Math.min(nextSetStart + 4, measureStartTimes.length)}`;
            showModal(`🎹 <strong>¡Excelente progreso!</strong><br><br>
                       Ahora practica los compases <strong>${newRange}</strong><br>
                       con la <strong>MANO DERECHA</strong>.`);
            setTimeout(() => {
                hideModal();
                preparePracticePhase();
            }, 3000);
            
        } else {
            startConsolidationPhase();
        }
    } else if (currentPracticePhase === 'consolidation') {
        // Completó la consolidación
        showSuccessModal("🎉 ¡Felicidades!<br><br>Has completado toda la práctica inteligente.<br>¡Excelente trabajo!");
        showConfetti(300);
        setTimeout(() => {
            stopIntelligentPractice();
        }, 3000);
    }
}

function startConsolidationPhase() {
    currentPracticePhase = 'consolidation';
    handFilterMode = 'both';
    updateHandButtons();
    updateStaffOpacity('both');
    
    const totalMeasures = currentPracticeMeasureSet * 4 + 4;
    showModal(`🎉 ¡Fase de Consolidación!<br><br>
               Toca los compases 1-${totalMeasures}<br>
               con AMBAS MANOS de forma continua.`);
    
    jumpToMeasureInLearnMode(0);
    preparePracticePhase();
}







function prepareNextExpectedNotes() {
    expectedNotes.clear();
    if (currentLearningIndex >= parsedNotes.length) {
        console.log("¡Felicidades, terminaste la pieza!");
        toggleMidiLearnMode(); // Desactiva el modo al final
        return;
    }

    // Obtenemos el tiempo de la siguiente nota
    const nextNoteTime = parsedNotes[currentLearningIndex].startSec;
    
    // Buscamos todas las notas que suenan en ESE MISMO MOMENTO (acordes)
    while (currentLearningIndex < parsedNotes.length && parsedNotes[currentLearningIndex].startSec === nextNoteTime) {
        expectedNotes.add(parsedNotes[currentLearningIndex].pitch);
        currentLearningIndex++;
    }
    
    // Opcional: Muestra en la consola qué notas se esperan
    console.log("Esperando notas:", Array.from(expectedNotes));
}

function midiNoteToPitchName(midiNote) {
    const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const octave = Math.floor(midiNote / 12) - 1;
    const noteName = noteNames[midiNote % 12];
    return noteName + octave;
}


function showModal(message, duration = 0) {
    modalMessage.innerHTML = message; 
    //modalMessage.textContent = message;
    midiModal.style.display = 'flex';
    setTimeout(() => {
        midiModal.classList.add('is-visible');
    }, 10);

    if (duration > 0) {
        setTimeout(() => {
            hideModal();
        }, duration);
    }
}


function hideModal() {
    midiModal.classList.remove('is-visible');
    // Esperamos a que la transición termine para ocultarlo con display:none
    setTimeout(() => {
        midiModal.style.display = 'none';
    }, 300);
}

  </script>
</body>
</html>    
